---
title: Sicherheitsüberlegungen zu Daten
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 8b54aea1409f2b4c0a3d39d215922ba62c2a3563
ms.sourcegitcommit: c4a15c6c4ecbb8a46ad4e67d9b3ab9b8b031d849
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "88656969"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="6e84a-102">Sicherheitsüberlegungen zu Daten</span><span class="sxs-lookup"><span data-stu-id="6e84a-102">Security Considerations for Data</span></span>

<span data-ttu-id="6e84a-103">Beim Umgang mit Daten in Windows Communication Foundation (WCF) müssen Sie eine Reihe von Bedrohungs Kategorien in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-103">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="6e84a-104">In der folgenden Tabelle werden die wichtigsten Bedrohungskategorien der Datenverarbeitung aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-104">The following table lists the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="6e84a-105">WCF bietet Tools, mit denen diese Bedrohungen minimiert werden können.</span><span class="sxs-lookup"><span data-stu-id="6e84a-105">WCF provides tools to mitigate these threats.</span></span>

<span data-ttu-id="6e84a-106">Ein Denial-of-Service-Vorgang beim Empfang nicht vertrauenswürdiger Daten kann dazu führen, dass die Empfängerseite auf eine unverhältnismäßig große Menge verschiedener Ressourcen wie Arbeitsspeicher, Threads, verfügbare Verbindungen oder Prozessor Zyklen zugreifen kann, indem lange Berechnungen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-106">Denial of service When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="6e84a-107">Ein Denial-of-Service-Angriff führt möglicherweise zum Absturz des Servers, wodurch er keine Nachrichten von anderen, legitimen Clients verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-107">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

<span data-ttu-id="6e84a-108">Eingehende nicht vertrauenswürdige Daten mit böswilliger Codeausführung bewirken, dass die empfangende Seite Code ausführen kann, der nicht beabsichtigt war.</span><span class="sxs-lookup"><span data-stu-id="6e84a-108">Malicious code execution Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

<span data-ttu-id="6e84a-109">Die Offenlegung von Informationen durch den Remote Angreifer zwingt die empfangende Partei, auf Ihre Anforderungen so zu reagieren, dass mehr Informationen als beabsichtigt offengelegt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-109">Information disclosure The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="6e84a-110">Vom Benutzer bereitgestellter Code und Codezugriffssicherheit</span><span class="sxs-lookup"><span data-stu-id="6e84a-110">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="6e84a-111">An mehreren Stellen in der Windows Communication Foundation (WCF)-Infrastruktur wird Code ausgeführt, der vom Benutzer bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-111">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="6e84a-112">Die Serialisierungs-Engine <xref:System.Runtime.Serialization.DataContractSerializer> z. B. kann vom Benutzer bereitgestellte `set` - und `get` -Eigenschaftenaccessoren aufrufen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-112">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="6e84a-113">Von der WCF-Kanal Infrastruktur können auch vom Benutzer bereitgestellte abgeleitete Klassen der-Klasse aufgerufen werden <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="6e84a-113">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="6e84a-114">Der Autor des Codes muss sicherstellen, dass kein Sicherheitsrisiko entsteht.</span><span class="sxs-lookup"><span data-stu-id="6e84a-114">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="6e84a-115">Angenommen, Sie erstellen einen Datenvertragstyp mit einer Datenmembereigenschaft vom Typ Integer und ordnen in der Implementierung des `set` -Accessors basierend auf dem Eigenschaftswert ein Array zu. In diesem Fall setzen Sie den Server der Gefahr eines Denial-of-Service-Angriffs aus, wenn eine böswillige Nachricht einen extrem langen Wert für diesen Datenmember enthält.</span><span class="sxs-lookup"><span data-stu-id="6e84a-115">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="6e84a-116">Vermeiden Sie in der Regel Zuordnungen, die auf eingehenden Daten oder langwierigen Verarbeitungen im Benutzercode basieren (insbesondere, wenn die langwierige Verarbeitung durch wenige eingehende Daten verursacht werden kann).</span><span class="sxs-lookup"><span data-stu-id="6e84a-116">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="6e84a-117">Berücksichtigen Sie bei der Sicherheitsanalyse von Benutzercode auch alle möglichen Schwachstellen (d. h. alle Codeverzweigungen, an denen Ausnahmen ausgelöst werden).</span><span class="sxs-lookup"><span data-stu-id="6e84a-117">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="6e84a-118">Der Code, der sich innerhalb der Dienstimplementierung für die einzelnen Vorgänge befindet, ist das letzte Beispiel für Benutzercode.</span><span class="sxs-lookup"><span data-stu-id="6e84a-118">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="6e84a-119">Für die Sicherheit Ihrer Dienstimplementierung sind Sie verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="6e84a-119">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="6e84a-120">Es kann leicht passieren, dass versehentlich unsichere Vorgänge implementiert werden, die das Risiko von Denial-of-Service-Angriffen mit sich bringen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-120">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="6e84a-121">Stellen Sie sich z.&#160;B. einen Vorgang vor, der anhand einer Zeichenfolge aus einer Datenbank eine Liste der Kunden zurückgibt, deren Name mit dieser Zeichenfolge beginnt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-121">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="6e84a-122">Wenn Sie mit großen Datenbanken arbeiten und die übergebene Zeichenfolge besteht nur aus einem einzelnen Buchstaben, ist die Nachricht, die der Code zu erstellen versucht, möglicherweise größer als der verfügbare Arbeitspeicher. Somit schlägt der gesamte Dienst fehl.</span><span class="sxs-lookup"><span data-stu-id="6e84a-122">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="6e84a-123">(Ein <xref:System.OutOfMemoryException> kann im .NET Framework nicht wieder hergestellt werden und führt immer zu einer Beendigung der Anwendung.)</span><span class="sxs-lookup"><span data-stu-id="6e84a-123">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="6e84a-124">Stellen Sie sicher, dass die verschiedenen Erweiterbarkeitspunkte keinen schädlichen Code enthalten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-124">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="6e84a-125">Dies ist besonders dann relevant, wenn er unter teilweiser Vertrauenswürdigkeit ausgeführt wird, und mit Typen arbeitet, die in nicht voll vertrauenswürdigen Assemblys deklariert sind, oder Komponenten erstellt, die von teilweise vertrauenswürdigem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-125">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="6e84a-126">Weitere Informationen finden Sie unter "Bedrohungen durch teilweise vertrauenswürdigen Code" in einem späteren Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-126">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="6e84a-127">Beachten Sie, dass bei Ausführung unter teilweiser Vertrauenswürdigkeit die Infrastruktur der Datenvertragsserialisierung nur eine beschränkte Teilmenge des Datenvertragsprogrammiermodells unterstützt &#8211; beispielsweise werden private Datenmember oder Typen, die das <xref:System.SerializableAttribute> -Attribut verwenden, nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-127">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="6e84a-128">Weitere Informationen finden Sie unter [teilweise Vertrauens](partial-trust.md)Würdigkeit.</span><span class="sxs-lookup"><span data-stu-id="6e84a-128">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="6e84a-129">Vermeiden einer unbeabsichtigten Offenlegung von Informationen</span><span class="sxs-lookup"><span data-stu-id="6e84a-129">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="6e84a-130">Spielt beim Entwerfen serialisierbarer Typen der Sicherheitsgedanke eine Rolle, ist eine mögliche Offenlegung von Informationen von besonderem Belang.</span><span class="sxs-lookup"><span data-stu-id="6e84a-130">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="6e84a-131">Beachten Sie die folgenden Punkte:</span><span class="sxs-lookup"><span data-stu-id="6e84a-131">Consider the following points:</span></span>

- <span data-ttu-id="6e84a-132">Das Programmiermodell <xref:System.Runtime.Serialization.DataContractSerializer> lässt das Offenlegen von privaten und internen Daten außerhalb des Typs oder der Assembly während der Serialisierung zu.</span><span class="sxs-lookup"><span data-stu-id="6e84a-132">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="6e84a-133">Darüber hinaus kann die Form eines Typs während des Schemaexports offengelegt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-133">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="6e84a-134">Stellen Sie sicher, dass Sie das Serialisierungskonzept des Typs verstehen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-134">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="6e84a-135">Wenn Sie nichts offenlegen möchten, deaktivieren Sie dementsprechend die Serialisierung (z. B. bei einem Datenvertrag, indem Sie das <xref:System.Runtime.Serialization.DataMemberAttribute> -Attribut nicht anwenden).</span><span class="sxs-lookup"><span data-stu-id="6e84a-135">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="6e84a-136">Denken Sie daran, dass derselbe Typ je nach verwendetem Serialisierungsprogramm mehrere Serialisierungskonzepte umfassen kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-136">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="6e84a-137">Ein Typ macht möglicherweise eine Reihe von Daten zugänglich, wenn er mit <xref:System.Runtime.Serialization.DataContractSerializer> verwendet wird und mit <xref:System.Xml.Serialization.XmlSerializer>eine andere Reihe von Daten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-137">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="6e84a-138">Wird versehentlich das falsche Serialisierungsprogramm verwendet, könnten Informationen in die falschen Hände gelangen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-138">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="6e84a-139">Wenn Sie <xref:System.Xml.Serialization.XmlSerializer> im RPC/encoded-Modus des Legacy-Remoteprozeduraufrufs verwenden, legen Sie vielleicht unbeabsichtigt die Form des Objektdiagramms der Absenderseite für die Empfängerseite offen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-139">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="6e84a-140">Verhindern von Denial-of-Service-Angriffen</span><span class="sxs-lookup"><span data-stu-id="6e84a-140">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="6e84a-141">Kontingente</span><span class="sxs-lookup"><span data-stu-id="6e84a-141">Quotas</span></span>

<span data-ttu-id="6e84a-142">Wenn die Empfängerseite dazu veranlasst wird, eine erhebliche Arbeitsspeichermenge zuzuordnen, kann es sich dabei um einen Denial-of-Service-Angriff handeln.</span><span class="sxs-lookup"><span data-stu-id="6e84a-142">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="6e84a-143">Dieser Abschnitt behandelt zwar vorwiegend Probleme des Arbeitsspeicherverbrauchs, der durch großen Nachrichten verursacht wird, es können jedoch auch andere Angriffe stattfinden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-143">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="6e84a-144">Nachrichten können beispielsweise eine außergewöhnlich lange Verarbeitungsdauer beanspruchen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-144">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="6e84a-145">Denial-of-Service-Angriffe werden häufig mithilfe von Kontingenten abgeschwächt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-145">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="6e84a-146">Beim Überschreiten eines Kontingents wird in der Regel eine <xref:System.ServiceModel.QuotaExceededException> -Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="6e84a-146">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="6e84a-147">Ohne Kontingent kann eine böswillige Nachricht den gesamten verfügbaren Arbeitsspeicher belegen und eine <xref:System.OutOfMemoryException> -Ausnahme auslösen, oder es werden alle verfügbaren Stapel verbraucht, was zu einer <xref:System.StackOverflowException>führt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-147">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="6e84a-148">Das Problem eines überschrittenen Kontingents ist behebbar. Wenn dabei ein Dienst aktiv ist, wird die aktuell verarbeitete Nachricht verworfen, der Dienst wird weiterhin ausgeführt und verarbeitet weitere Nachrichten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-148">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="6e84a-149">Die Szenarios "nicht genügend Arbeitsspeicher" und "Stapelüberlauf" sind jedoch an einer beliebigen Stelle im .NET Framework nicht wiederherstellbar. der Dienst wird beendet, wenn diese Ausnahmen auftreten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-149">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="6e84a-150">Kontingente in WCF umfassen keine vorab Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="6e84a-150">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="6e84a-151">Ist beispielsweise das <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> -Kontingent (das für verschiedene Klassen verwendet wir) auf 128 KB festgelegt, heißt das nicht, dass automatisch jeder Nachricht 128 KB zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-151">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="6e84a-152">Die tatsächliche zugeordnete Menge hängt von der tatsächlichen Größe der eingehenden Nachricht ab.</span><span class="sxs-lookup"><span data-stu-id="6e84a-152">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="6e84a-153">Auf der Transportebene ist eine Vielzahl von Kontingenten verfügbar.</span><span class="sxs-lookup"><span data-stu-id="6e84a-153">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="6e84a-154">Dabei handelt es sich um Kontingente, die vom jeweils verwendeten Transportkanal (HTTP, TCP usw.) eingesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-154">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="6e84a-155">Einige dieser Kontingente werden in diesem Thema erläutert, eine ausführliche Beschreibung finden Sie jedoch unter [Transport Quotas](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="6e84a-155">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="6e84a-156">Sicherheitsrisiko bei Hashtabellen</span><span class="sxs-lookup"><span data-stu-id="6e84a-156">Hashtable Vulnerability</span></span>

<span data-ttu-id="6e84a-157">Wenn Datenverträge Hashtabellen oder Auflistungen enthalten, besteht ein Sicherheitsrisiko.</span><span class="sxs-lookup"><span data-stu-id="6e84a-157">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="6e84a-158">Das Problem tritt auf, wenn in eine Hashtabelle eine große Anzahl von Werten eingefügt wird und eine große Anzahl dieser Werte den gleichen Hashwert generiert.</span><span class="sxs-lookup"><span data-stu-id="6e84a-158">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="6e84a-159">Dies kann als DoS-Angriff genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-159">This can be used as a DOS attack.</span></span>  <span data-ttu-id="6e84a-160">Dieses Sicherheitsrisiko kann durch Festlegen des MaxReceivedMessageSize-Bindungs Kontingents verringert werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-160">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="6e84a-161">Wenn dieses Kontingent festgelegt wird, um solche Angriffe zu verhindern, ist Sorgfalt geboten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-161">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="6e84a-162">Mit dem Kontingent wird die Größe der WCF-Nachricht begrenzt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-162">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="6e84a-163">Verwenden Sie außerdem in den Datenverträgen keine Hashtabellen oder Auflistungen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-163">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="6e84a-164">Einschränken des Arbeitsspeicherverbrauch ohne Streaming</span><span class="sxs-lookup"><span data-stu-id="6e84a-164">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="6e84a-165">Das Sicherheitsmodell zu großen Nachrichten hängt davon ab, ob Streaming verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-165">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="6e84a-166">In einem einfachen Fall ohne Streaming werden Nachrichten im Arbeitsspeicher gepuffert.</span><span class="sxs-lookup"><span data-stu-id="6e84a-166">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="6e84a-167">Verwenden Sie hier zur Abwehr großer Nachrichten das <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> -Kontingent für <xref:System.ServiceModel.Channels.TransportBindingElement> oder für die vom System bereitgestellten Bindungen, und schränken Sie damit die maximal verarbeitete Nachrichtengröße ein.</span><span class="sxs-lookup"><span data-stu-id="6e84a-167">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="6e84a-168">Beachten Sie, dass ein Dienst mehrere Nachrichten gleichzeitig verarbeiten kann, die sich dann alle im Arbeitsspeicher befinden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-168">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="6e84a-169">Verwenden Sie die Drosselungsfunktion, um diese Bedrohung zu verringern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-169">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="6e84a-170">Beachten Sie auch, dass `MaxReceivedMessageSize` keine Obergrenze für den Arbeitsspeicherverbrauch der einzelnen Nachrichten festlegt, sondern den Verbrauch auf eine konstante Größe beschränkt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-170">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="6e84a-171">Angenommen, `MaxReceivedMessageSize` ist auf 1&#160;MB festgelegt. Wenn dann eine 1-MB-Nachricht eingeht und anschließend deserialisiert wird, ist weiterer Arbeitsspeicher zur Aufnahme des deserialisierten Objektdiagramms erforderlich. Folglich liegt der insgesamt benötigte Arbeitsspeicher bei gut über 1&#160;MB.</span><span class="sxs-lookup"><span data-stu-id="6e84a-171">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="6e84a-172">Vermeiden Sie deshalb, serialisierbare Typen zu erstellen, die bei nur wenigen eingehenden Daten einen erheblichen Arbeitsspeicherverbrauch verursachen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-172">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="6e84a-173">Beispielsweise kann ein Datenvertrag "mycontract" mit 50 optionalen Datenmember-Feldern und zusätzlichen 100 Private-Feldern mit der XML-Konstruktion "" instanziiert werden \<MyContract/> .</span><span class="sxs-lookup"><span data-stu-id="6e84a-173">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="6e84a-174">Bei diesem XML-Konstrukt wird Arbeitsspeicher für 150&#160;Felder belegt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-174">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="6e84a-175">Datenmember sind standardmäßig optional.</span><span class="sxs-lookup"><span data-stu-id="6e84a-175">Note that data members are optional by default.</span></span> <span data-ttu-id="6e84a-176">Das Problem wird verschärft, wenn ein solcher Typ Teil eines Arrays ist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-176">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="6e84a-177">`MaxReceivedMessageSize` allein reicht nicht aus, um alle Denial-of-Service-Angriffe zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-177">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="6e84a-178">Das Deserialisierungsprogramm kann z.&#160;B. von einer eingehenden Nachricht gezwungen werden, ein tief geschachteltes Objektdiagramm (ein Objekt, das ein anderes Objekt enthält, das wiederum ein Objekt enthält usw.) zu deserialisieren.</span><span class="sxs-lookup"><span data-stu-id="6e84a-178">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="6e84a-179">Sowohl <xref:System.Runtime.Serialization.DataContractSerializer> als auch <xref:System.Xml.Serialization.XmlSerializer> rufen zum Deserialisieren solcher Diagramme Methoden in einer geschachtelte Weise auf.</span><span class="sxs-lookup"><span data-stu-id="6e84a-179">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="6e84a-180">Eine tiefe Schachtelung von Methodenaufrufen kann zu einer nicht behebbaren <xref:System.StackOverflowException>führen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-180">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="6e84a-181">Diese Gefahr verringert sich, wenn das <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> -Kontingent die Schachtelungstiefe von XML einschränkt (wie im Abschnitt "Sicheres Verwenden von XML" weiter unten in diesem Thema erläutert wird).</span><span class="sxs-lookup"><span data-stu-id="6e84a-181">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="6e84a-182">`MaxReceivedMessageSize` festzulegen, ist bei der Verwendung einer binären XML-Codierung besonders wichtig.</span><span class="sxs-lookup"><span data-stu-id="6e84a-182">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="6e84a-183">Die Verwendung einer binären Codierung ähnelt in gewisser Weise einer Komprimierung: eine kleine Gruppe von Bytes in der eingehenden Nachricht kann eine große Menge von Daten darstellen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-183">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="6e84a-184">Deshalb kann selbst eine Nachricht, die im Rahmen des `MaxReceivedMessageSize` -Limits liegt, in erweiterter Form wesentlich mehr Arbeitsspeicher beanspruchen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-184">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="6e84a-185">Um diese speziellen Risiken durch XML zu verringern, müssen alle XML-Readerkontingente richtig festgelegt werden (siehe "Sicheres Verwenden von XML" weiter unten in diesem Thema).</span><span class="sxs-lookup"><span data-stu-id="6e84a-185">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="6e84a-186">Einschränken des Arbeitsspeicherverbrauch mit Streaming</span><span class="sxs-lookup"><span data-stu-id="6e84a-186">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="6e84a-187">Beim Streaming verwenden Sie zum Schutz vor Denial-of-Service-Angriffen möglicherweise eine niedrige `MaxReceivedMessageSize` -Einstellung.</span><span class="sxs-lookup"><span data-stu-id="6e84a-187">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="6e84a-188">Mit Streaming sind komplexere Szenarien möglich.</span><span class="sxs-lookup"><span data-stu-id="6e84a-188">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="6e84a-189">Ein Dateiuploaddienst akzeptiert z. B. Dateien, die größer sind als der gesamte verfügbare Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="6e84a-189">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="6e84a-190">Legen Sie in diesem Fall `MaxReceivedMessageSize` auf einen extrem hohen Wert fest, da voraussichtlich fast keine Daten im Arbeitsspeicher gepuffert werden und die Nachricht per Streaming direkt auf die Festplatte übertragen wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-190">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="6e84a-191">Wenn eine böswillige Nachricht in diesem Fall in der Folge erzwingen kann, dass WCF Daten puffert, werden Sie `MaxReceivedMessageSize` nicht mehr von der Nachricht geschützt, die auf den gesamten verfügbaren Arbeitsspeicher zugreift.</span><span class="sxs-lookup"><span data-stu-id="6e84a-191">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="6e84a-192">Um diese Bedrohung zu mindern, sind bestimmte Kontingent Einstellungen für verschiedene WCF-Datenverarbeitungs Komponenten vorhanden, die die Pufferung einschränken.</span><span class="sxs-lookup"><span data-stu-id="6e84a-192">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="6e84a-193">Am wichtigsten ist hierbei die `MaxBufferSize` -Eigenschaft für verschiedene Transportbindungselemente und Standardbindungen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-193">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="6e84a-194">Berücksichtigen Sie beim Streaming die maximale Arbeitsspeichermenge, die Sie für einzelne Nachrichten zuordnen möchten, wenn Sie dieses Kontingent festlegen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-194">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="6e84a-195">Wie bei `MaxReceivedMessageSize`wird mit dieser Einstellung kein absolutes Maximum für den Arbeitsspeicherverbrauch festgelegt, sondern der Verbrauch wird auf eine konstante Größe beschränkt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-195">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="6e84a-196">Denken Sie auch hier wie bei `MaxReceivedMessageSize`an die Möglichkeit, dass mehrere Nachrichten gleichzeitig verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-196">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="6e84a-197">Näheres zu MaxBufferSize</span><span class="sxs-lookup"><span data-stu-id="6e84a-197">MaxBufferSize Details</span></span>

<span data-ttu-id="6e84a-198">Die- `MaxBufferSize` Eigenschaft schränkt die Massen Pufferung von WCF ein.</span><span class="sxs-lookup"><span data-stu-id="6e84a-198">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="6e84a-199">Beispielsweise puffert WCF immer SOAP-Header und SOAP-Fehler sowie alle MIME-Teile, die sich in einer MTOM-Nachricht (Message Transmission Optimization Mechanism) nicht in der natürlichen Lesefolge befinden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-199">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="6e84a-200">Diese Einstellung schränkt die Menge der gepufferten Daten in all diesen Fällen ein.</span><span class="sxs-lookup"><span data-stu-id="6e84a-200">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="6e84a-201">WCF erreicht dies, indem der- `MaxBufferSize` Wert an die verschiedenen Komponenten übergeben wird, die möglicherweise gepuffert werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-201">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="6e84a-202">Beispielsweise akzeptieren einige <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> -Überladungen der <xref:System.ServiceModel.Channels.Message> -Klasse den `maxSizeOfHeaders` -Parameter.</span><span class="sxs-lookup"><span data-stu-id="6e84a-202">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="6e84a-203">WCF übergibt den `MaxBufferSize` Wert an diesen Parameter, um die Größe der SOAP-Header Pufferung einzuschränken.</span><span class="sxs-lookup"><span data-stu-id="6e84a-203">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="6e84a-204">Bei einer direkten Verwendung der <xref:System.ServiceModel.Channels.Message> -Klasse ist es wichtig, diesen Parameter festzulegen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-204">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="6e84a-205">Im Allgemeinen ist es bei der Verwendung einer Komponente in WCF, die Kontingent Parameter annimmt, wichtig, die Auswirkungen dieser Parameter auf die Sicherheit zu verstehen und diese korrekt festzulegen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-205">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="6e84a-206">Auch der MTOM-Nachrichtenencoder verfügt über eine `MaxBufferSize` -Einstellung.</span><span class="sxs-lookup"><span data-stu-id="6e84a-206">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="6e84a-207">Bei der Verwendung von Standardbindungen wird hierfür automatisch der `MaxBufferSize` -Wert der Transportebene festgelegt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-207">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="6e84a-208">Wenn jedoch mit dem Bindungselement des MTOM-Nachrichtenencoders eine benutzerdefinierte Bindung erstellt wird, ist es wichtig, die `MaxBufferSize` -Eigenschaft beim Verwenden von Streaming auf einen sicheren Wert festzulegen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-208">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="6e84a-209">XML-basierte Streamingangriffe</span><span class="sxs-lookup"><span data-stu-id="6e84a-209">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="6e84a-210">`MaxBufferSize` allein reicht nicht aus, um sicherzustellen, dass WCF nicht in die Pufferung gezwungen werden kann, wenn ein Streaming erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-210">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="6e84a-211">Beispielsweise Puffern die WCF-XML-Reader immer das gesamte Starttag des XML-Elements, wenn mit dem Lesen eines neuen Elements begonnen wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-211">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="6e84a-212">Das dient der ordnungsgemäßen Verarbeitung von Namespaces und Attributen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-212">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="6e84a-213">Wenn `MaxReceivedMessageSize` hoch konfiguriert wird (z. B. um eine umfangreiches Streaming direkt auf die Festplatte zu ermöglichen), könnte eine böswillige Nachricht erstellt werden, in der der gesamte Nachrichtentext aus einem großen Starttag für XML-Elemente besteht.</span><span class="sxs-lookup"><span data-stu-id="6e84a-213">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="6e84a-214">Der Versuch, dieses Starttag zu lesen, führt zu einer <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="6e84a-214">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="6e84a-215">Dies ist einer von vielen möglichen XML-basierten Denial-of-Service-Angriffen, die mithilfe von XML-Readerkontingenten vermieden werden können, die im Abschnitt "Sicheres Verwenden von XML" weiter unten in diesem Thema erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-215">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="6e84a-216">Beim Streaming ist es besonders wichtig, alle diese Kontingente festzulegen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-216">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="6e84a-217">Kombinieren von Streaming- und Pufferprogrammiermodellen</span><span class="sxs-lookup"><span data-stu-id="6e84a-217">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="6e84a-218">Viele mögliche Angriffe ergeben sich aus kombinierten Streaming- und anderen Programmiermodellen im gleichen Dienst.</span><span class="sxs-lookup"><span data-stu-id="6e84a-218">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="6e84a-219">Angenommen, ein Dienst umfasst zwei Vorgänge: ein Vorgang verwendet einen <xref:System.IO.Stream> und ein anderer ein Array eines benutzerdefinierten Typs.</span><span class="sxs-lookup"><span data-stu-id="6e84a-219">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="6e84a-220">`MaxReceivedMessageSize` wird außerdem auf einen großen Wert festgelegt, damit der erste Vorgang große Streams verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-220">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="6e84a-221">Leider bedeutet das, dass große Nachrichten nun auch an den zweiten Vorgang gesendet werden können und dass das Deserialisierungsprogramm Daten als Array im Arbeitsspeicher puffert, bevor der Vorgang aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-221">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="6e84a-222">Das stellt einen potenzieller Denial-of-Service-Angriff dar: das `MaxBufferSize` -Kontingent schränkt die Größe des Nachrichtentextes, womit das Deserialisierungsprogramm arbeitet, nicht ein.</span><span class="sxs-lookup"><span data-stu-id="6e84a-222">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="6e84a-223">Vermeiden Sie es deshalb, auf Streams basierende Vorgänge mit anderen Vorgängen im selben Vertrag zu kombinieren.</span><span class="sxs-lookup"><span data-stu-id="6e84a-223">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="6e84a-224">Sollte eine Kombination der beiden Programmiermodelle zwingend erforderlich sein, treffen Sie die folgenden Vorkehrungen:</span><span class="sxs-lookup"><span data-stu-id="6e84a-224">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="6e84a-225">Deaktivieren Sie die <xref:System.Runtime.Serialization.IExtensibleDataObject> -Funktion, indem Sie die <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> -Eigenschaft von <xref:System.ServiceModel.ServiceBehaviorAttribute> auf `true`festlegen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-225">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="6e84a-226">Dadurch stellen Sie sicher, dass nur Member deserialisiert werden, die zum Vertrag gehören.</span><span class="sxs-lookup"><span data-stu-id="6e84a-226">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="6e84a-227">Legen Sie die <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> -Eigenschaft von <xref:System.Runtime.Serialization.DataContractSerializer> auf einen sicheren Wert fest.</span><span class="sxs-lookup"><span data-stu-id="6e84a-227">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="6e84a-228">Dieses Kontingent ist auch für das <xref:System.ServiceModel.ServiceBehaviorAttribute> -Attribut oder die Konfiguration verfügbar.</span><span class="sxs-lookup"><span data-stu-id="6e84a-228">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="6e84a-229">Mit diesem Kontingent wird Anzahl der Objekte eingeschränkt, die in einer Deserialisierungsfolge deserialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-229">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="6e84a-230">In der Regel wird jeder Vorgangsparameter oder jeder Nachrichtentextteil in einem Nachrichtenvertrag in einer Folge deserialisiert.</span><span class="sxs-lookup"><span data-stu-id="6e84a-230">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="6e84a-231">Beim Deserialisieren von Arrays wird jeder Arrayeintrag als separates Objekt betrachtet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-231">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="6e84a-232">Legen Sie alle XML-Readerkontingente auf sichere Werte fest.</span><span class="sxs-lookup"><span data-stu-id="6e84a-232">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="6e84a-233">Achten Sie auf <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>und <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> , und vermeiden Sie Zeichenfolgen in anderen als Streamingvorgängen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-233">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="6e84a-234">Überprüfen Sie die Liste der bekannten Typen und denken Sie daran, dass jeder davon jederzeit instanziiert werden kann (siehe "Verhindern des Ladens unbeabsichtigter Typen" weiter unten in diesem Thema).</span><span class="sxs-lookup"><span data-stu-id="6e84a-234">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="6e84a-235">Verwenden Sie keine Typen, die die <xref:System.Xml.Serialization.IXmlSerializable> -Schnittstelle implementieren und eine große Datenmenge puffern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-235">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="6e84a-236">Fügen Sie keine Typen dieser Art der Liste der bekannten Typen hinzu.</span><span class="sxs-lookup"><span data-stu-id="6e84a-236">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="6e84a-237">Verwenden Sie kein <xref:System.Xml.XmlElement>und keine <xref:System.Xml.XmlNode> -Arrays, <xref:System.Byte> -Arrays oder Typen, die <xref:System.Runtime.Serialization.ISerializable> in einem Vertrag implementieren.</span><span class="sxs-lookup"><span data-stu-id="6e84a-237">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="6e84a-238">Verwenden Sie kein <xref:System.Xml.XmlElement>und keine <xref:System.Xml.XmlNode> -Arrays, <xref:System.Byte> -Arrays oder Typen, die <xref:System.Runtime.Serialization.ISerializable> in der Liste der bekannten Typen implementieren.</span><span class="sxs-lookup"><span data-stu-id="6e84a-238">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="6e84a-239">Die vorangehenden Vorkehrungen sind relevant, wenn der Vorgang ohne Streaming <xref:System.Runtime.Serialization.DataContractSerializer>verwendet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-239">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="6e84a-240">Kombinieren Sie niemals Streaming- und andere Programmiermodelle im selben Dienst, wenn Sie <xref:System.Xml.Serialization.XmlSerializer>verwenden, denn der Schutz von <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> -Kontingenten ist dabei nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-240">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="6e84a-241">Angriffe durch langsame Streams</span><span class="sxs-lookup"><span data-stu-id="6e84a-241">Slow Stream Attacks</span></span>

<span data-ttu-id="6e84a-242">Eine Kategorie von Denial-of-Service-Angriffen beim Streaming wirkt sich nicht auf den Arbeitsspeicherverbrauch aus.</span><span class="sxs-lookup"><span data-stu-id="6e84a-242">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="6e84a-243">Stattdessen konzentriert sich der Angriff auf das langsame Senden oder Empfangen von Daten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-243">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="6e84a-244">Während auf das Senden oder Empfang der Daten gewartet wird, erschöpfen sich die Ressourcen wie Threads und die verfügbaren Verbindungen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-244">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="6e84a-245">Dieser Fall kann als Ergebnis eines böswilligen Angriffs oder durch einen legitimen Absender/Empfänger bei einer langsamen Netzwerkverbindung entstehen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-245">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="6e84a-246">Legen Sie die Transporttimeouts richtig fest, um diese Angriffe zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-246">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="6e84a-247">Weitere Informationen finden Sie unter [Transport Kontingente](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="6e84a-247">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="6e84a-248">Verwenden Sie `Read` `Write` beim Arbeiten mit Streams in WCF niemals synchrone or-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="6e84a-248">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="6e84a-249">Sicheres Verwenden von XML</span><span class="sxs-lookup"><span data-stu-id="6e84a-249">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="6e84a-250">Obwohl dieser Abschnitt XML behandelt, gelten die Informationen auch für JSON-Dokumente (JavaScript Objekt Notation).</span><span class="sxs-lookup"><span data-stu-id="6e84a-250">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="6e84a-251">Die Kontingente funktionieren auf ähnliche Weise und verwenden [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="6e84a-251">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="6e84a-252">Sichere XML-Reader</span><span class="sxs-lookup"><span data-stu-id="6e84a-252">Secure XML Readers</span></span>

<span data-ttu-id="6e84a-253">Das XML-Infoset bildet die Basis der gesamten Nachrichtenverarbeitung in WCF.</span><span class="sxs-lookup"><span data-stu-id="6e84a-253">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="6e84a-254">Das Akzeptieren von XML-Daten aus einer nicht vertrauenswürdigen Quelle ermöglicht eine Reihe von Denial-of-Service-Angriffen, die verhindert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-254">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="6e84a-255">WCF bietet spezielle, sichere XML-Reader.</span><span class="sxs-lookup"><span data-stu-id="6e84a-255">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="6e84a-256">Diese Leser werden automatisch erstellt, wenn eine der Standard Codierungen in WCF verwendet wird (Text, Binär oder MTOM).</span><span class="sxs-lookup"><span data-stu-id="6e84a-256">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="6e84a-257">Einige der Sicherheitsfunktionen dieser Reader sind immer aktiv.</span><span class="sxs-lookup"><span data-stu-id="6e84a-257">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="6e84a-258">Die Reader verarbeiten z. B. keine Dokumenttypdefinitionen (DTDs), die eine mögliche Quelle von Denial-of-Service-Angriffen darstellen und niemals in rechtmäßigen SOAP-Nachrichten auftreten sollten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-258">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="6e84a-259">Zu weiteren Sicherheitsfunktionen gehören Readerkontingente, die konfiguriert werden müssen. Im folgenden Abschnitt werden diese Kontingente beschrieben.</span><span class="sxs-lookup"><span data-stu-id="6e84a-259">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="6e84a-260">Wenn Sie direkt mit XML-Readern arbeiten (z. b. beim Schreiben eines eigenen benutzerdefinierten Encoders oder beim direkten Arbeiten mit der- <xref:System.ServiceModel.Channels.Message> Klasse), verwenden Sie immer die sicheren WCF-Reader, wenn die Möglichkeit besteht, mit nicht vertrauenswürdigen Daten zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-260">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="6e84a-261">Erstellen Sie die sicheren Reader, indem Sie eine der Überladungen der statischen Factorymethode von <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>oder <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> für die <xref:System.Xml.XmlDictionaryReader> -Klasse aufrufen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-261">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="6e84a-262">Geben Sie beim Erstellen eines Readers sichere Kontingentwerte an.</span><span class="sxs-lookup"><span data-stu-id="6e84a-262">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="6e84a-263">Rufen Sie nicht die Überladungen der `Create` -Methode auf.</span><span class="sxs-lookup"><span data-stu-id="6e84a-263">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="6e84a-264">Diese erstellen keinen WCF-Reader.</span><span class="sxs-lookup"><span data-stu-id="6e84a-264">These do not create a WCF reader.</span></span> <span data-ttu-id="6e84a-265">Stattdessen wird ein Reader erstellt, der nicht durch die in diesem Abschnitt beschriebenen Sicherheitsfunktionen geschützt ist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-265">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="6e84a-266">Readerkontingente</span><span class="sxs-lookup"><span data-stu-id="6e84a-266">Reader Quotas</span></span>

<span data-ttu-id="6e84a-267">Die sicheren XML-Reader verfügen über fünf konfigurierbare Kontingente.</span><span class="sxs-lookup"><span data-stu-id="6e84a-267">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="6e84a-268">Diese werden in der Regel mithilfe der `ReaderQuotas` -Eigenschaft für das Codierungsbindungselement oder die Standardbindungen konfiguriert oder mithilfe eines <xref:System.Xml.XmlDictionaryReaderQuotas> -Objekts, das beim Erstellen eines Readers übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-268">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="6e84a-269">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="6e84a-269">MaxBytesPerRead</span></span>

<span data-ttu-id="6e84a-270">Dieses Kontingent beschränkt die Anzahl der Bytes, die in einem einzelnen `Read` -Vorgang beim Lesen des Starttags des Elements und seiner Attribute gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="6e84a-270">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="6e84a-271">(In Fällen ohne Streaming wird der Elementname selbst nicht in die Berechnung des Kontingents einbezogen.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> ist aus den folgenden Gründen wichtig:</span><span class="sxs-lookup"><span data-stu-id="6e84a-271">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="6e84a-272">Der Elementname und dessen Attribute werden immer im Arbeitsspeicher gepuffert, wenn sie gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-272">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="6e84a-273">Deshalb ist es wichtig, dass dieses Kontingent im Streamingmodus richtig festgelegt wird, um bei einem erwarteten Streaming eine übermäßige Pufferung zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-273">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="6e84a-274">Informationen zum tatsächlichen Pufferumfang finden Sie unten in den Ausführungen zum `MaxDepth` -Kontingent.</span><span class="sxs-lookup"><span data-stu-id="6e84a-274">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="6e84a-275">Bei zu vielen XML-Attributen kann die Verarbeitungszeit übermäßig lange dauern, da die Attributnamen auf Eindeutigkeit überprüft werden müssen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-275">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="6e84a-276">`MaxBytesPerRead` mindert dieses Risiko.</span><span class="sxs-lookup"><span data-stu-id="6e84a-276">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="6e84a-277">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="6e84a-277">MaxDepth</span></span>

<span data-ttu-id="6e84a-278">Diese Kontingent schränkt die maximale Schachtelungstiefe von XML-Elementen ein.</span><span class="sxs-lookup"><span data-stu-id="6e84a-278">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="6e84a-279">Das Dokument "" hat beispielsweise eine Schachtelungs \<A> \<B> \<C/> \</B> \</A> Tiefe von drei.</span><span class="sxs-lookup"><span data-stu-id="6e84a-279">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="6e84a-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> ist aus den folgenden Gründen wichtig:</span><span class="sxs-lookup"><span data-stu-id="6e84a-280"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="6e84a-281">`MaxDepth` interagiert mit `MaxBytesPerRead`: Der Reader behält stets Daten für das aktuelle Element und alle seiner übergeordneten Elemente im Arbeitsspeicher, weshalb der maximale Arbeitsspeicherverbrauch proportional zum Produkt aus diesen beiden Einstellungen ist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-281">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="6e84a-282">Wenn Sie ein tief geschachteltes Objektdiagramm deserialisieren, ist das Deserialisierungsprogramm gezwungen, auf den gesamten Stapel zuzugreifen und eine nicht behebbare <xref:System.StackOverflowException>auszulösen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-282">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="6e84a-283">Ein direkter Zusammenhang besteht zwischen der XML-Schachtelung und der Objektschachtelung sowohl für <xref:System.Runtime.Serialization.DataContractSerializer> als auch für <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="6e84a-283">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="6e84a-284">Verwenden Sie `MaxDepth` , um diese Bedrohung zu verringern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-284">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="6e84a-285">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="6e84a-285">MaxNameTableCharCount</span></span>

<span data-ttu-id="6e84a-286">Dieses Kontingent schränkt die Größe der *Nametable*des Readers ein.</span><span class="sxs-lookup"><span data-stu-id="6e84a-286">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="6e84a-287">Die Nametable enthält bestimmte Zeichenfolgen (z. B. Namespaces and Präfixe), die beim Verarbeiten von XML-Dokumenten auftreten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-287">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="6e84a-288">Diese Zeichenfolgen werden im Arbeitsspeicher gepuffert. Legen Sie deshalb dieses Kontingent fest, um eine übermäßige Pufferung bei einem erwarteten Streaming zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-288">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="6e84a-289">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="6e84a-289">MaxStringContentLength</span></span>

<span data-ttu-id="6e84a-290">Dieses Kontingent schränkt die maximale Größe der Zeichenfolgen ein, die vom XML-Reader zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-290">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="6e84a-291">Der Arbeitsspeicherverbrauch im XML-Reader selbst wird mit diesem Kontingent nicht eingeschränkt, jedoch in der Komponente, die den Reader verwendet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-291">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="6e84a-292">Wenn <xref:System.Runtime.Serialization.DataContractSerializer> z.&#160;B. einen Reader verwendet, der mit <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>gesichert ist, werden keine Zeichenfolgen deserialisiert, deren Größe dieses Kontingent überschreitet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-292">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="6e84a-293">Wird die <xref:System.Xml.XmlDictionaryReader> -Klasse direkt verwendet, beachten nicht alle Methoden dieses Kontingent, sondern nur die Methoden, die speziell für das Lesen dieser Zeichenfolgen entworfen wurden, z.&#160;B. die <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> -Methode.</span><span class="sxs-lookup"><span data-stu-id="6e84a-293">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="6e84a-294">Die <xref:System.Xml.XmlReader.Value%2A> -Eigenschaft für den Reader wird von diesem Kontingent nicht beeinflusst. Sie sollte deshalb nicht verwendet werden, wenn der Schutz benötigt wird, den dieses Kontingent bietet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-294">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="6e84a-295">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="6e84a-295">MaxArrayLength</span></span>

<span data-ttu-id="6e84a-296">Dieses Kontingent schränkt die maximale Größe eines Arrays von Primitiven ein, einschließlich Bytearrays, die vom XML-Reader zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-296">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="6e84a-297">Der Arbeitsspeicherverbrauch im XML-Reader selbst wird mit diesem Kontingent nicht eingeschränkt, jedoch in der Komponente, die den Reader verwendet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-297">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="6e84a-298">Wenn <xref:System.Runtime.Serialization.DataContractSerializer> z.&#160;B. einen Reader verwendet, der mit <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>gesichert ist, werden keine Bytearrays deserialisiert, deren Größe dieses Kontingent überschreitet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-298">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="6e84a-299">Sollen Streaming- und Pufferprogrammiermodelle in einem einzelnen Vertrag kombiniert werden, ist es wichtig, dieses Kontingent festzulegen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-299">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="6e84a-300">Denken Sie daran, dass bei einer direkten Verwendung der <xref:System.Xml.XmlDictionaryReader> -Klasse nur die Methoden dieses Kontingent beachten, die speziell zum Lesen von Arrays beliebiger Größe von bestimmten primitiven Typen entworfen wurden, wie z.&#160;B. <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e84a-300">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="6e84a-301">Spezielle Bedrohungen bei der binären Codierung</span><span class="sxs-lookup"><span data-stu-id="6e84a-301">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="6e84a-302">Die binäre XML-Codierung, die von WCF unterstützt wird, Bein *haltet eine Funktion* für</span><span class="sxs-lookup"><span data-stu-id="6e84a-302">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="6e84a-303">Eine große Zeichenfolge kann mit wenigen Bytes codiert werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-303">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="6e84a-304">Das ermöglicht eine erhebliche Leistungsverbesserung, bringt jedoch neue Angriffsflächen für Denial-of-Service-Bedrohungen mit sich, die abgewehrt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-304">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="6e84a-305">Es gibt zwei Arten von Wörterbüchern: *statisch* und *dynamisch*.</span><span class="sxs-lookup"><span data-stu-id="6e84a-305">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="6e84a-306">Das statische Wörterbuch besteht aus eine integrierten Liste langer Zeichenfolgen, die mithilfe eines kurzen Codes in der binären Codierung dargestellt werden können.</span><span class="sxs-lookup"><span data-stu-id="6e84a-306">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="6e84a-307">Diese Zeichenfolgenliste steht beim Erstellen des Readers fest und kann nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-307">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="6e84a-308">Keine der Zeichen folgen im statischen Wörterbuch, die von WCF standardmäßig verwendet werden, ist ausreichend groß, um eine ernste Denial-of-Service-Bedrohung darzustellen, obwohl Sie möglicherweise weiterhin in einem Angriff auf die Wörterbuch Erweiterung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-308">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="6e84a-309">Seien Sie in komplexen Szenarien, in denen Sie ein eigenes statisches Wörterbuch bereitstellen, mit dem Einbringen langer Wörterbuchzeichenfolgen vorsichtig.</span><span class="sxs-lookup"><span data-stu-id="6e84a-309">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="6e84a-310">Die Funktion dynamischer Wörterbücher ermöglicht es Nachrichten, eigene Zeichenfolgen zu definieren und kurzen Codes zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-310">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="6e84a-311">Diese Zeichenfolgen-Code-Zuordnungen bleiben während der gesamten Kommunikationssitzung im Arbeitsspeicher. Auf diese Weise müssen anschließende Nachrichten die Zeichenfolgen nicht erneut senden und können bereits definierte Codes nutzen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-311">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="6e84a-312">Die Länge dieser Zeichenfolgen ist beliebig, weshalb sie eine ernstere Bedrohung darstellen als die Zeichenfolgen im statischen Wörterbuch.</span><span class="sxs-lookup"><span data-stu-id="6e84a-312">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="6e84a-313">Die erste Bedrohung, die es zu verringern gilt, ist die Möglichkeit eines zu großen dynamischen Wörterbuchs (die Zeichenfolgen-Code-Zuordnung).</span><span class="sxs-lookup"><span data-stu-id="6e84a-313">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="6e84a-314">Dieses Wörterbuch kann im Verlauf mehrerer Nachrichten anwachsen. Das `MaxReceivedMessageSize` -Kontingent bietet somit keinen Schutz, da es sich gesondert auf die einzelnen Nachrichten bezieht.</span><span class="sxs-lookup"><span data-stu-id="6e84a-314">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="6e84a-315">Deshalb gibt es eine gesonderte <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> -Eigenschaft für <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> , die die Größe des Wörterbuchs einschränkt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-315">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="6e84a-316">Im Gegensatz zu den meisten anderen Kontingenten wird dieses Kontingent auch beim Schreiben von Nachrichten angewendet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-316">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="6e84a-317">Wird es beim Lesen einer Nachricht überschritten, wird wie üblich die `QuotaExceededException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="6e84a-317">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="6e84a-318">Wenn es beim Schreiben einer Nachricht überschritten wird, werden alle Zeichenfolgen, die das Überschreiten des Kontingents verursachen, ohne Einbeziehung der Funktion für dynamische Wörterbücher so geschrieben, wie sie sind.</span><span class="sxs-lookup"><span data-stu-id="6e84a-318">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="6e84a-319">Bedrohungen durch Wörterbucherweiterungen</span><span class="sxs-lookup"><span data-stu-id="6e84a-319">Dictionary Expansion Threats</span></span>

<span data-ttu-id="6e84a-320">Wörterbucherweiterungen stellen eine wichtige Kategorie von Angriffen binärer Natur dar.</span><span class="sxs-lookup"><span data-stu-id="6e84a-320">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="6e84a-321">Eine kleine Nachricht in binärer Form kann sich in vollständig erweiterter Textform in eine extrem große Nachricht verwandeln, wenn die Wörterbuchzeichenfolgenfunktion umfassend angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-321">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="6e84a-322">Der Erweiterungsfaktor für Zeichenfolgen des dynamischen Wörterbuchs wird durch das <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> -Kontingent eingeschränkt, da keine Zeichenfolge des Wörterbuchs die maximale Größe des gesamten dynamischen Wörterbuchs überschreitet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-322">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="6e84a-323">Die Eigenschaften <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`und `MaxArrayLength` schränken nur den Arbeitsspeicherverbrauch ein.</span><span class="sxs-lookup"><span data-stu-id="6e84a-323">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="6e84a-324">In der Regel sind sie zur Abwehr von Bedrohungen in Szenarien ohne Streaming nicht erforderlich, da der Arbeitsspeicherverbrauch bereits durch `MaxReceivedMessageSize`eingeschränkt wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-324">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="6e84a-325">`MaxReceivedMessageSize` berechnet jedoch die Bytes vor der Erweiterung.</span><span class="sxs-lookup"><span data-stu-id="6e84a-325">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="6e84a-326">Bei der Verwendung der binären Codierung könnte der Arbeitsspeicherverbrauch `MaxReceivedMessageSize`überschreiten und würde lediglich durch den Faktor von <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>eingeschränkt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-326">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="6e84a-327">Aus diesem Grund ist es wichtig, stets alle Kontingente des Readers festzulegen (insbesondere <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>), wenn die binäre Codierung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-327">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="6e84a-328">Wird die binäre Codierung in Verbindung mit <xref:System.Runtime.Serialization.DataContractSerializer>verwendet, kann die `IExtensibleDataObject` -Schnittstelle für einen Angriff durch eine Erweiterung des Wörterbuchs missbraucht werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-328">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="6e84a-329">Diese Schnittstelle stellt im Wesentlichen unbegrenzten Speicher für beliebige Daten bereit, die nicht zum Vertrag gehören.</span><span class="sxs-lookup"><span data-stu-id="6e84a-329">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="6e84a-330">Wenn Kontingente nicht so niedrig festgelegt werden können, dass `MaxSessionSize` multipliziert mit `MaxReceivedMessageSize` kein Problem darstellt, deaktivieren Sie die `IExtensibleDataObject` -Funktion bei der Verwendung der binären Codierung.</span><span class="sxs-lookup"><span data-stu-id="6e84a-330">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="6e84a-331">Legen Sie die `IgnoreExtensionDataObject` -Eigenschaft für das `true` -Attribute auf `ServiceBehaviorAttribute` fest.</span><span class="sxs-lookup"><span data-stu-id="6e84a-331">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="6e84a-332">Als Alternative können Sie auch darauf verzichten, die `IExtensibleDataObject` -Schnittstelle zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="6e84a-332">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="6e84a-333">Weitere Informationen finden Sie unter [Aufwärtskompatible Datenverträge](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6e84a-333">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="6e84a-334">Zusammenfassung der Kontingente</span><span class="sxs-lookup"><span data-stu-id="6e84a-334">Quotas Summary</span></span>

<span data-ttu-id="6e84a-335">In der folgenden Tabelle werden die Hinweise zu den Kontingenten zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="6e84a-335">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="6e84a-336">Bedingung</span><span class="sxs-lookup"><span data-stu-id="6e84a-336">Condition</span></span>|<span data-ttu-id="6e84a-337">Wichtige Kontingente</span><span class="sxs-lookup"><span data-stu-id="6e84a-337">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="6e84a-338">Kein Streaming oder Streaming von kleinen Nachrichten, Text oder MTOM-Codierung</span><span class="sxs-lookup"><span data-stu-id="6e84a-338">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="6e84a-339">`MaxReceivedMessageSize`, `MaxBytesPerRead` und `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="6e84a-339">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="6e84a-340">Kein Streaming oder Streaming von kleinen Nachrichten und binäre Codierung</span><span class="sxs-lookup"><span data-stu-id="6e84a-340">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="6e84a-341">`MaxReceivedMessageSize`, `MaxSessionSize`und alle `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="6e84a-341">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="6e84a-342">Streaming von großen Nachrichten, Text oder MTOM-Codierung</span><span class="sxs-lookup"><span data-stu-id="6e84a-342">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="6e84a-343">`MaxBufferSize` und alle `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="6e84a-343">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="6e84a-344">Streaming von großen Nachrichten und binäre Codierung</span><span class="sxs-lookup"><span data-stu-id="6e84a-344">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="6e84a-345">`MaxBufferSize`, `MaxSessionSize`und alle `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="6e84a-345">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="6e84a-346">Timeouts auf Transportebene müssen immer festgelegt werden, und beim Streaming dürfen niemals synchrone Lese-/Schreibvorgänge verwendet werden, unabhängig davon, ob große oder kleine Nachrichten übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-346">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="6e84a-347">Wenn Sie sich über ein Kontingent nicht klar sind, legen Sie besser einen sicheren Wert fest, statt gar keinen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-347">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="6e84a-348">Verhindern der Ausführung von schädlichem Code</span><span class="sxs-lookup"><span data-stu-id="6e84a-348">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="6e84a-349">Bei den folgenden allgemeinen Bedrohungskategorien kann Code ausführt werden und ein unerwünschtes Ergebnis eintreten:</span><span class="sxs-lookup"><span data-stu-id="6e84a-349">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="6e84a-350">Das Deserialisierungsprogramm lädt einen schädlichen, unsicheren oder sicherheitsrelevanten Typ.</span><span class="sxs-lookup"><span data-stu-id="6e84a-350">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="6e84a-351">Eine eingehende Nachricht veranlasst das Deserialisierungsprogramm, eine Instanz eines normalerweise sicheren Typs so zu erstellen, dass er unerwünschte Folgen hat.</span><span class="sxs-lookup"><span data-stu-id="6e84a-351">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="6e84a-352">In den folgenden Abschnitten werden diese Bedrohungskategorien näher erläutert.</span><span class="sxs-lookup"><span data-stu-id="6e84a-352">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="6e84a-353">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="6e84a-353">DataContractSerializer</span></span>

<span data-ttu-id="6e84a-354">(Sicherheitsinformationen zu finden Sie in <xref:System.Xml.Serialization.XmlSerializer> der entsprechenden Dokumentation.) Das Sicherheitsmodell für <xref:System.Xml.Serialization.XmlSerializer> ähnelt dem von <xref:System.Runtime.Serialization.DataContractSerializer> und unterscheidet sich größtenteils in den Details.</span><span class="sxs-lookup"><span data-stu-id="6e84a-354">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="6e84a-355">Beispielsweise wird das <xref:System.Xml.Serialization.XmlIncludeAttribute> -Attribut für die Inklusion von Typen verwendet statt des <xref:System.Runtime.Serialization.KnownTypeAttribute> -Attributs.</span><span class="sxs-lookup"><span data-stu-id="6e84a-355">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="6e84a-356">Einige Bedrohungen, die sich speziell auf <xref:System.Xml.Serialization.XmlSerializer> beziehen, werden jedoch weiter unten in diesem Thema erläutert.</span><span class="sxs-lookup"><span data-stu-id="6e84a-356">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="6e84a-357">Verhindern des Ladens unerwünschter Typen</span><span class="sxs-lookup"><span data-stu-id="6e84a-357">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="6e84a-358">Das Laden unerwünschter Typen kann schwerwiegende Folgen haben, unabhängig davon, ob der Typ schädlich ist oder nur sicherheitsrelevante Nebeneffekte aufweist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-358">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="6e84a-359">Ein Typ kann Sicherheitslücken verursachen, sicherheitsrelevante Aktionen in seinem Konstruktor oder dem Klassenkonstruktor ausführen, eine große Menge Arbeitsspeicher belegen, was Denial-of-Service-Angriffe vereinfacht, oder nicht behebbare Ausnahmen auslösen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-359">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="6e84a-360">Typen können Klassenkonstruktoren besitzen, die beim Laden des Typs vor dem Erstellen von Instanzen sofort ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-360">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="6e84a-361">Aus diesen Gründen ist es wichtig, die Reihe der Typen zu steuern, die das Deserialisierungsprogramm laden kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-361">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="6e84a-362"><xref:System.Runtime.Serialization.DataContractSerializer> führt die Desialisierung mit einer losen Verknüpfung durch.</span><span class="sxs-lookup"><span data-stu-id="6e84a-362">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="6e84a-363">Es werden keine Namen von CRL-Typen (Common Language Runtime) oder von Assemblys in den eingehenden Daten gelesen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-363">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="6e84a-364">Das ist mit dem Verhalten von <xref:System.Xml.Serialization.XmlSerializer>vergleichbar, unterscheidet sich jedoch vom Verhalten von <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>und von <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="6e84a-364">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="6e84a-365">Die lose Verknüpfung bietet eine gewisse Sicherheit, da Remoteangreifer das Laden eines beliebigen Typs nicht veranlassen können, indem sie diesen Typ einfach in der Nachricht benennen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-365">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="6e84a-366"><xref:System.Runtime.Serialization.DataContractSerializer> darf stets einen Typ laden, der in Übereinstimmung mit dem Vertrag gerade erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-366">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="6e84a-367">Wenn z. B. ein Datenvertrag einen Datenmember vom Typ `Customer`enthält, darf <xref:System.Runtime.Serialization.DataContractSerializer> den `Customer` -Typ beim Deserialisieren dieses Datenmembers laden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-367">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="6e84a-368">Darüber hinaus unterstützt <xref:System.Runtime.Serialization.DataContractSerializer> Polymorphie.</span><span class="sxs-lookup"><span data-stu-id="6e84a-368">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="6e84a-369">Ein Datenmember kann als <xref:System.Object>deklariert werden, die eingehenden Daten können jedoch eine `Customer` -Instanz enthalten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-369">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="6e84a-370">Das ist nur möglich, wenn der `Customer` -Typ für das Deserialisierungsprogramm anhand einer der folgenden Mechanismen "bekannt" gemacht wurde:</span><span class="sxs-lookup"><span data-stu-id="6e84a-370">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="6e84a-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> -Attribut wird auf einen Typ angewendet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-371"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="6e84a-372">`KnownTypeAttribute` -Attribut gibt eine Methode an, die eine Liste mit Typen zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-372">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="6e84a-373">`ServiceKnownTypeAttribute` -Attribut.</span><span class="sxs-lookup"><span data-stu-id="6e84a-373">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="6e84a-374">`KnownTypes` -Konfigurationsabschnitt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-374">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="6e84a-375">Eine Liste bekannter Typen wird bei direkter Verwendung des Serialisierungsprogramm während der Erstellung explizit an <xref:System.Runtime.Serialization.DataContractSerializer> übergeben.</span><span class="sxs-lookup"><span data-stu-id="6e84a-375">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="6e84a-376">Jede dieser Mechanismen erhöht die Angriffsfläche, da sie die Anzahl der Typen erhöhen, die das Deserialisierungsprogramm laden kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-376">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="6e84a-377">Überprüfen Sie diese Mechanismen und stellen Sie sicher, dass der Liste der bekannten Typen keine unerwünschten Typen hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-377">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="6e84a-378">Sobald sich ein bekannter Typ im Bereich befindet, kann er jederzeit geladen und Instanzen des Typs erstellt werden, selbst wenn der Vertag dessen Verwendung an sich verbietet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-378">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="6e84a-379">Angenommen, der Typ "MyDangerousType" wird über einen dieser Mechanismen der Liste der bekannten Typen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-379">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="6e84a-380">Dies bedeutet Folgendes:</span><span class="sxs-lookup"><span data-stu-id="6e84a-380">This means that:</span></span>

- <span data-ttu-id="6e84a-381">`MyDangerousType` wird geladen und sein Klassenkonstruktor wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-381">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="6e84a-382">Auch wenn nur ein Datenvertrag mit einem Zeichenfolgendatenmember deserialisiert wird, kann eine böswillige Nachricht dazu führen, dass eine Instanz von `MyDangerousType` erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-382">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="6e84a-383">Code in `MyDangerousType`, z. B. ein Eigenschaftensetter, wird möglicherweise ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-383">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="6e84a-384">Anschließend versucht das Deserialisierungsprogramm diese Instanz dem Zeichenfolgendatenmember zuzuordnen, schlägt fehl und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="6e84a-384">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="6e84a-385">Wenn Sie eine Methode schreiben, die eine Liste bekannter Typen zurückgibt, oder wenn Sie eine Liste direkt an den <xref:System.Runtime.Serialization.DataContractSerializer> -Konstruktor übergeben, stellen Sie sicher, dass der Code zum Erstellen der Liste sicher ist und nur vertrauenswürdige Daten heranzieht.</span><span class="sxs-lookup"><span data-stu-id="6e84a-385">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="6e84a-386">Wenn Sie bekannte Typen in Konfiguration angeben, stellen Sie sicher, dass die Konfigurationsdatei sicher ist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-386">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="6e84a-387">Verwenden Sie stets starke Namen in der Konfiguration, indem Sie den öffentlichen Schlüssel der signierten Assembly angeben, in der sich der Typ befindet. Geben Sie jedoch nicht die Version des zu ladenden Typs an.</span><span class="sxs-lookup"><span data-stu-id="6e84a-387">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="6e84a-388">Das Typladeprogramm wählt die neueste Version wenn möglich automatisch aus.</span><span class="sxs-lookup"><span data-stu-id="6e84a-388">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="6e84a-389">Die Angabe einer bestimmten Version in der Konfiguration birgt folgendes Risiko: Falls ein Typ eine Sicherheitslücke aufweist, die eine spätere Version möglicherweise beseitigt, wird trotzdem die gefährdete Version geladen, da sie in der Konfiguration ausdrücklich angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-389">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="6e84a-390">Zu viele bekannte Typen haben eine weitere Konsequenz: <xref:System.Runtime.Serialization.DataContractSerializer> erstellt einen Cache mit Serialisierungs-/Deserialisierungscode in der Anwendungsdomäne. Dabei erhält jeder zu serialisierende und zu deserialisierende Typ einen Eintrag.</span><span class="sxs-lookup"><span data-stu-id="6e84a-390">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="6e84a-391">Dieser Cache wird nie gelöscht, solange die Anwendungsdomäne ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-391">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="6e84a-392">Folglich kann ein Angreifer, dem die Verwendung vieler bekannter Typen in einer Anwendung bekannt ist, die Deserialisierung all dieser Typen veranlassen, wodurch der Cache außerordentlich viel Arbeitsspeicher verbraucht.</span><span class="sxs-lookup"><span data-stu-id="6e84a-392">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="6e84a-393">Verhindern eines unerwünschter Zustands der Typen</span><span class="sxs-lookup"><span data-stu-id="6e84a-393">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="6e84a-394">Ein Typ besitzt möglicherweise interne Konsistenzeinschränkungen, die beachtet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-394">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="6e84a-395">Diese Einschränkungen dürfen bei der Deserialisierung nicht außer Kraft gesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-395">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="6e84a-396">Im folgenden Beispiel wird der Zustand einer Luftschleuse in einer Raumsonde dargestellt. Dabei gilt die Einschränkung, dass beide Türen nicht gleichzeitig geöffnet werden können.</span><span class="sxs-lookup"><span data-stu-id="6e84a-396">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="6e84a-397">Ein Angreifer kann folgende böswillige Nachricht senden, um die Einschränkungen zu umgehen und das Objekt in einen ungültigen Zustand zu versetzen, der unerwünschte und unvorhersehbare Folgen haben kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-397">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="6e84a-398">Diese Situation ist vermeidbar, wenn folgenden Punkte beachtet werden:</span><span class="sxs-lookup"><span data-stu-id="6e84a-398">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="6e84a-399">Wenn <xref:System.Runtime.Serialization.DataContractSerializer> Klassen deserialisiert, werden in den meisten Fällen keine Konstruktoren ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-399">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="6e84a-400">Verlassen Sie sich deshalb nicht darauf, dass der Konstruktor Zustände verwaltet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-400">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="6e84a-401">Verwenden Sie Rückrufe, um sicherzustellen, dass sich das Objekt in einem gültigen Zustand befindet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-401">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="6e84a-402">Der mit dem <xref:System.Runtime.Serialization.OnDeserializedAttribute> -Attribut gekennzeichnete Rückruf ist besonders hilfreich, wenn er nach Abschluss der Deserialisierung ausgeführt wird und den Gesamtzustand überprüfen und korrigieren kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-402">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="6e84a-403">Weitere Informationen finden Sie unter [Versions tolerante Serialisierungsrückrufe](version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="6e84a-403">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="6e84a-404">Entwerfen Sie Datenvertragstypen nicht nach einer bestimmten Reihenfolge, in der Eigenschaftensetter aufgerufen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-404">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="6e84a-405">Seien Sie vorsichtig, wenn Sie ältere Typen verwenden, die mit dem <xref:System.SerializableAttribute> -Attribut gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="6e84a-405">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="6e84a-406">Viele davon wurden entwickelt, um mit .NET Framework Remoting für die Verwendung mit vertrauenswürdigen Daten zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-406">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="6e84a-407">Bei der Entwicklung vorhandener Typen, die mit diesem Attribut gekennzeichnet sind, spielte die Sicherheit möglicherweise keine Rolle.</span><span class="sxs-lookup"><span data-stu-id="6e84a-407">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="6e84a-408">Verlassen Sie sich nicht darauf, dass die <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> -Eigenschaft des <xref:System.Runtime.Serialization.DataMemberAttribute> -Attributs das Vorhandensein von Daten in einem sicheren Zustand garantiert.</span><span class="sxs-lookup"><span data-stu-id="6e84a-408">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="6e84a-409">Deren Status könnte auch `null`, `zero`oder `invalid`lauten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-409">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="6e84a-410">Vertrauen Sie niemals einem Objektdiagramm, das von einer nicht vertrauenswürdigen Datenquelle deserialisiert wurde, ohne es zuerst zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-410">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="6e84a-411">Zwar kann sich jedes einzelne Objekt in einem konsistenten Zustand befinden, das Objektdiagramm insgesamt vielleicht jedoch nicht.</span><span class="sxs-lookup"><span data-stu-id="6e84a-411">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="6e84a-412">Außerdem kann es sein, dass selbst bei deaktiviertem Objektdiagramm-Beibehaltungsmodus das deserialisierte Diagramm in einem Zirkelverweis noch mehrere Verweise auf das selbe Objekt aufweist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-412">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="6e84a-413">Weitere Informationen finden Sie unter [Serialisierung und Deserialisierung](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="6e84a-413">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="6e84a-414">Sicheres Verwenden von NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="6e84a-414">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="6e84a-415">ph x="1" /&gt; ist eine Serialisierungs-Engine, das eng verknüpfte Typen verwendet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-415">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="6e84a-416">Das ist mit <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> und <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>vergleichbar.</span><span class="sxs-lookup"><span data-stu-id="6e84a-416">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="6e84a-417">Das heißt, es bestimmt, welcher Typ instanziiert werden soll, indem er die .NET Framework Assembly und den Typnamen aus den eingehenden Daten liest.</span><span class="sxs-lookup"><span data-stu-id="6e84a-417">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="6e84a-418">Obwohl es Teil von WCF ist, gibt es keine Möglichkeit, diese Serialisierungs-Engine zu überspringen. benutzerdefinierter Code muss geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-418">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="6e84a-419">Der `NetDataContractSerializer` wird hauptsächlich zur Erleichterung der Migration von .NET Framework Remoting zu WCF bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-419">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="6e84a-420">Weitere Informationen finden Sie im entsprechenden Abschnitt unter [Serialisierung und Deserialisierung](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="6e84a-420">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="6e84a-421">Da die Nachricht selbst möglicherweise alle ladbaren Typen angibt, ist der <xref:System.Runtime.Serialization.NetDataContractSerializer> -Mechanismus grundsätzlich unsicher und sollte nur mit vertrauenswürdigen Daten verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-421">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="6e84a-422">Weitere Informationen finden Sie im [BinaryFormatter-Sicherheitshandbuch](../../../standard/serialization/binaryformatter-security-guide.md).</span><span class="sxs-lookup"><span data-stu-id="6e84a-422">For more information, see the [BinaryFormatter security guide](../../../standard/serialization/binaryformatter-security-guide.md).</span></span>

<span data-ttu-id="6e84a-423">Selbst wenn das Modul mit vertrauenswürdigen Daten arbeitet, geben die eingehenden Daten möglicherweise den zu ladenden Typ nur ungenau an, insbesondere, wenn die <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> -Eigenschaft auf <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-423">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="6e84a-424">Jeder, der Zugriff auf das Verzeichnis der Anwendung oder den globalen Assemblycache besitzt, kann den vorhandenen zu ladenden Typ durch einen schädlichen Typ ersetzen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-424">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="6e84a-425">Stellen Sie stets sicher, dass das Verzeichnis der Anwendung und der globale Anwendungscache gesichert sind, indem Sie die Berechtigungen richtig festlegen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-425">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="6e84a-426">Im Allgemeinen gilt: Wenn Sie teilweise vertrauenswürdigem Code erlauben, auf Ihre `NetDataContractSerializer` -Instanz zuzugreifen oder auf andere Weise den Ersatzselektor (<xref:System.Runtime.Serialization.ISurrogateSelector>) bzw. den Serialisierungsbinder (<xref:System.Runtime.Serialization.SerializationBinder>) zu steuern, kann er möglicherweise einen großen Teil des Serialisierungs-/Deserialisierungsprozesses steuern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-426">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="6e84a-427">Er kann beispielsweise beliebige Typen einfügen, was zur Offenlegung von Informationen führt, oder das sich ergebende Objektdiagramm und die serialisierten Daten manipulieren bzw. einen Überlauf des resultierenden serialisierten Streams herbeiführen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-427">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="6e84a-428">Ein weiteres Sicherheitsproblem bei `NetDataContractSerializer` stellen Denial-of-Service-Angriffe dar, nicht die Gefahr durch das Ausführen von schädlichem Code.</span><span class="sxs-lookup"><span data-stu-id="6e84a-428">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="6e84a-429">Legen Sie bei der Verwendung von `NetDataContractSerializer`das <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> -Kontingent immer auf einen sicheren Wert fest.</span><span class="sxs-lookup"><span data-stu-id="6e84a-429">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="6e84a-430">Eine kleine böswillige Nachricht kann leicht erstellt werden, die ein Array von Objekten zuordnet, deren Größe nur durch dieses Kontingent eingeschränkt werden kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-430">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="6e84a-431">Spezielle Bedrohungen bei XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="6e84a-431">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="6e84a-432">Das <xref:System.Xml.Serialization.XmlSerializer> -Sicherheitsmodell ähnelt dem von <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="6e84a-432">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="6e84a-433">Einige Bedrohungen sind jedoch speziell bei <xref:System.Xml.Serialization.XmlSerializer>relevant.</span><span class="sxs-lookup"><span data-stu-id="6e84a-433">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="6e84a-434"><xref:System.Xml.Serialization.XmlSerializer> generiert zur Laufzeit *Serialisierungsassemblys* mit Code, der die eigentliche Serialisierung und Deserialisierung ausführt. Diese Assemblys werden in einem temporären Dateiverzeichnis erstellt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-434">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="6e84a-435">Wenn ein anderer Prozess oder Benutzer Zugriffrechte für dieses Verzeichnis besitzt, kann er den Serialisierungs-/Deserialisierungscode mit beliebigem Code überschreiben.</span><span class="sxs-lookup"><span data-stu-id="6e84a-435">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="6e84a-436"><xref:System.Xml.Serialization.XmlSerializer> führt dann diesen Code mit dessen Sicherheitskontext anstelle des Serialisierungs-/Deserialisierungscode aus.</span><span class="sxs-lookup"><span data-stu-id="6e84a-436">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="6e84a-437">Stellen Sie sicher, dass die Berechtigungen für das temporäre Dateiverzeichnis richtig festgelegt sind, um dieses Szenario zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-437">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="6e84a-438"><xref:System.Xml.Serialization.XmlSerializer> besitzt außerdem einen Modus, in dem Serialisierungsassemblys nicht zur Laufzeit generiert werden, sondern bereits generierte Serialisierungsassemblys verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-438">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="6e84a-439">Dieser Modus wird immer dann ausgelöst, wenn <xref:System.Xml.Serialization.XmlSerializer> eine geeignete Serialisierungsassembly findet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-439">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="6e84a-440"><xref:System.Xml.Serialization.XmlSerializer> überprüft, ob die Serialisierungsassembly mit demselben Schlüssel signiert wurde wie die Assembly, die die zu serialisierenden Typen enthält.</span><span class="sxs-lookup"><span data-stu-id="6e84a-440">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="6e84a-441">Dies dient als Schutz vor schädlichen Assemblys, die als Serialisierungsassemblys getarnt sind.</span><span class="sxs-lookup"><span data-stu-id="6e84a-441">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="6e84a-442">Wenn die Assembly mit den serialisierbaren Typen jedoch nicht signiert ist, kann <xref:System.Xml.Serialization.XmlSerializer> diese Überprüfung nicht ausführen und verwendet eine beliebige Assembly mit dem richtigen Namen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-442">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="6e84a-443">Auf diese Weise kann schädlicher Code ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-443">This makes running malicious code possible.</span></span> <span data-ttu-id="6e84a-444">Signieren Sie stets die Assemblys, die die serialisierbaren Typen enthalten, oder schränken Sie den Zugriff auf das Verzeichnis der Anwendung und den globalen Assemblycache stark ein, um das Eindringen von schädlichen Assemblys zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-444">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="6e84a-445"><xref:System.Xml.Serialization.XmlSerializer> kann einem Denial-of-Service-Angriff ausgesetzt sein.</span><span class="sxs-lookup"><span data-stu-id="6e84a-445">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="6e84a-446"><xref:System.Xml.Serialization.XmlSerializer> verfügt über kein `MaxItemsInObjectGraph` -Kontingent (wie es bei <xref:System.Runtime.Serialization.DataContractSerializer>vorhanden ist).</span><span class="sxs-lookup"><span data-stu-id="6e84a-446">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="6e84a-447">Deshalb wird eine beliebige Anzahl von Objekten deserialisiert, die nur durch die Nachrichtengröße eingeschränkt wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-447">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="6e84a-448">Bedrohungen durch teilweise vertrauenswürdigen Code</span><span class="sxs-lookup"><span data-stu-id="6e84a-448">Partial Trust Threats</span></span>

<span data-ttu-id="6e84a-449">Berücksichtigen Sie beim Ausführen von teilweise vertrauenswürdigem Code die folgenden Überlegungen zu den damit verbundenen Bedrohungen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-449">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="6e84a-450">Zu diesen Bedrohungen gehören enthaltener schädlicher Code ebenso wie schädlicher Code in Verbindung mit anderen Angriffsszenarien (z.&#160;B. teilweise vertrauenswürdiger Code, der eine bestimmte Zeichenfolge enthält und diese anschließend deserialisiert).</span><span class="sxs-lookup"><span data-stu-id="6e84a-450">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="6e84a-451">Bestätigen Sie bei der Verwendung irgendwelcher Serialisierungskomponenten niemals im Voraus Berechtigungen, selbst wenn die gesamte Serialisierung innerhalb des Assertionsbereichs stattfindet und nur vertrauenswürdige Daten oder Objekte behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-451">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="6e84a-452">Eine solche Vorgehensweise könnte zu Sicherheitslücken führen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-452">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="6e84a-453">In Fällen, in denen teilweise vertrauenswürdiger Code entweder über Erweiterungspunkte (Ersatzzeichen), über zu serialisierende Typen oder über andere Mittel den Serialisierungsprozess bestimmt, kann dieser teilweise vertrauenswürdige Code bewirken, dass das Serialisierungsprogramm eine große Datenmenge in den serialisierten Stream ausgibt, was einen Denial-of-Service (DoS) beim Empfänger dieses Streams bewirken kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-453">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="6e84a-454">Wenn Sie Daten serialisieren, die für ein Ziel bestimmt sind, das für DoS-Angriffe anfällig ist, dann serialisieren Sie keine teilweise vertrauenswürdigen Typen und lassen Sie nicht zu, dass teilweise vertrauenswürdiger Code die Serialisierung irgendwie steuert.</span><span class="sxs-lookup"><span data-stu-id="6e84a-454">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="6e84a-455">Wenn Sie teilweise vertrauenswürdigen Code Zugriff auf die- <xref:System.Runtime.Serialization.DataContractSerializer> Instanz gewähren oder die Ersatz Zeichen für den [Datenvertrag](../extending/data-contract-surrogates.md)anderweitig steuern, kann der Serialisierungs-/Deserialisierungsprozess viel Kontrolle über den Prozess der Serialisierung/Deserialisierung haben.</span><span class="sxs-lookup"><span data-stu-id="6e84a-455">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="6e84a-456">Er kann beispielsweise beliebige Typen einfügen, was zur Offenlegung von Informationen führt, oder das sich ergebende Objektdiagramm und die serialisierten Daten manipulieren bzw. einen Überlauf des resultierenden serialisierten Streams herbeiführen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-456">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="6e84a-457">Eine entsprechende <xref:System.Runtime.Serialization.NetDataContractSerializer> -Bedrohung wird im Abschnitt "Sicheres Verwenden von NetDataContractSerializer" beschrieben.</span><span class="sxs-lookup"><span data-stu-id="6e84a-457">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="6e84a-458">Wenn das <xref:System.Runtime.Serialization.DataContractAttribute> -Attribut auf einen Typ angewendet wird (oder der Typ als <xref:System.SerializableAttribute> gekennzeichnet wird, ohne <xref:System.Runtime.Serialization.ISerializable>zu sein), kann das Deserialisierungsprogramm eine Instanz eines solchen Typs selbst dann erstellen, wenn alle Konstruktoren durch Aufrufe nicht öffentlich und/oder geschützt sind.</span><span class="sxs-lookup"><span data-stu-id="6e84a-458">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="6e84a-459">Vertrauen Sie niemals dem Ergebnis der Deserialisierung, es sei denn , die Daten können als vertrauenswürdig eingestuft werden und Sie sind sicher, dass alle bekannten Typen vertrauenswürdige Typen sind.</span><span class="sxs-lookup"><span data-stu-id="6e84a-459">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="6e84a-460">Beachten Sie, dass bei Ausführung unter teilweiser Vertrauenswürdigkeit bekannte Typen nicht aus der Anwendungskonfigurationsdatei, sondern aus der Computerkonfigurationsdatei geladen werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-460">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="6e84a-461">Wenn Sie eine <xref:System.Runtime.Serialization.DataContractSerializer> -Instanz mit einem Ersatzselektor übergeben, der im teilweise vertrauenswürdigen Modus hinzugefügt wurde, kann der Code alle änderbaren Einstellungen dieses Ersatzselektors ändern.</span><span class="sxs-lookup"><span data-stu-id="6e84a-461">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="6e84a-462">Wenn ein XML-Reader (oder die enthaltenen Daten) auf teilweise vertrauenswürdigem Code basiert, dann betrachten Sie das resultierende deserialisierte Objekt als nicht vertrauenswürdige Daten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-462">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="6e84a-463">Der Umstand, dass der <xref:System.Runtime.Serialization.ExtensionDataObject> -Typ keine öffentlichen Member besitzt, bedeutet nicht, dass die darin enthaltenen Daten sicher sind.</span><span class="sxs-lookup"><span data-stu-id="6e84a-463">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="6e84a-464">Wenn Sie z.&#160;B. eine Deserialisierung aus einer privilegierten Datenquelle in ein Objekt ausführen, in dem sich einige Daten befinden, und dieses Objekt anschließend an teilweise vertrauenswürdigen Code übergeben, kann dieser Code die Daten in `ExtensionDataObject` lesen, indem er das Objekt serialisiert.</span><span class="sxs-lookup"><span data-stu-id="6e84a-464">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="6e84a-465">Legen Sie bei einer Deserialisierung aus einer privilegierten Datenquelle in ein Objekt, das später an teilweise vertrauenswürdigen Code übergeben wird, wenn möglich die <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> -Einstellung auf `true` fest.</span><span class="sxs-lookup"><span data-stu-id="6e84a-465">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="6e84a-466"><xref:System.Runtime.Serialization.DataContractSerializer> und <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> unterstützen die Serialisierung von privaten, geschützten, internen und öffentlichen Membern mit vollständiger Vertrauenswürdigkeit.</span><span class="sxs-lookup"><span data-stu-id="6e84a-466"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="6e84a-467">Bei teilweiser Vertrauenswürdigkeit können jedoch nur öffentliche Member serialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-467">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="6e84a-468">Wenn eine Anwendung versucht, einen nicht öffentlichen Member zu serialisieren, wird eine <xref:System.Security.SecurityException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="6e84a-468">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="6e84a-469">Verwenden Sie das <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> -Assemblyattribut, um zuzulassen, dass interne oder geschützte interne Member serialisiert werden können.</span><span class="sxs-lookup"><span data-stu-id="6e84a-469">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="6e84a-470">Dieses Attribut ermöglicht es einer Assembly zu deklarieren, dass eigene interne Member in anderen Assemblys sichtbar sein sollen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-470">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="6e84a-471">In diesem Fall deklariert eine Assembly, deren interne Member serialisiert werden sollen, dass ihre internen Member für System.Runtime.Serialization.dll sichtbar sein sollen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-471">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="6e84a-472">Der Vorteil dieser Vorgehensweise besteht darin, dass kein Codegenerierungspfad mit erweiterten Berechtigungen erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-472">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="6e84a-473">Gleichzeitig sind jedoch zwei gravierende Nachteile zu beachten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-473">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="6e84a-474">Der erste Nachteil besteht darin, dass die Opt-In-Eigenschaft des <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> -Attributs assemblyweit festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="6e84a-474">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="6e84a-475">Das heißt, Sie können nicht angeben, dass nur die internen Member einer bestimmten Klasse serialisiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-475">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="6e84a-476">Natürlich können Sie immer noch festlegen, dass ein bestimmter interner Member nicht serialisiert werden soll, indem Sie dem betreffenden Member einfach kein <xref:System.Runtime.Serialization.DataMemberAttribute> -Attribut hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-476">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="6e84a-477">Ebenso können Entwickler angeben, dass ein Member intern und nicht privat oder geschützt ist, wobei jedoch geringe Nachteile in Bezug auf die Sichtbarkeit zu erwarten sind.</span><span class="sxs-lookup"><span data-stu-id="6e84a-477">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="6e84a-478">Der zweite Nachteil besteht darin, dass nach wie vor keine privaten und geschützten Member unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-478">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="6e84a-479">Betrachten Sie das folgende Programm, das die Verwendung des <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> -Attributs bei teilweiser Vertrauenswürdigkeit veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="6e84a-479">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="6e84a-480">Im obigen Beispiel entspricht `PermissionsHelper.InternetZone` dem <xref:System.Security.PermissionSet> für teilweise Vertrauenswürdigkeit.</span><span class="sxs-lookup"><span data-stu-id="6e84a-480">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="6e84a-481">Nun, ohne das- <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> Attribut, schlägt die Anwendung fehl und löst einen aus, der <xref:System.Security.SecurityException> angibt, dass nicht öffentliche Member bei teilweiser Vertrauenswürdigkeit nicht serialisiert werden können.</span><span class="sxs-lookup"><span data-stu-id="6e84a-481">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="6e84a-482">Wenn jedoch der Quelldatei die folgende Zeile hinzugefügt wird, wird das Programm erfolgreich ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-482">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="6e84a-483">Weitere Überlegungen zur Zustandsverwaltung</span><span class="sxs-lookup"><span data-stu-id="6e84a-483">Other State Management Concerns</span></span>

<span data-ttu-id="6e84a-484">Es gibt noch einige Überlegungen zur Verwaltung von Objektzuständen, die erwähnt werden sollten:</span><span class="sxs-lookup"><span data-stu-id="6e84a-484">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="6e84a-485">Bei der Verwendung eines auf Streams basierenden Programmiermodells mit einem Streamingtransport findet die Verarbeitung der Nachricht statt, sobald sie eingeht.</span><span class="sxs-lookup"><span data-stu-id="6e84a-485">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="6e84a-486">Der Absender der Nachricht kann den Sendevorgang in der Mitte des Streams abbrechen, wodurch Ihr Code einen unvorhersehbaren Zustand annimmt, falls mehr Inhalt erwartet wurde.</span><span class="sxs-lookup"><span data-stu-id="6e84a-486">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="6e84a-487">Verlassen Sie sich im Allgemeinen nicht darauf, dass Streams abgeschlossen werden, und führen Sie keine Arbeiten in einem streambasierten Vorgang aus, für die im Fall eines abgebrochenen Streams kein Rollback erfolgen kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-487">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="6e84a-488">Das gilt auch für den Fall, dass eine Nachricht nach dem Streamingtext falsch formatiert ist (es fehlt z. B. ein Endtag für den SOAP-Umschlag oder es ist ein zweiter Nachrichtentext vorhanden).</span><span class="sxs-lookup"><span data-stu-id="6e84a-488">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="6e84a-489">Mit der `IExtensibleDataObject` -Funktion werden möglicherweise vertrauliche Daten ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="6e84a-489">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="6e84a-490">Wenn Sie Daten aus einer nicht vertrauenswürdigen Quelle in Datenverträgen mit `IExtensibleObjectData` zulassen und später über einen sicheren Kanal neu ausgeben, in dem Nachrichten signiert sind, bürgen Sie womöglich für völlig unbekannte Daten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-490">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="6e84a-491">Darüber hinaus sind vielleicht die gesendeten Daten insgesamt ungültig, wenn Sie sowohl die bekannten als auch die unbekannten Teile der Daten in Betracht ziehen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-491">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="6e84a-492">Vermeiden Sie diese Situation, indem Sie entweder die Eigenschaft der Erweiterungsdaten selektiv auf `null` festlegen oder indem Sie selektiv die `IExtensibleObjectData` -Funktion deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="6e84a-492">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="6e84a-493">Schemaimport</span><span class="sxs-lookup"><span data-stu-id="6e84a-493">Schema Import</span></span>

<span data-ttu-id="6e84a-494">Normalerweise wird ein Schema zum Generieren von Typen nur zur Entwurfszeit importiert, beispielsweise, wenn Sie mit dem [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) eine Clientklasse für einen Webdienst generieren.</span><span class="sxs-lookup"><span data-stu-id="6e84a-494">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="6e84a-495">In komplexeren Szenarien jedoch verarbeiten Sie ein Schema vielleicht auch zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="6e84a-495">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="6e84a-496">Seien Sie sich jedoch bewusst, dass dabei das Risiko von Denial-of-Service-Angriffen besteht.</span><span class="sxs-lookup"><span data-stu-id="6e84a-496">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="6e84a-497">Bei einigen Schemas dauert das Importieren sehr lange.</span><span class="sxs-lookup"><span data-stu-id="6e84a-497">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="6e84a-498">Verwenden Sie in solchen Szenarien niemals die Schemaimportkomponente von <xref:System.Xml.Serialization.XmlSerializer> , falls Schemas von einer nicht vertrauenswürdigen Quelle stammen könnten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-498">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="6e84a-499">Spezielle Bedrohungen bei der ASP.NET AJAX-Integration</span><span class="sxs-lookup"><span data-stu-id="6e84a-499">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="6e84a-500">Wenn der Benutzer <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> oder implementiert <xref:System.ServiceModel.Description.WebHttpBehavior> , macht WCF einen Endpunkt verfügbar, der sowohl XML-als auch JSON-Nachrichten akzeptieren kann.</span><span class="sxs-lookup"><span data-stu-id="6e84a-500">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="6e84a-501">Es gibt jedoch nur einen Satz von Readerkontingenten, der sowohl vom XML-Reader als auch von JSON-Reader verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-501">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="6e84a-502">Einige Kontingenteinstellungen sind möglicherweise für einen Reader geeignet, aber zu groß für den anderen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-502">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="6e84a-503">Mit der Implementierung von `WebScriptEnablingBehavior`hat der Benutzer die Möglichkeit, beim Endpunkt einen JavaScript-Proxy verfügbar zu machen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-503">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="6e84a-504">Die folgenden Sicherheitsprobleme müssen beachtet werden:</span><span class="sxs-lookup"><span data-stu-id="6e84a-504">The following security issues must be considered:</span></span>

- <span data-ttu-id="6e84a-505">Informationen über den Dienst (Vorgangsnamen, Parameternamen usw.) können abgerufen werden, indem der JavaScript-Proxy überprüft wird.</span><span class="sxs-lookup"><span data-stu-id="6e84a-505">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="6e84a-506">Wird der JavaScript-Endpunkt verwendet, bleiben möglicherweise vertrauliche und private Informationen im Webbrowsercache des Clients gespeichert.</span><span class="sxs-lookup"><span data-stu-id="6e84a-506">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="6e84a-507">Hinweis zu Komponenten</span><span class="sxs-lookup"><span data-stu-id="6e84a-507">A Note on Components</span></span>

<span data-ttu-id="6e84a-508">WCF ist ein flexibles und anpassbares System.</span><span class="sxs-lookup"><span data-stu-id="6e84a-508">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="6e84a-509">Die meisten Inhalte dieses Themas konzentrieren sich auf die gängigsten WCF-Verwendungs Szenarien.</span><span class="sxs-lookup"><span data-stu-id="6e84a-509">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="6e84a-510">Es ist jedoch möglich, Komponenten, die WCF bereitstellt, auf viele verschiedene Arten zu verfassen.</span><span class="sxs-lookup"><span data-stu-id="6e84a-510">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="6e84a-511">Deshalb sollten Sie wissen, welche Auswirkung die Verwendung der einzelnen Komponenten auf die Sicherheit hat.</span><span class="sxs-lookup"><span data-stu-id="6e84a-511">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="6e84a-512">Dies gilt insbesondere für:</span><span class="sxs-lookup"><span data-stu-id="6e84a-512">In particular:</span></span>

- <span data-ttu-id="6e84a-513">Wenn XML-Reader notwendig sind, verwenden Sie nur die Reader der <xref:System.Xml.XmlDictionaryReader> -Klasse.</span><span class="sxs-lookup"><span data-stu-id="6e84a-513">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="6e84a-514">Sichere Reader werden mit den Methoden <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>oder <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> erstellt.</span><span class="sxs-lookup"><span data-stu-id="6e84a-514">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="6e84a-515">Verwenden Sie nicht die <xref:System.Xml.XmlReader.Create%2A> -Methode.</span><span class="sxs-lookup"><span data-stu-id="6e84a-515">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="6e84a-516">Konfigurieren Sie die Reader immer mit sicheren Kontingenten.</span><span class="sxs-lookup"><span data-stu-id="6e84a-516">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="6e84a-517">Die serialisierungsengines in WCF sind nur dann sicher, wenn Sie mit sicheren XML-Lesern von WCF verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-517">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="6e84a-518">Wenn Sie potenziell nicht vertrauenswürdige Daten mit <xref:System.Runtime.Serialization.DataContractSerializer> deserialisieren, legen Sie immer die <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> -Eigenschaft fest.</span><span class="sxs-lookup"><span data-stu-id="6e84a-518">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="6e84a-519">Legen Sie beim Erstellen einer Nachricht den `maxSizeOfHeaders` -Parameter fest, falls `MaxReceivedMessageSize` keinen ausreichenden Schutz bietet.</span><span class="sxs-lookup"><span data-stu-id="6e84a-519">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="6e84a-520">Wenn Sie einen Encoder erstellen, konfigurieren Sie stets die relevanten Kontingente, z. B. `MaxSessionSize` und `MaxBufferSize`.</span><span class="sxs-lookup"><span data-stu-id="6e84a-520">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="6e84a-521">Legen Sie bei Verwendung eines XPath-Nachrichtenfilters <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> fest, um die Menge der XML-Knoten einzuschränken, die der Filter durchläuft.</span><span class="sxs-lookup"><span data-stu-id="6e84a-521">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="6e84a-522">Verwenden Sie keine XPath-Ausdrücke, deren Berechnung lange dauert, ohne dass viele Knoten durchlaufen werden.</span><span class="sxs-lookup"><span data-stu-id="6e84a-522">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="6e84a-523">Machen Sie sich generell bei der Verwendung einer Komponente, die ein Kontingent akzeptiert, mit dessen Auswirkung auf die Sicherheit vertraut, und legen Sie einen sicheren Wert dafür fest.</span><span class="sxs-lookup"><span data-stu-id="6e84a-523">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="6e84a-524">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="6e84a-524">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="6e84a-525">Bekannte Typen in Datenverträgen</span><span class="sxs-lookup"><span data-stu-id="6e84a-525">Data Contract Known Types</span></span>](data-contract-known-types.md)
