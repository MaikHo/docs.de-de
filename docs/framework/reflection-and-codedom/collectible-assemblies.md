---
title: Entladbare Assemblys für die dynamische Typgenerierung
description: Hier erfahren Sie mehr über die ersten Schritte mit entladbaren Assemblys für die dynamische Typgenerierung in .NET. Informieren Sie sich über die Lebensdauer und Einschränkungen der entladbaren Assemblys.
ms.date: 08/29/2017
helpviewer_keywords:
- reflection, dynamic assembly
- assemblies, collectible
- collectible assemblies, retrieving
ms.openlocfilehash: 4981b93dbd49a6da96740bebed0f2ed7b89036c8
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 07/20/2020
ms.locfileid: "86475124"
---
# <a name="collectible-assemblies-for-dynamic-type-generation"></a><span data-ttu-id="6f77d-104">Entladbare Assemblys für die dynamische Typgenerierung</span><span class="sxs-lookup"><span data-stu-id="6f77d-104">Collectible assemblies for dynamic type generation</span></span>

<span data-ttu-id="6f77d-105">Bei *entladbaren Assemblys* handelt es sich um dynamische Assemblys, die entladen werden können, ohne die Anwendungsdomäne zu entladen, in der sie erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-105">*Collectible assemblies* are dynamic assemblies that can be unloaded without unloading the application domain in which they were created.</span></span> <span data-ttu-id="6f77d-106">Der verwaltete und nicht verwaltete Speicher, der von einer entladbaren Assembly und den darin enthaltenen Typen verwendet wurde, kann wieder freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-106">All managed and unmanaged memory used by a collectible assembly and the types it contains can be reclaimed.</span></span> <span data-ttu-id="6f77d-107">Informationen wie der Name der Assembly werden aus den internen Tabellen entfernt.</span><span class="sxs-lookup"><span data-stu-id="6f77d-107">Information such as the assembly name is removed from internal tables.</span></span>

<span data-ttu-id="6f77d-108">Verwenden Sie zum Aktivieren der Entladung das <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType>-Flag, wenn Sie eine dynamische Assembly erstellen.</span><span class="sxs-lookup"><span data-stu-id="6f77d-108">To enable unloading, use the <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType> flag when you create a dynamic assembly.</span></span> <span data-ttu-id="6f77d-109">Die Assembly ist flüchtig (d.h. sie kann nicht gespeichert werden) und unterliegt den Einschränkungen, die im Abschnitt [Einschränkungen bei entladbaren Assemblys](#restrictions-on-collectible-assemblies) beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-109">The assembly is transient (that is, it cannot be saved) and is subject to limitations described in the [Restrictions on Collectible Assemblies](#restrictions-on-collectible-assemblies) section.</span></span> <span data-ttu-id="6f77d-110">Die Common Language Runtime (CLR) entlädt eine entladbare Assembly automatisch, wenn Sie alle Objekte freigeben, die der Assembly zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="6f77d-110">The common language runtime (CLR) unloads a collectible assembly automatically when you release all objects associated with the assembly.</span></span> <span data-ttu-id="6f77d-111">In jeder anderen Hinsicht werden entladbare Assemblys genau wie andere dynamische Assemblys erstellt und verwendet.</span><span class="sxs-lookup"><span data-stu-id="6f77d-111">In all other respects, collectible assemblies are created and used in the same way as other dynamic assemblies.</span></span>

## <a name="lifetime-of-collectible-assemblies"></a><span data-ttu-id="6f77d-112">Lebensdauer von entladbaren Assemblys</span><span class="sxs-lookup"><span data-stu-id="6f77d-112">Lifetime of collectible assemblies</span></span>

<span data-ttu-id="6f77d-113">Die Lebensdauer einer entladbaren Assembly wird durch das Vorhandensein der Verweise auf die enthaltenen Typen und auf die Objekte, die aus diesen Typen erstellt werden, gesteuert.</span><span class="sxs-lookup"><span data-stu-id="6f77d-113">The lifetime of a collectible assembly is controlled by the existence of references to the types it contains and the objects that are created from those types.</span></span> <span data-ttu-id="6f77d-114">Die Common Language Runtime entlädt eine Assembly nicht, solange mindestens eins der folgenden Objekte vorhanden ist (bei `T` handelt es sich um einen beliebigen Typ, der in der Assembly definiert wird):</span><span class="sxs-lookup"><span data-stu-id="6f77d-114">The common language runtime does not unload an assembly as long as one or more of the following exist (`T` is any type that is defined in the assembly):</span></span>

- <span data-ttu-id="6f77d-115">Eine Instanz von `T`.</span><span class="sxs-lookup"><span data-stu-id="6f77d-115">An instance of `T`.</span></span>

- <span data-ttu-id="6f77d-116">Eine Instanz eines Arrays von `T`.</span><span class="sxs-lookup"><span data-stu-id="6f77d-116">An instance of an array of `T`.</span></span>

- <span data-ttu-id="6f77d-117">Eine Instanz eines generischen Typs, der über `T` als Typargument verfügt.</span><span class="sxs-lookup"><span data-stu-id="6f77d-117">An instance of a generic type that has `T` as one of its type arguments.</span></span> <span data-ttu-id="6f77d-118">Dies schließt generische Auflistungen von `T` ein, auch wenn diese Auflistung leer ist.</span><span class="sxs-lookup"><span data-stu-id="6f77d-118">This includes generic collections of `T`, even if that collection is empty.</span></span>

- <span data-ttu-id="6f77d-119">Eine Instanz von <xref:System.Type> oder <xref:System.Reflection.Emit.TypeBuilder>, die `T` darstellt.</span><span class="sxs-lookup"><span data-stu-id="6f77d-119">An instance of <xref:System.Type> or <xref:System.Reflection.Emit.TypeBuilder> that represents `T`.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="6f77d-120">Sie müssen alle Objekte freigeben, die Teile der Assembly darstellen.</span><span class="sxs-lookup"><span data-stu-id="6f77d-120">You must release all objects that represent parts of the assembly.</span></span> <span data-ttu-id="6f77d-121">Die <xref:System.Reflection.Emit.ModuleBuilder>-Klasse, die `T` definiert, behält einen Verweis auf <xref:System.Reflection.Emit.TypeBuilder> bei, und das <xref:System.Reflection.Emit.AssemblyBuilder>-Objekt behält einen Verweis auf <xref:System.Reflection.Emit.ModuleBuilder> bei. Die Verweise auf diese Objekte müssen ebenfalls freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-121">The <xref:System.Reflection.Emit.ModuleBuilder> that defines `T` keeps a reference to the <xref:System.Reflection.Emit.TypeBuilder>, and the <xref:System.Reflection.Emit.AssemblyBuilder> object keeps a reference to the <xref:System.Reflection.Emit.ModuleBuilder>, so references to these objects must be released.</span></span> <span data-ttu-id="6f77d-122">Auch das Vorhandensein einer <xref:System.Reflection.Emit.LocalBuilder>- oder <xref:System.Reflection.Emit.ILGenerator>-Klasse, die bei der Erstellung von `T` verwendet werden, verhindert das Entladen.</span><span class="sxs-lookup"><span data-stu-id="6f77d-122">Even the existence of a <xref:System.Reflection.Emit.LocalBuilder> or an <xref:System.Reflection.Emit.ILGenerator> used in the construction of `T` prevents unloading.</span></span>

- <span data-ttu-id="6f77d-123">Ein statischer Verweis auf `T` durch einen anderen dynamisch definierten `T1`-Typ, der für ausgeführten Code weiterhin erreichbar ist.</span><span class="sxs-lookup"><span data-stu-id="6f77d-123">A static reference to `T` by another dynamically defined type `T1` that is still reachable by executing code.</span></span> <span data-ttu-id="6f77d-124">`T1` kann beispielsweise von `T` abgeleitet werden, oder `T` kann den Typ eines Parameters in einer Methode von `T1` darstellen.</span><span class="sxs-lookup"><span data-stu-id="6f77d-124">For example, `T1` might derive from `T`, or `T` might be the type of a parameter in a method of `T1`.</span></span>

- <span data-ttu-id="6f77d-125">Ein **ByRef**-Modifizierer für ein statisches Feld, das zu `T` gehört.</span><span class="sxs-lookup"><span data-stu-id="6f77d-125">A **ByRef** to a static field that belongs to `T`.</span></span>

- <span data-ttu-id="6f77d-126">Eine <xref:System.RuntimeTypeHandle>-, <xref:System.RuntimeFieldHandle>- oder <xref:System.RuntimeMethodHandle>-Struktur, die auf `T` oder eine Komponente von `T` verweist.</span><span class="sxs-lookup"><span data-stu-id="6f77d-126">A <xref:System.RuntimeTypeHandle>, <xref:System.RuntimeFieldHandle>, or <xref:System.RuntimeMethodHandle> that refers to `T` or to a component of `T`.</span></span>

- <span data-ttu-id="6f77d-127">Eine Instanz eines beliebigen Reflektionsobjekts, das indirekt oder direkt verwendet werden kann, um auf das <xref:System.Type>-Objekt zuzugreifen, das `T` darstellt.</span><span class="sxs-lookup"><span data-stu-id="6f77d-127">An instance of any reflection object that could be used indirectly or directly to access the <xref:System.Type> object that represents `T`.</span></span> <span data-ttu-id="6f77d-128">Das <xref:System.Type>-Objekt für `T` kann beispielsweise von einem Arraytyp abgerufen werden, dessen Elementtyp `T` ist, oder von einem generischen Typ mit `T` als Typargument.</span><span class="sxs-lookup"><span data-stu-id="6f77d-128">For example, the <xref:System.Type> object for `T` can be obtained from an array type whose element type is `T`, or from a generic type that has `T` as a type argument.</span></span>

- <span data-ttu-id="6f77d-129">Eine `M`-Methode in der Aufrufliste eines beliebigen Threads, bei der `M` eine Methode von `T` oder eine Methode auf Modulebene darstellt, die in der Assembly definiert ist.</span><span class="sxs-lookup"><span data-stu-id="6f77d-129">A method `M` on the call stack of any thread, where `M` is a method of `T` or a module-level method that is defined in the assembly.</span></span>

- <span data-ttu-id="6f77d-130">Ein Delegat von einer statischen Methode, der in einem Modul der Assembly definiert wird.</span><span class="sxs-lookup"><span data-stu-id="6f77d-130">A delegate to a static method that is defined in a module of the assembly.</span></span>

<span data-ttu-id="6f77d-131">Wenn ein Element aus dieser Liste für einen Typ oder eine Methode in der Assembly vorhanden ist, kann die Runtime die Assembly nicht entladen.</span><span class="sxs-lookup"><span data-stu-id="6f77d-131">If only one item from this list exists for only one type or one method in the assembly, the runtime cannot unload the assembly.</span></span>

> [!NOTE]
> <span data-ttu-id="6f77d-132">Die Runtime entlädt die Assembly nicht, bevor Finalizer für alle Elemente in der Liste ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-132">The runtime does not actually unload the assembly until finalizers have run for all items in the list.</span></span>

<span data-ttu-id="6f77d-133">Zum Nachverfolgen der Lebensdauer sollte ein konstruierter generischer Typ wie `List<int>` (in C#) oder `List(Of Integer)` (in Visual Basic), der bei der Generierung einer entladbaren Assembly erstellt und verwendet wird, entweder in der Assembly definiert werden, die die generische Typdefinition enthält, oder in einer Assembly, die die Definition von einem seiner Typargumente enthält.</span><span class="sxs-lookup"><span data-stu-id="6f77d-133">For purposes of tracking lifetime, a constructed generic type such as `List<int>` (in C#) or `List(Of Integer)` (in Visual Basic) that is created and used in the generation of a collectible assembly is considered to have been defined either in the assembly that contains the generic type definition or in an assembly that contains the definition of one of its type arguments.</span></span> <span data-ttu-id="6f77d-134">Die Assembly, die verwendet wird, stellt ein Implementierungsdetail dar und unterliegt Änderungen.</span><span class="sxs-lookup"><span data-stu-id="6f77d-134">The exact assembly that is used is an implementation detail and subject to change.</span></span>

## <a name="restrictions-on-collectible-assemblies"></a><span data-ttu-id="6f77d-135">Einschränkungen bei entladbaren Assemblys</span><span class="sxs-lookup"><span data-stu-id="6f77d-135">Restrictions on collectible assemblies</span></span>

<span data-ttu-id="6f77d-136">Für entladbare Assemblys gelten folgende Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="6f77d-136">The following restrictions apply to collectible assemblies:</span></span>

- <span data-ttu-id="6f77d-137">**Statische Verweise:** Die Typen in einer gewöhnlichen dynamischen Assembly können keine statischen Verweise auf Typen enthalten, die in einer entladbaren Assembly definiert sind.</span><span class="sxs-lookup"><span data-stu-id="6f77d-137">**Static references** Types in an ordinary dynamic assembly cannot have static references to types that are defined in a collectible assembly.</span></span> <span data-ttu-id="6f77d-138">Wenn Sie beispielsweise einen normalen Typ definieren, der von einem Typ in einer entladbaren Assembly erbt, wird eine <xref:System.NotSupportedException>-Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="6f77d-138">For example, if you define an ordinary type that inherits from a type in a collectible assembly, a <xref:System.NotSupportedException> exception is thrown.</span></span> <span data-ttu-id="6f77d-139">Ein Typ in einer entladbaren Assembly kann statische Verweise auf einen Typ in einer anderen entladbaren Assembly enthalten, dadurch wird jedoch die Lebensdauer der Assembly, auf die verweisen wird, auf die Lebensdauer der verweisenden Assembly erweitert.</span><span class="sxs-lookup"><span data-stu-id="6f77d-139">A type in a collectible assembly can have static references to a type in another collectible assembly, but this extends the lifetime of the referenced assembly to the lifetime of the referencing assembly.</span></span>

- <span data-ttu-id="6f77d-140">**COM-Interop:** In einer entladbaren Assembly können keine COM-Schnittstellen definiert werden, und Instanzen von Typen in einer entladbaren Assembly können nicht in COM-Objekte konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-140">**COM interop** No COM interfaces can be defined within a collectible assembly, and no instances of types within a collectible assembly can be converted into COM objects.</span></span> <span data-ttu-id="6f77d-141">Ein Typ in einer entladbaren Assembly kann nicht als COM Callable Wrapper (CCW) oder Runtime Callable Wrapper (RCW) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-141">A type in a collectible assembly cannot serve as a COM callable wrapper (CCW) or runtime callable wrapper (RCW).</span></span> <span data-ttu-id="6f77d-142">Typen in entladbaren Assemblys können jedoch Objekte verwenden, die COM-Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="6f77d-142">However, types in collectible assemblies can use objects that implement COM interfaces.</span></span>

- <span data-ttu-id="6f77d-143">**Plattformaufrufe:** Methoden mit dem <xref:System.Runtime.InteropServices.DllImportAttribute>-Attribut können nicht kompiliert werden, wenn diese in einer entladbaren Assembly deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-143">**Platform invoke** Methods that have the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute will not compile when they are declared in a collectible assembly.</span></span> <span data-ttu-id="6f77d-144">Die <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType>-Anweisung kann nicht in der Implementierung eines Typs in einer entladbaren Assembly verwendet werden, und solche Typen können nicht an nicht verwalteten Code gemarshallt werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-144">The <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType> instruction cannot be used in the implementation of a type in a collectible assembly, and such types cannot be marshaled to unmanaged code.</span></span> <span data-ttu-id="6f77d-145">Sie können jedoch Aufrufe in nativem Code durchführen, indem Sie einen Einstiegspunkt verwenden, der in einer nicht entladbaren Assembly deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="6f77d-145">However, you can call into native code by using an entry point that is declared in a non-collectible assembly.</span></span>

- <span data-ttu-id="6f77d-146">**Marshalling:** Objekte (insbesondere Delegate), die in entladbaren Assemblys definiert sind, können nicht gemarshallt werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-146">**Marshaling** Objects (in particular, delegates) that are defined in collectible assemblies cannot be marshaled.</span></span> <span data-ttu-id="6f77d-147">Diese Einschränkung gilt für alle flüchtig ausgegebenen Typen.</span><span class="sxs-lookup"><span data-stu-id="6f77d-147">This is a restriction on all transient emitted types.</span></span>

- <span data-ttu-id="6f77d-148">**Laden von Assemblys:** Die Reflexionsausgabe stellt den einzigen Mechanismus dar, der zum Laden von entladbaren Assemblys unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="6f77d-148">**Assembly loading** Reflection emit is the only mechanism that is supported for loading collectible assemblies.</span></span> <span data-ttu-id="6f77d-149">Assemblys, die mithilfe einer anderen Methode zum Laden von Assemblys geladen werden, können nicht entladen werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-149">Assemblies that are loaded by using any other form of assembly loading cannot be unloaded.</span></span>

- <span data-ttu-id="6f77d-150">**Kontextgebundene Objekte:** Kontextstatische Variablen werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="6f77d-150">**Context-bound objects** Context-static variables are not supported.</span></span> <span data-ttu-id="6f77d-151">Typen in einer entladbaren Assembly können <xref:System.ContextBoundObject> nicht erweitern.</span><span class="sxs-lookup"><span data-stu-id="6f77d-151">Types in a collectible assembly cannot extend <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="6f77d-152">Der Code in entladbaren Assemblys kann jedoch in kontextgebundenen Objekten verwendet werden, die an anderer Stelle definiert werden.</span><span class="sxs-lookup"><span data-stu-id="6f77d-152">However, code in collectible assemblies can use context-bound objects that are defined elsewhere.</span></span>

- <span data-ttu-id="6f77d-153">**Threadstatische Daten:** Threadstatische Variablen werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="6f77d-153">**Thread-static data** Thread-static variables are not supported.</span></span>

## <a name="see-also"></a><span data-ttu-id="6f77d-154">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="6f77d-154">See also</span></span>

- [<span data-ttu-id="6f77d-155">Ausgeben von dynamischen Methoden und Assemblys</span><span class="sxs-lookup"><span data-stu-id="6f77d-155">Emitting Dynamic Methods and Assemblies</span></span>](emitting-dynamic-methods-and-assemblies.md)
