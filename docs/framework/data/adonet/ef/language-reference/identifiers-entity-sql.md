---
title: Bezeichner (Entity SQL)
ms.date: 03/30/2017
ms.assetid: d58a5edd-7b5c-48e1-b5d7-a326ff426aa4
ms.openlocfilehash: 7e9b12ca351b021fab62988969cb98310cb55cc2
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/24/2020
ms.locfileid: "91203695"
---
# <a name="identifiers-entity-sql"></a><span data-ttu-id="35dc4-102">Bezeichner (Entity SQL)</span><span class="sxs-lookup"><span data-stu-id="35dc4-102">Identifiers (Entity SQL)</span></span>

<span data-ttu-id="35dc4-103">Bezeichner werden in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] verwendet, um Abfrageausdruckaliase, Verweise auf Variablen, Eigenschaften von Objekten und Funktionen usw. darzustellen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-103">Identifiers are used in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] to represent query expression aliases, variable references, properties of objects, functions, and so on.</span></span> [!INCLUDE[esql](../../../../../../includes/esql-md.md)] <span data-ttu-id="35dc4-104">bietet zwei Arten von Bezeichnern: einfache Bezeichner und Bezeichner in Anführungszeichen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-104">provides two kinds of identifiers: simple identifiers and quoted identifiers.</span></span>  
  
## <a name="simple-identifiers"></a><span data-ttu-id="35dc4-105">Einfacher Bezeichner</span><span class="sxs-lookup"><span data-stu-id="35dc4-105">Simple Identifiers</span></span>  

 <span data-ttu-id="35dc4-106">Ein einfacher Bezeichner in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] ist eine Sequenz von alphanumerischen Zeichen und unterstrichen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-106">A simple identifier in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] is a sequence of alphanumeric and underscore characters.</span></span> <span data-ttu-id="35dc4-107">Das erste Zeichen des Bezeichners muss ein alphabetisches Zeichen (a-z oder A-Z) sein.</span><span class="sxs-lookup"><span data-stu-id="35dc4-107">The first character of the identifier must be an alphabetical character (a-z or A-Z).</span></span>  
  
## <a name="quoted-identifiers"></a><span data-ttu-id="35dc4-108">Bezeichner in Anführungszeichen</span><span class="sxs-lookup"><span data-stu-id="35dc4-108">Quoted Identifiers</span></span>  

 <span data-ttu-id="35dc4-109">Ein Bezeichner in Anführungszeichen ist eine beliebige Sequenz von in eckige Klammern ([]) eingeschlossenen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-109">A quoted identifier is any sequence of characters enclosed in square brackets ([]).</span></span> <span data-ttu-id="35dc4-110">Mit Bezeichnern in Anführungszeichen können Bezeichner mit Zeichen festgelegt werden, die in gewöhnlichen Bezeichnern nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="35dc4-110">Quoted identifiers let you specify identifiers with characters that are not valid in identifiers.</span></span> <span data-ttu-id="35dc4-111">Alle Zeichen zwischen den eckigen Klammern werden Teil des Bezeichners, einschließlich aller Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-111">All characters between the square brackets become part of the identifier, including all white space.</span></span>  
  
 <span data-ttu-id="35dc4-112">Folgende Zeichen dürfen in einem Bezeichner in Anführungszeichen nicht enthalten sein:</span><span class="sxs-lookup"><span data-stu-id="35dc4-112">A quoted identifier cannot include the following characters:</span></span>  
  
- <span data-ttu-id="35dc4-113">Zeilenumbruch</span><span class="sxs-lookup"><span data-stu-id="35dc4-113">Newline.</span></span>  
  
- <span data-ttu-id="35dc4-114">Wagenrücklauf</span><span class="sxs-lookup"><span data-stu-id="35dc4-114">Carriage returns.</span></span>  
  
- <span data-ttu-id="35dc4-115">Tabulator</span><span class="sxs-lookup"><span data-stu-id="35dc4-115">Tabs.</span></span>  
  
- <span data-ttu-id="35dc4-116">Rücktaste</span><span class="sxs-lookup"><span data-stu-id="35dc4-116">Backspace.</span></span>  
  
- <span data-ttu-id="35dc4-117">Zusätzliche eckige Klammern (d. h. eckige Klammern innerhalb der eckigen Klammern, die den Bezeichner umschließen)</span><span class="sxs-lookup"><span data-stu-id="35dc4-117">Additional square brackets (that is, square brackets within the square brackets that delineate the identifier).</span></span>  
  
 <span data-ttu-id="35dc4-118">Ein Bezeichner in Anführungszeichen kann Unicode-Zeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="35dc4-118">A quoted-identifier can include Unicode characters.</span></span>  
  
 <span data-ttu-id="35dc4-119">Durch Bezeichner in Anführungszeichen können Sie Eigenschaftennamen mit Zeichen erstellen, die in Bezeichnern nicht zulässig sind, wie im folgenden Beispiel verdeutlicht wird:</span><span class="sxs-lookup"><span data-stu-id="35dc4-119">Quoted identifiers enable you to create property name characters that are not valid in identifiers, as illustrated in the following example:</span></span>  
  
 `SELECT c.ContactName AS [Contact Name] FROM customers AS c`  
  
 <span data-ttu-id="35dc4-120">Sie können auch Bezeichner in Anführungszeichen verwenden, um einen Bezeichner anzugeben, der einem reservierten Schlüsselwort von [!INCLUDE[esql](../../../../../../includes/esql-md.md)] entspricht.</span><span class="sxs-lookup"><span data-stu-id="35dc4-120">You can also use quoted identifiers to specify an identifier that is a reserved keyword of [!INCLUDE[esql](../../../../../../includes/esql-md.md)].</span></span> <span data-ttu-id="35dc4-121">Wenn beispielsweise der Typ  über eine Eigenschaft mit dem Namen "From" verfügt, können Sie diese vom reservierten Schlüsselwort FROM durch die Verwendung von eckigen Klammern wie folgt unterscheiden:</span><span class="sxs-lookup"><span data-stu-id="35dc4-121">For example, if the type `Email` has a property named "From", you can disambiguate it from the reserved keyword FROM by using square brackets, as follows:</span></span>  
  
 `SELECT e.[From] FROM emails AS e`  
  
 <span data-ttu-id="35dc4-122">Ein Bezeichner in Anführungszeichen kann rechts von einem Punkt (.)-Operator verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="35dc4-122">You can use a quoted identifier on the right side of a dot (.) operator.</span></span>  
  
 `SELECT t FROM ts as t WHERE t.[property] == 2`  
  
 <span data-ttu-id="35dc4-123">Fügen Sie eine zusätzliche eckige Klammer hinzu, um die eckige Klammer in einem Bezeichner zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="35dc4-123">To use the square bracket in an identifier, add an extra square bracket.</span></span> <span data-ttu-id="35dc4-124">Im folgenden Beispiel ist "`abc]`" der Bezeichner:</span><span class="sxs-lookup"><span data-stu-id="35dc4-124">In the following example "`abc]`" is the identifier:</span></span>  
  
 `SELECT t from ts as t WHERE t.[abc]]] == 2`  
  
 <span data-ttu-id="35dc4-125">Informationen zur Vergleichs Semantik in Anführungszeichen finden Sie unter [Eingabe Zeichensatz](input-character-set-entity-sql.md).</span><span class="sxs-lookup"><span data-stu-id="35dc4-125">For quoted identifier comparison semantics, see [Input Character Set](input-character-set-entity-sql.md).</span></span>  
  
## <a name="aliasing-rules"></a><span data-ttu-id="35dc4-126">Regeln für das Aliasing</span><span class="sxs-lookup"><span data-stu-id="35dc4-126">Aliasing Rules</span></span>  

 <span data-ttu-id="35dc4-127">Es empfiehlt sich, bei Bedarf Aliase in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] Abfragen anzugeben, einschließlich der folgenden [!INCLUDE[esql](../../../../../../includes/esql-md.md)] Konstrukte:</span><span class="sxs-lookup"><span data-stu-id="35dc4-127">We recommend specifying aliases in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] queries whenever needed, including the following [!INCLUDE[esql](../../../../../../includes/esql-md.md)] constructs:</span></span>  
  
- <span data-ttu-id="35dc4-128">Felder eines Zeilenkonstruktors.</span><span class="sxs-lookup"><span data-stu-id="35dc4-128">Fields of a row constructor.</span></span>  
  
- <span data-ttu-id="35dc4-129">Elemente in der FROM-Klausel eines Abfrageausdrucks.</span><span class="sxs-lookup"><span data-stu-id="35dc4-129">Items in the FROM clause of a query expression.</span></span>  
  
- <span data-ttu-id="35dc4-130">Elemente in der SELECT-Klausel eines Abfrageausdrucks.</span><span class="sxs-lookup"><span data-stu-id="35dc4-130">Items in the SELECT clause of a query expression.</span></span>  
  
- <span data-ttu-id="35dc4-131">Elemente in der GROUP BY-Klausel eines Abfrageausdrucks.</span><span class="sxs-lookup"><span data-stu-id="35dc4-131">Items in the GROUP BY clause of a query expression.</span></span>  
  
### <a name="valid-aliases"></a><span data-ttu-id="35dc4-132">Gültige Aliase</span><span class="sxs-lookup"><span data-stu-id="35dc4-132">Valid Aliases</span></span>  

 <span data-ttu-id="35dc4-133">Gültige Aliase in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] sind einfache Bezeichner oder Bezeichner in Anführungszeichen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-133">Valid aliases in [!INCLUDE[esql](../../../../../../includes/esql-md.md)] are any simple identifier or quoted identifier.</span></span>  
  
### <a name="alias-generation"></a><span data-ttu-id="35dc4-134">Generierung von Aliasen</span><span class="sxs-lookup"><span data-stu-id="35dc4-134">Alias Generation</span></span>  

 <span data-ttu-id="35dc4-135">Wenn in einem Abfrage Ausdruck kein Alias angegeben ist [!INCLUDE[esql](../../../../../../includes/esql-md.md)] , [!INCLUDE[esql](../../../../../../includes/esql-md.md)] versucht, einen Alias auf der Grundlage der folgenden einfachen Regeln zu generieren:</span><span class="sxs-lookup"><span data-stu-id="35dc4-135">If no alias is specified in an [!INCLUDE[esql](../../../../../../includes/esql-md.md)] query expression, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] tries to generate an alias based on the following simple rules:</span></span>  
  
- <span data-ttu-id="35dc4-136">Wenn es sich bei dem Abfrageausdruck (für den der Alias nicht angegeben wurde) um einen einfachen Bezeichner oder Bezeichner in Anführungszeichen handelt, wird dieser Bezeichner als Alias verwendet.</span><span class="sxs-lookup"><span data-stu-id="35dc4-136">If the query expression (for which the alias is unspecified) is a simple or quoted identifier, that identifier is used as the alias.</span></span> <span data-ttu-id="35dc4-137">`ROW(a, [b])` wird beispielsweise zu `ROW(a AS a, [b] AS [b])`.</span><span class="sxs-lookup"><span data-stu-id="35dc4-137">For example, `ROW(a, [b])` becomes `ROW(a AS a, [b] AS [b])`.</span></span>  
  
- <span data-ttu-id="35dc4-138">Wenn es sich bei dem Abfrageausdruck um einen komplexeren Ausdruck handelt, die letzte Komponente dieses Abfrageausdrucks jedoch ein einfacher Bezeichner ist, wird dieser Bezeichner als Alias verwendet.</span><span class="sxs-lookup"><span data-stu-id="35dc4-138">If the query expression is a more complex expression, but the last component of that query expression is a simple identifier, then that identifier is used as the alias.</span></span> <span data-ttu-id="35dc4-139">`ROW(a.a1, b.[b1])` wird beispielsweise zu `ROW(a.a1 AS a1, b.[b1] AS [b1])`.</span><span class="sxs-lookup"><span data-stu-id="35dc4-139">For example, `ROW(a.a1, b.[b1])` becomes `ROW(a.a1 AS a1, b.[b1] AS [b1])`.</span></span>  
  
 <span data-ttu-id="35dc4-140">Sie sollten implizites Aliasing vermeiden, wenn Sie den Aliasnamen später verwenden möchten.</span><span class="sxs-lookup"><span data-stu-id="35dc4-140">We recommend that you do not use implicit aliasing if you want to use the alias name later.</span></span> <span data-ttu-id="35dc4-141">Wenn Aliase (implizit oder explizit) miteinander in Konflikt stehen oder im selben Gültigkeitsbereich wiederholt auftreten, kommt es zu einem Kompilierungsfehler.</span><span class="sxs-lookup"><span data-stu-id="35dc4-141">Anytime aliases (implicit or explicit) conflict or are repeated in the same scope, there will be a compile error.</span></span> <span data-ttu-id="35dc4-142">Eine impliziter Alias durchläuft die Kompilierung auch dann, wenn ein expliziter oder impliziter Alias desselben Namens vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="35dc4-142">An implicit alias will pass compilation even if there is an explicit or implicit alias of the same name.</span></span>  
  
 <span data-ttu-id="35dc4-143">Implizite Aliase werden anhand von Benutzereingaben automatisch generiert.</span><span class="sxs-lookup"><span data-stu-id="35dc4-143">Implicit aliases are autogenerated based on user input.</span></span> <span data-ttu-id="35dc4-144">Beispielsweise generiert die folgende Codezeile "NAME" als Alias für beide Spalten, wodurch ein Konflikt entsteht.</span><span class="sxs-lookup"><span data-stu-id="35dc4-144">For example, the following line of code will generate NAME as an alias for both columns and therefore will conflict.</span></span>  
  
```sql  
SELECT product.NAME, person.NAME  
```  
  
 <span data-ttu-id="35dc4-145">Die folgende Codezeile, in der explizite Aliase verwendet werden, schlägt ebenfalls fehl.</span><span class="sxs-lookup"><span data-stu-id="35dc4-145">The following line of code, which uses explicit aliases, will also fail.</span></span> <span data-ttu-id="35dc4-146">Der Fehler ist jedoch offensichtlicher beim Lesen des Codes.</span><span class="sxs-lookup"><span data-stu-id="35dc4-146">However, the failure will be more apparent by reading the code.</span></span>  
  
```sql  
SELECT 1 AS X, 2 AS X …  
```  
  
## <a name="scoping-rules"></a><span data-ttu-id="35dc4-147">Bereichsregeln</span><span class="sxs-lookup"><span data-stu-id="35dc4-147">Scoping Rules</span></span>  

 [!INCLUDE[esql](../../../../../../includes/esql-md.md)] <span data-ttu-id="35dc4-148">definiert Bereichs Regeln, die bestimmen, wann bestimmte Variablen in der Abfragesprache sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="35dc4-148">defines scoping rules that determine when particular variables are visible in the query language.</span></span> <span data-ttu-id="35dc4-149">Mit einigen Ausdrücken oder Anweisungen werden neue Namen eingeführt.</span><span class="sxs-lookup"><span data-stu-id="35dc4-149">Some expressions or statements introduce new names.</span></span> <span data-ttu-id="35dc4-150">Die Bereichsregeln bestimmen, wo solche Namen verwendet werden können und wann oder wo eine neue Deklaration mit demselben Namen wie eine andere die vorherige übergehen kann.</span><span class="sxs-lookup"><span data-stu-id="35dc4-150">The scoping rules determine where those names can be used, and when or where a new declaration with the same name as another can hide its predecessor.</span></span>  
  
 <span data-ttu-id="35dc4-151">Wenn Namen in einer-Abfrage definiert werden [!INCLUDE[esql](../../../../../../includes/esql-md.md)] , werden Sie in einem Bereich definiert.</span><span class="sxs-lookup"><span data-stu-id="35dc4-151">When names are defined in an [!INCLUDE[esql](../../../../../../includes/esql-md.md)] query, they are said to be defined within a scope.</span></span> <span data-ttu-id="35dc4-152">Ein Gültigkeitsbereich deckt einen vollständigen Bereich der Abfrage ab.</span><span class="sxs-lookup"><span data-stu-id="35dc4-152">A scope covers an entire region of the query.</span></span> <span data-ttu-id="35dc4-153">Für alle Ausdrücke oder Namensverweise innerhalb eines bestimmten Gültigkeitsbereichs sind Namen sichtbar, die innerhalb dieses Gültigkeitsbereichs definiert sind.</span><span class="sxs-lookup"><span data-stu-id="35dc4-153">All expressions or name references within a certain scope can see names that are defined within that scope.</span></span> <span data-ttu-id="35dc4-154">Vor dem Beginn und nach dem Ende eines Gültigkeitsbereichs kann nicht auf Namen verwiesen werden, die innerhalb des Gültigkeitsbereichs definiert sind.</span><span class="sxs-lookup"><span data-stu-id="35dc4-154">Before a scope begins and after it ends, names that are defined within the scope cannot be referenced.</span></span>  
  
 <span data-ttu-id="35dc4-155">Gültigkeitsbereiche können geschachtelt werden.</span><span class="sxs-lookup"><span data-stu-id="35dc4-155">Scopes can be nested.</span></span> <span data-ttu-id="35dc4-156">Teile von [!INCLUDE[esql](../../../../../../includes/esql-md.md)] stellen neue Bereiche vor, die ganze Regionen abdecken, und diese Regionen können andere Ausdrücke enthalten, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] die auch Bereiche enthalten.</span><span class="sxs-lookup"><span data-stu-id="35dc4-156">Parts of [!INCLUDE[esql](../../../../../../includes/esql-md.md)] introduce new scopes that cover entire regions, and these regions can contain other [!INCLUDE[esql](../../../../../../includes/esql-md.md)] expressions that also introduce scopes.</span></span> <span data-ttu-id="35dc4-157">Wenn Gültigkeitsbereiche geschachtelt sind, kann auf Namen verwiesen werden, die im innersten Gültigkeitsbereich definiert sind, der den Verweis enthält.</span><span class="sxs-lookup"><span data-stu-id="35dc4-157">When scopes are nested, references can be made to names that are defined in the innermost scope, which contains the reference.</span></span> <span data-ttu-id="35dc4-158">Außerdem kann auf alle Namen verwiesen werden, die in beliebigen äußeren Gültigkeitsbereichen definiert sind.</span><span class="sxs-lookup"><span data-stu-id="35dc4-158">References can also be made to any names that are defined in any outer scopes.</span></span> <span data-ttu-id="35dc4-159">Zwei beliebige Gültigkeitsbereiche, die innerhalb desselben Gültigkeitsbereichs definiert sind, werden als nebengeordnete Gültigkeitsbereiche bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="35dc4-159">Any two scopes defined within the same scope are considered sibling scopes.</span></span> <span data-ttu-id="35dc4-160">Es kann nicht auf Namen verwiesen werden, die innerhalb nebengeordneter Gültigkeitsbereiche definiert sind.</span><span class="sxs-lookup"><span data-stu-id="35dc4-160">References cannot be made to names that are defined within sibling scopes.</span></span>  
  
 <span data-ttu-id="35dc4-161">Wenn ein Name in einem inneren Gültigkeitsbereich mit einem Namen in einem äußeren Gültigkeitsbereich übereinstimmt, beziehen sich Verweise im inneren Gültigkeitsbereich oder in Gültigkeitsbereichen, die innerhalb dieses Gültigkeitsbereichs deklariert sind, ausschließlich auf den neu deklarierten Namen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-161">If a name declared in an inner scope matches a name declared in an outer scope, references within the inner scope or within scopes declared within that scope refer only to the newly declared name.</span></span> <span data-ttu-id="35dc4-162">Der Name im äußeren Gültigkeitsbereich ist nicht sichtbar.</span><span class="sxs-lookup"><span data-stu-id="35dc4-162">The name in the outer scope is hidden.</span></span>  
  
 <span data-ttu-id="35dc4-163">Selbst innerhalb desselben Gültigkeitsbereichs kann auf Namen erst verwiesen werden, wenn diese definiert sind.</span><span class="sxs-lookup"><span data-stu-id="35dc4-163">Even within the same scope, names cannot be referenced before they are defined.</span></span>  
  
 <span data-ttu-id="35dc4-164">Globale Namen können als Teil der Ausführungsumgebung existieren.</span><span class="sxs-lookup"><span data-stu-id="35dc4-164">Global names can exist as part of the execution environment.</span></span> <span data-ttu-id="35dc4-165">Dies kann Namen von permanenten Auflistungen oder Umgebungsvariablen einschließen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-165">This can include names of persistent collections or environment variables.</span></span> <span data-ttu-id="35dc4-166">Damit ein Name global ist, muss dieser im äußersten Gültigkeitsbereich deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="35dc4-166">For a name to be global, it must be declared in the outermost scope.</span></span>  
  
 <span data-ttu-id="35dc4-167">Parameter befinden sich nicht in einem Gültigkeitsbereich.</span><span class="sxs-lookup"><span data-stu-id="35dc4-167">Parameters are not in a scope.</span></span> <span data-ttu-id="35dc4-168">Da Verweise auf Parameter eine spezielle Syntax einschließen, treten niemals Konflikte zwischen Namen von Parametern und anderen Namen in der Abfrage auf.</span><span class="sxs-lookup"><span data-stu-id="35dc4-168">Because references to parameters include special syntax, names of parameters will never collide with other names in the query.</span></span>  
  
### <a name="query-expressions"></a><span data-ttu-id="35dc4-169">Abfrageausdrücke</span><span class="sxs-lookup"><span data-stu-id="35dc4-169">Query Expressions</span></span>  

 <span data-ttu-id="35dc4-170">Mit einem [!INCLUDE[esql](../../../../../../includes/esql-md.md)] Abfrage Ausdruck wird ein neuer Bereich eingeführt.</span><span class="sxs-lookup"><span data-stu-id="35dc4-170">An [!INCLUDE[esql](../../../../../../includes/esql-md.md)] query expression introduces a new scope.</span></span> <span data-ttu-id="35dc4-171">Namen, die in der FROM-Klausel definiert sind, werden im FROM-Gültigkeitsbereich in der Reihenfolge ihres Auftretens von links nach rechts eingeführt.</span><span class="sxs-lookup"><span data-stu-id="35dc4-171">Names that are defined in the FROM clause are introduced into the from scope in order of appearance, left to right.</span></span> <span data-ttu-id="35dc4-172">In der Joinliste können Ausdrücke auf Namen verweisen, die zuvor in der Liste definiert wurden.</span><span class="sxs-lookup"><span data-stu-id="35dc4-172">In the join list, expressions can refer to names that were defined earlier in the list.</span></span> <span data-ttu-id="35dc4-173">Öffentliche Eigenschaften (Felder usw.) von in der FROM-Klausel festgelegten Elementen werden dem FROM-Gültigkeitsbereich nicht hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="35dc4-173">Public properties (fields and so on) of elements identified in the FROM clause are not added to the from-scope.</span></span> <span data-ttu-id="35dc4-174">Auf sie muss immer durch den aliasqualifizierten Namen verwiesen werden.</span><span class="sxs-lookup"><span data-stu-id="35dc4-174">They must be always referenced by the alias-qualified name.</span></span> <span data-ttu-id="35dc4-175">Üblicherweise werden alle Teile des SELECT-Ausdrucks als innerhalb des FROM-Gültigkeitsbereichs angesehen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-175">Typically, all parts of the SELECT expression are considered within the from-scope.</span></span>  
  
 <span data-ttu-id="35dc4-176">Mit der GROUP BY-Klausel wird auch ein neuer nebengeordneter Gültigkeitsbereich eingeführt.</span><span class="sxs-lookup"><span data-stu-id="35dc4-176">The GROUP BY clause also introduces a new sibling scope.</span></span> <span data-ttu-id="35dc4-177">Jede Gruppe kann über einen Gruppennamen verfügen, der auf die Auflistung der Elemente in der Gruppe verweist.</span><span class="sxs-lookup"><span data-stu-id="35dc4-177">Each group can have a group name that refers to the collection of elements in the group.</span></span> <span data-ttu-id="35dc4-178">Mit jedem Gruppierungsausdruck wird auch ein neuer Name im Gruppengültigkeitsbereich eingeführt.</span><span class="sxs-lookup"><span data-stu-id="35dc4-178">Each grouping expression will also introduce a new name into the group-scope.</span></span> <span data-ttu-id="35dc4-179">Darüber hinaus wird das Schachtelaggregat (bzw. die benannte Gruppe) ebenfalls dem Gültigkeitsbereich hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="35dc4-179">Additionally, the nest aggregate (or the named group) is also added to the scope.</span></span> <span data-ttu-id="35dc4-180">Die Gruppierungsausdrücke selbst befinden sich innerhalb des FROM-Gültigkeitsbereichs.</span><span class="sxs-lookup"><span data-stu-id="35dc4-180">The grouping expressions themselves are within the from-scope.</span></span> <span data-ttu-id="35dc4-181">Wenn jedoch eine GROUP BY-Klausel verwendet wird, werden die SELECT-Liste (Projektion), die HAVING-Klausel und die ORDER BY-Klausel als innerhalb des Gruppengültigkeitsbereichs und nicht des FROM-Gültigkeitsbereichs angesehen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-181">However, when a GROUP BY clause is used, the select-list (projection), HAVING clause, and ORDER BY clause are considered to be within the group-scope, and not the from-scope.</span></span> <span data-ttu-id="35dc4-182">Aggregate werden besonders behandelt, wie in der folgenden Aufzählung beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="35dc4-182">Aggregates receive special treatment, as described in the following bulleted list.</span></span>  
  
 <span data-ttu-id="35dc4-183">Folgende weitere Hinweise gelten für Gültigkeitsbereiche:</span><span class="sxs-lookup"><span data-stu-id="35dc4-183">The following are additional notes about scopes:</span></span>  
  
- <span data-ttu-id="35dc4-184">Die SELECT-Liste kann der Reihe nach neue Namen im Gültigkeitsbereich einführen.</span><span class="sxs-lookup"><span data-stu-id="35dc4-184">The select-list can introduce new names into the scope, in order.</span></span> <span data-ttu-id="35dc4-185">Projektionsausdrücke auf der rechten Seite können auf Namen verweisen, die auf der linken Seite projiziert sind.</span><span class="sxs-lookup"><span data-stu-id="35dc4-185">Projection expressions to the right might refer to names projected on the left.</span></span>  
  
- <span data-ttu-id="35dc4-186">Die ORDER BY-Klausel kann auf Namen (Aliase) verweisen, die in der SELECT-Liste angegeben sind.</span><span class="sxs-lookup"><span data-stu-id="35dc4-186">The ORDER BY clause can refer to names (aliases) specified in the select list.</span></span>  
  
- <span data-ttu-id="35dc4-187">Die Reihenfolge der Auswertung von Klauseln innerhalb des SELECT-Ausdrucks bestimmt die Reihenfolge, in der Namen im Gültigkeitsbereich eingeführt werden.</span><span class="sxs-lookup"><span data-stu-id="35dc4-187">The order of evaluation of clauses within the SELECT expression determines the order that names are introduced into the scope.</span></span> <span data-ttu-id="35dc4-188">Die FROM-Klausel wird zuerst ausgewertet, gefolgt von der WHERE-Klausel, GROUP BY-Klausel, HAVING-Klausel, SELECT-Klausel und schließlich der ORDER BY-Klausel.</span><span class="sxs-lookup"><span data-stu-id="35dc4-188">The FROM clause is evaluated first, followed by the WHERE clause, GROUP BY clause, HAVING clause, SELECT clause, and finally the ORDER BY clause.</span></span>  
  
### <a name="aggregate-handling"></a><span data-ttu-id="35dc4-189">Aggregatbehandlung</span><span class="sxs-lookup"><span data-stu-id="35dc4-189">Aggregate Handling</span></span>  

 [!INCLUDE[esql](../../../../../../includes/esql-md.md)] <span data-ttu-id="35dc4-190">unterstützt zwei Formen von Aggregaten: Auflistungs basierte Aggregate und gruppenbasierte Aggregate.</span><span class="sxs-lookup"><span data-stu-id="35dc4-190">supports two forms of aggregates: collection-based aggregates and group-based aggregates.</span></span> <span data-ttu-id="35dc4-191">Auflistungsbasierte Aggregate sind das bevorzugte Konstrukt in [!INCLUDE[esql](../../../../../../includes/esql-md.md)], und gruppenbasierte Aggregate werden für die SQL-Kompatibilität unterstützt.</span><span class="sxs-lookup"><span data-stu-id="35dc4-191">Collection-based aggregates are the preferred construct in [!INCLUDE[esql](../../../../../../includes/esql-md.md)], and group-based aggregates are supported for SQL compatibility.</span></span>  
  
 <span data-ttu-id="35dc4-192">Beim Auflösen eines Aggregats [!INCLUDE[esql](../../../../../../includes/esql-md.md)] versucht zunächst, es als Auflistungs basiertes Aggregat zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="35dc4-192">When resolving an aggregate, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] first tries to treat it as a collection-based aggregate.</span></span> <span data-ttu-id="35dc4-193">Wenn dies fehlschlägt, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] wandelt die Aggregat Eingabe in einen Verweis auf das Schachteln-Aggregat um und versucht, diesen neuen Ausdruck aufzulösen, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="35dc4-193">If that fails, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] transforms the aggregate input into a reference to the nest aggregate and tries to resolve this new expression, as illustrated in the following example.</span></span>  
  
 `AVG(t.c) becomes AVG(group..(t.c))`  
  
## <a name="see-also"></a><span data-ttu-id="35dc4-194">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="35dc4-194">See also</span></span>

- [<span data-ttu-id="35dc4-195">Entity SQL-Referenz</span><span class="sxs-lookup"><span data-stu-id="35dc4-195">Entity SQL Reference</span></span>](entity-sql-reference.md)
- [<span data-ttu-id="35dc4-196">Übersicht über Entity SQL</span><span class="sxs-lookup"><span data-stu-id="35dc4-196">Entity SQL Overview</span></span>](entity-sql-overview.md)
- [<span data-ttu-id="35dc4-197">Eingabezeichensatz</span><span class="sxs-lookup"><span data-stu-id="35dc4-197">Input Character Set</span></span>](input-character-set-entity-sql.md)
