---
title: Abfragen für einzelne Tabellen (LINQ to DataSet)
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 0b74bcf8-3f87-449f-bff7-6bcb0d69d212
ms.openlocfilehash: 17a2fcf54cae64d9443b0cc0e8a37e1002bbd394
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/24/2020
ms.locfileid: "91175355"
---
# <a name="single-table-queries-linq-to-dataset"></a><span data-ttu-id="3ab61-102">Abfragen für einzelne Tabellen (LINQ to DataSet)</span><span class="sxs-lookup"><span data-stu-id="3ab61-102">Single-Table Queries (LINQ to DataSet)</span></span>

<span data-ttu-id="3ab61-103">LINQ-Abfragen (Language-Integrated Query) können für Datenquellen verwendet werden, die die- <xref:System.Collections.Generic.IEnumerable%601> Schnittstelle oder die- <xref:System.Linq.IQueryable%601> Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="3ab61-103">Language-Integrated Query (LINQ) queries work on data sources that implement the <xref:System.Collections.Generic.IEnumerable%601> interface or the <xref:System.Linq.IQueryable%601> interface.</span></span> <span data-ttu-id="3ab61-104">Die- <xref:System.Data.DataTable> Klasse implementiert keine der beiden Schnittstellen, sodass Sie die- <xref:System.Data.DataTableExtensions.AsEnumerable%2A> Methode verwenden müssen, wenn Sie das <xref:System.Data.DataTable> als Quelle in der- `From` Klausel einer LINQ-Abfrage verwenden möchten.</span><span class="sxs-lookup"><span data-stu-id="3ab61-104">The <xref:System.Data.DataTable> class does not implement either interface, so you must call the <xref:System.Data.DataTableExtensions.AsEnumerable%2A> method if you want to use the <xref:System.Data.DataTable> as a source in the `From` clause of a LINQ query.</span></span>  
  
 <span data-ttu-id="3ab61-105">Das folgende Beispiel ruft alle Onlinebestellungen aus der Tabelle SalesOrderHeader ab und zeigt in der Konsole die Auftrags-ID, das Auftragsdatum und die Auftragsnummer an.</span><span class="sxs-lookup"><span data-stu-id="3ab61-105">The following example gets all the online orders from the SalesOrderHeader table and outputs the order ID, order date, and order number to the console.</span></span>  
  
 [!code-csharp[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/CS/Program.cs#where1)]  
 [!code-vb[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/VB/Module1.vb#where1)]
  
 <span data-ttu-id="3ab61-106">Die Abfrage der lokalen Variable wird mit einem Abfrage Ausdruck initialisiert, der für eine oder mehrere Informationsquellen durch Anwenden eines oder mehrerer Abfrage Operatoren entweder von den Standard Abfrage Operatoren oder, bei der LINQ to DataSet, für die-Klasse spezifische Operatoren angewendet wird <xref:System.Data.DataSet> .</span><span class="sxs-lookup"><span data-stu-id="3ab61-106">The local variable query is initialized with a query expression, which operates on one or more information sources by applying one or more query operators from either the standard query operators or, in the case of LINQ to DataSet, operators specific to the <xref:System.Data.DataSet> class.</span></span> <span data-ttu-id="3ab61-107">Der Abfrageausdruck im vorherigen Beispiel verwendet zwei der Standardabfrageoperatoren: `Where` und `Select`.</span><span class="sxs-lookup"><span data-stu-id="3ab61-107">The query expression in the previous example uses two of the standard query operators: `Where` and `Select`.</span></span>  
  
 <span data-ttu-id="3ab61-108">Die `Where`-Klausel filtert die Reihenfolge auf der Basis einer Bedingung. In diesem Fall lautet die Bedingung, dass für `OnlineOrderFlag` der Wert `true` gilt.</span><span class="sxs-lookup"><span data-stu-id="3ab61-108">The `Where` clause filters the sequence based on a condition, in this case that the `OnlineOrderFlag` is set to `true`.</span></span> <span data-ttu-id="3ab61-109">Der `Select`-Operator ordnet ein aufzählbares Objekt zu, das die an den Operator übergebenen Argumente erfasst, und gibt das Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="3ab61-109">The `Select` operator allocates and returns an enumerable object that captures the arguments passed to the operator.</span></span> <span data-ttu-id="3ab61-110">Im Beispiel oben wird ein anonymer Typ mit drei Eigenschaften erstellt: `SalesOrderID`, `OrderDate` und `SalesOrderNumber`.</span><span class="sxs-lookup"><span data-stu-id="3ab61-110">In this above example, an anonymous type is created with three properties: `SalesOrderID`, `OrderDate`, and `SalesOrderNumber`.</span></span> <span data-ttu-id="3ab61-111">Als Werte für diese drei Eigenschaften werden die Werte der Spalten `SalesOrderID`, `OrderDate` und `SalesOrderNumber` aus der `SalesOrderHeader`-Tabelle verwendet.</span><span class="sxs-lookup"><span data-stu-id="3ab61-111">The values of these three properties are set to the values of the `SalesOrderID`, `OrderDate`, and `SalesOrderNumber` columns from the `SalesOrderHeader` table.</span></span>  
  
 <span data-ttu-id="3ab61-112">Die `foreach`-Schleife zählt dann das von `Select` zurückgegebene aufzählbare Objekt auf und gibt die Abfrageergebnisse aus.</span><span class="sxs-lookup"><span data-stu-id="3ab61-112">The `foreach` loop then enumerates the enumerable object returned by `Select` and yields the query results.</span></span> <span data-ttu-id="3ab61-113">Da es sich bei der Abfrage um eine <xref:System.Linq.Enumerable>-Abfrage handelt, die die <xref:System.Collections.Generic.IEnumerable%601>-Schnittstelle implementiert, wird die Auswertung der Abfrage so lange verzögert, bis die Abfragevariable mit der `foreach`-Schleife durchlaufen wird.</span><span class="sxs-lookup"><span data-stu-id="3ab61-113">Because query is an <xref:System.Linq.Enumerable> type, which implements <xref:System.Collections.Generic.IEnumerable%601>, the evaluation of the query is deferred until the query variable is iterated over using the `foreach` loop.</span></span> <span data-ttu-id="3ab61-114">Durch die verzögerte Abfrageauswertung können die Abfragen als Werte erhalten werden, die mehrere Male ausgewertet werden und dabei potenziell jedes Mal ein anderes Ergebnis erbringen können.</span><span class="sxs-lookup"><span data-stu-id="3ab61-114">Deferred query evaluation allows queries to be kept as values that can be evaluated multiple times, each time yielding potentially different results.</span></span>  
  
 <span data-ttu-id="3ab61-115">Die <xref:System.Data.DataRowExtensions.Field%2A>-Methode bietet Zugriff auf die Spaltenwerte einer <xref:System.Data.DataRow>, und das <xref:System.Data.DataRowExtensions.SetField%2A> (im Beispiel oben nicht dargestellt) gibt Spaltenwerte in einer <xref:System.Data.DataRow> an.</span><span class="sxs-lookup"><span data-stu-id="3ab61-115">The <xref:System.Data.DataRowExtensions.Field%2A> method provides access to the column values of a <xref:System.Data.DataRow> and the <xref:System.Data.DataRowExtensions.SetField%2A> (not shown in the previous example) sets column values in a <xref:System.Data.DataRow>.</span></span> <span data-ttu-id="3ab61-116">Sowohl die <xref:System.Data.DataRowExtensions.Field%2A> -Methode als auch die- <xref:System.Data.DataRowExtensions.SetField%2A> Methode behandeln auf NULL festleg Bare Werttypen, sodass Sie nicht explizit nach NULL-Werten suchen müssen.</span><span class="sxs-lookup"><span data-stu-id="3ab61-116">Both the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method handle nullable value types, so you do not have to explicitly check for null values.</span></span> <span data-ttu-id="3ab61-117">Beide Methoden sind darüber hinaus generische Methoden. Der Rückgabetyp muss also nicht umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="3ab61-117">Both methods are generic methods, also, which means you do not have to cast the return type.</span></span> <span data-ttu-id="3ab61-118">Sie könnten die schon vorhandene Spaltenzugriffsmethode in <xref:System.Data.DataRow> (z. B. `o["OrderDate"]`) verwenden, müssten dann aber das Rückgabeobjekt in den entsprechenden Typ umwandeln.</span><span class="sxs-lookup"><span data-stu-id="3ab61-118">You could use the pre-existing column accessor in <xref:System.Data.DataRow> (for example, `o["OrderDate"]`), but doing so would require you to cast the return object to the appropriate type.</span></span>  <span data-ttu-id="3ab61-119">Wenn die Spalte ein Werttyp ist, der NULL-Werte zulässt, müssen Sie mithilfe der-Methode überprüfen, ob der Wert NULL ist <xref:System.Data.DataRow.IsNull%2A> .</span><span class="sxs-lookup"><span data-stu-id="3ab61-119">If the column is a nullable value type you have to check if the value is null by using the <xref:System.Data.DataRow.IsNull%2A> method.</span></span> <span data-ttu-id="3ab61-120">Weitere Informationen finden Sie unter [generische Field-und SetField-Methoden](generic-field-and-setfield-methods-linq-to-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="3ab61-120">For more information, see [Generic Field and SetField Methods](generic-field-and-setfield-methods-linq-to-dataset.md).</span></span>  
  
 <span data-ttu-id="3ab61-121">Beachten Sie, dass der im generischen `T`-Parameter der <xref:System.Data.DataRowExtensions.Field%2A>-Methode und der <xref:System.Data.DataRowExtensions.SetField%2A>-Methode angegebene Datentyp mit dem Typ des zugrunde liegenden Werts übereinstimmen muss. Anderenfalls wird eine <xref:System.InvalidCastException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3ab61-121">Note that the data type specified in the generic parameter `T` of the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method must match the type of the underlying value or an <xref:System.InvalidCastException> will be thrown.</span></span> <span data-ttu-id="3ab61-122">Der angegebene Spaltenname muss außerdem mit dem Namen einer <xref:System.Data.DataSet>-Spalte übereinstimmen. Wenn dies nicht der Fall ist, wird eine <xref:System.ArgumentException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3ab61-122">The specified column name must also match the name of a column in the <xref:System.Data.DataSet> or an <xref:System.ArgumentException> will be thrown.</span></span> <span data-ttu-id="3ab61-123">Die Auslösung der Ausnahme erfolgt in beiden Fällen bei der Datenenumeration zur Laufzeit, wenn die Abfrage ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="3ab61-123">In both cases, the exception is thrown at run time data enumeration when the query is executed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3ab61-124">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="3ab61-124">See also</span></span>

- [<span data-ttu-id="3ab61-125">Tabellenübergreifende Abfragen</span><span class="sxs-lookup"><span data-stu-id="3ab61-125">Cross-Table Queries</span></span>](cross-table-queries-linq-to-dataset.md)
- [<span data-ttu-id="3ab61-126">Abfragen von typisierten DataSets</span><span class="sxs-lookup"><span data-stu-id="3ab61-126">Querying Typed DataSets</span></span>](querying-typed-datasets.md)
- [<span data-ttu-id="3ab61-127">Generische Field- und SetField-Methoden</span><span class="sxs-lookup"><span data-stu-id="3ab61-127">Generic Field and SetField Methods</span></span>](generic-field-and-setfield-methods-linq-to-dataset.md)
