---
title: Auffüllen eines "DataSets" durch einen "DataAdapter"
description: Erfahren Sie, wie Sie ein DataSet aus einem DataAdapter in ADO.net auffüllen, der unabhängig von der Datenquelle ein konsistentes relationales Programmiermodell bereitstellt.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3fa0ac7d-e266-4954-bfac-3fbe2f913153
ms.openlocfilehash: ac84af884238b166266d4206802878c1e21169fd
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/24/2020
ms.locfileid: "91177409"
---
# <a name="populating-a-dataset-from-a-dataadapter"></a><span data-ttu-id="57abb-103">Auffüllen eines "DataSets" durch einen "DataAdapter"</span><span class="sxs-lookup"><span data-stu-id="57abb-103">Populating a DataSet from a DataAdapter</span></span>

<span data-ttu-id="57abb-104">Das ADO.NET-<xref:System.Data.DataSet> ist eine speicherresidente Datendarstellung, das ein konsistentes relationales und von der Datenquelle unabhängiges Programmiermodell bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="57abb-104">The ADO.NET <xref:System.Data.DataSet> is a memory-resident representation of data that provides a consistent relational programming model independent of the data source.</span></span> <span data-ttu-id="57abb-105">Das `DataSet` stellt eine vollständige Datengruppe einschließlich Tabellen, Einschränkungen und Beziehungen zwischen Tabellen dar.</span><span class="sxs-lookup"><span data-stu-id="57abb-105">The `DataSet` represents a complete set of data that includes tables, constraints, and relationships among the tables.</span></span> <span data-ttu-id="57abb-106">Da das `DataSet` von der Datenquelle unabhängig ist, kann ein `DataSet` sowohl lokale Daten einer Anwendung als auch Daten aus mehreren Datenquellen enthalten.</span><span class="sxs-lookup"><span data-stu-id="57abb-106">Because the `DataSet` is independent of the data source, a `DataSet` can include data local to the application, and data from multiple data sources.</span></span> <span data-ttu-id="57abb-107">Die Interaktion mit vorhandenen Datenquellen wird über den `DataAdapter`gesteuert.</span><span class="sxs-lookup"><span data-stu-id="57abb-107">Interaction with existing data sources is controlled through the `DataAdapter`.</span></span>  
  
 <span data-ttu-id="57abb-108">Die `SelectCommand` -Eigenschaft des `DataAdapter` ist ein `Command` -Objekt, das Daten aus der Datenquelle abruft.</span><span class="sxs-lookup"><span data-stu-id="57abb-108">The `SelectCommand` property of the `DataAdapter` is a `Command` object that retrieves data from the data source.</span></span> <span data-ttu-id="57abb-109">Die `InsertCommand`-Eigenschaft, die `UpdateCommand`-Eigenschaft und die `DeleteCommand` -Eigenschaft des `DataAdapter` sind `Command` -Objekte, die Updates an den Daten in der Datenquelle entsprechend den Modifikationen an den Daten im `DataSet`verwalten.</span><span class="sxs-lookup"><span data-stu-id="57abb-109">The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties of the `DataAdapter` are `Command` objects that manage updates to the data in the data source according to modifications made to the data in the `DataSet`.</span></span> <span data-ttu-id="57abb-110">Diese Eigenschaften werden in [Aktualisieren von Datenquellen mit DataAdapters](updating-data-sources-with-dataadapters.md)ausführlicher behandelt.</span><span class="sxs-lookup"><span data-stu-id="57abb-110">These properties are covered in more detail in [Updating Data Sources with DataAdapters](updating-data-sources-with-dataadapters.md).</span></span>  
  
 <span data-ttu-id="57abb-111">Mithilfe der `Fill` -Methode des `DataAdapter` wird ein `DataSet` mit den Ergebnissen vom `SelectCommand` des `DataAdapter`aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="57abb-111">The `Fill` method of the `DataAdapter` is used to populate a `DataSet` with the results of the `SelectCommand` of the `DataAdapter`.</span></span> <span data-ttu-id="57abb-112">`Fill` verwendet als Argumente ein aufzufüllendes `DataSet` sowie ein `DataTable` -Objekt bzw. den Namen der `DataTable` , die mit den Zeilen gefüllt werden soll, die vom `SelectCommand`zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="57abb-112">`Fill` takes as its arguments a `DataSet` to be populated, and a `DataTable` object, or the name of the `DataTable` to be filled with the rows returned from the `SelectCommand`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="57abb-113">Die Verwendung des `DataAdapter` zum Abrufen einer gesamten Tabelle kann einige Zeit in Anspruch nehmen, insbesondere, wenn die Tabelle viele Zeilen enthält.</span><span class="sxs-lookup"><span data-stu-id="57abb-113">Using the `DataAdapter` to retrieve all of a table takes time, especially if there are many rows in the table.</span></span> <span data-ttu-id="57abb-114">Der Grund hierfür ist, dass das Zugreifen auf die Datenbank und das Auffinden, Verarbeiten und Übertragen der Daten an den Client zeitaufwändig ist.</span><span class="sxs-lookup"><span data-stu-id="57abb-114">This is because accessing the database, locating and processing the data, and then transferring the data to the client is time-consuming.</span></span> <span data-ttu-id="57abb-115">Durch das Abrufen der gesamten Tabelle seitens des Clients werden außerdem alle ihre Zeilen auf dem Server gesperrt.</span><span class="sxs-lookup"><span data-stu-id="57abb-115">Pulling all of the table to the client also locks all of the rows on the server.</span></span> <span data-ttu-id="57abb-116">Zur Verbesserung der Leistung können Sie die `WHERE` -Klausel verwenden, um die Anzahl der an den Client zurückgegebenen Zeilen deutlich zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="57abb-116">To improve performance, you can use the `WHERE` clause to greatly reduce the number of rows returned to the client.</span></span> <span data-ttu-id="57abb-117">Die Anzahl der an den Client zurückgegebenen Daten kann auch verringert werden, indem Sie in der `SELECT` -Anweisung nur die erforderlichen Spalten explizit auflisten.</span><span class="sxs-lookup"><span data-stu-id="57abb-117">You can also reduce the amount of data returned to the client by only explicitly listing required columns in the `SELECT` statement.</span></span> <span data-ttu-id="57abb-118">Eine weitere gute Möglichkeit, dieses Problem zu umgehen, besteht darin, die Zeilen in Stapeln (z. B. immer einige hundert Zeilen auf einmal) abzurufen, wobei der nächste Stapel erst dann abgerufen wird, wenn der Client mit dem aktuellen Stapel fertig ist.</span><span class="sxs-lookup"><span data-stu-id="57abb-118">Another good workaround is to retrieve the rows in batches (such as several hundred rows at a time) and only retrieve the next batch when the client is finished with the current batch.</span></span>  
  
 <span data-ttu-id="57abb-119">Die `Fill` -Methode verwendet das `DataReader` -Objekt implizit, um die Spaltennamen und Spaltentypen zurückzugeben, mit denen die Tabellen im `DataSet`erstellt werden, sowie die Daten zum Füllen der Tabellenzeilen im `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="57abb-119">The `Fill` method uses the `DataReader` object implicitly to return the column names and types that are used to create the tables in the `DataSet`, and the data to populate the rows of the tables in the `DataSet`.</span></span> <span data-ttu-id="57abb-120">Tabellen und Spalten werden nur erstellt, wenn sie noch nicht vorhanden sind. Andernfalls verwendet die `Fill` -Methode das vorhandene `DataSet` -Schema.</span><span class="sxs-lookup"><span data-stu-id="57abb-120">Tables and columns are only created if they do not already exist; otherwise `Fill` uses the existing `DataSet` schema.</span></span> <span data-ttu-id="57abb-121">Spaltentypen werden als .NET Framework Typen gemäß den Tabellen in [Datentyp Zuordnungen in ADO.net](data-type-mappings-in-ado-net.md)erstellt.</span><span class="sxs-lookup"><span data-stu-id="57abb-121">Column types are created as .NET Framework types according to the tables in [Data Type Mappings in ADO.NET](data-type-mappings-in-ado-net.md).</span></span> <span data-ttu-id="57abb-122">Primärschlüssel werden nur erstellt, wenn Sie in der Datenquelle und vorhanden sind `DataAdapter` **.**`MissingSchemaAction`</span><span class="sxs-lookup"><span data-stu-id="57abb-122">Primary keys are not created unless they exist in the data source and `DataAdapter`**.**`MissingSchemaAction`</span></span> <span data-ttu-id="57abb-123">ist `MissingSchemaAction` **.** auf festgelegt. `AddWithKey`</span><span class="sxs-lookup"><span data-stu-id="57abb-123">is set to `MissingSchemaAction`**.**`AddWithKey`.</span></span> <span data-ttu-id="57abb-124">Wenn die `Fill` -Methode ermittelt, dass ein Primärschlüssel für eine Tabelle vorhanden ist, werden Daten im `DataSet` mit den Daten aus der Datenquelle überschrieben. Dies gilt für Zeilen, deren Werte in der Primärschlüsselspalte mit denen der Zeile übereinstimmen, die von der Datenquelle zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="57abb-124">If `Fill` finds that a primary key exists for a table, it will overwrite data in the `DataSet` with data from the data source for rows where the primary key column values match those of the row returned from the data source.</span></span> <span data-ttu-id="57abb-125">Wurde kein Primärschlüssel gefunden, so werden die Daten an die Tabellen im `DataSet`angehängt.</span><span class="sxs-lookup"><span data-stu-id="57abb-125">If no primary key is found, the data is appended to the tables in the `DataSet`.</span></span> <span data-ttu-id="57abb-126">`Fill` verwendet alle Zuordnungen, die ggf. vorhanden sind, wenn Sie das Auffüllen `DataSet` (siehe [DataAdapter-Datentabelle und datacolumschlag-](dataadapter-datatable-and-datacolumn-mappings.md)Zuordnungen).</span><span class="sxs-lookup"><span data-stu-id="57abb-126">`Fill` uses any mappings that may exist when you populate the `DataSet` (see [DataAdapter DataTable and DataColumn Mappings](dataadapter-datatable-and-datacolumn-mappings.md)).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="57abb-127">Wenn vom `SelectCommand` die Ergebnisse eines OUTER JOIN zurückgegeben werden, wird vom `DataAdapter` kein `PrimaryKey` -Wert für die resultierende `DataTable`festgelegt.</span><span class="sxs-lookup"><span data-stu-id="57abb-127">If the `SelectCommand` returns the results of an OUTER JOIN, the `DataAdapter` does not set a `PrimaryKey` value for the resulting `DataTable`.</span></span> <span data-ttu-id="57abb-128">Sie müssen den `PrimaryKey` selbst definieren, um sicherzustellen, dass doppelte Zeilen ordnungsgemäß aufgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="57abb-128">You must define the `PrimaryKey` yourself to make sure that duplicate rows are resolved correctly.</span></span> <span data-ttu-id="57abb-129">Weitere Informationen finden Sie unter [Definieren von primär Schlüsseln](./dataset-datatable-dataview/defining-primary-keys.md).</span><span class="sxs-lookup"><span data-stu-id="57abb-129">For more information, see [Defining Primary Keys](./dataset-datatable-dataview/defining-primary-keys.md).</span></span>  
  
 <span data-ttu-id="57abb-130">Im folgenden Codebeispiel wird eine Instanz eines <xref:System.Data.SqlClient.SqlDataAdapter> erstellt, die eine <xref:System.Data.SqlClient.SqlConnection> zur Microsoft SQL Server-Datenbank `Northwind` verwendet und eine <xref:System.Data.DataTable> in einem `DataSet` mit der Kundenliste füllt.</span><span class="sxs-lookup"><span data-stu-id="57abb-130">The following code example creates an instance of a <xref:System.Data.SqlClient.SqlDataAdapter> that uses a <xref:System.Data.SqlClient.SqlConnection> to the Microsoft SQL Server `Northwind` database and populates a <xref:System.Data.DataTable> in a `DataSet` with the list of customers.</span></span> <span data-ttu-id="57abb-131">Mit der SQL-Anweisung und den <xref:System.Data.SqlClient.SqlConnection> -Argumenten, die an den <xref:System.Data.SqlClient.SqlDataAdapter> -Konstruktor übergeben werden, wird die <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> -Eigenschaft des <xref:System.Data.SqlClient.SqlDataAdapter>erstellt.</span><span class="sxs-lookup"><span data-stu-id="57abb-131">The SQL statement and <xref:System.Data.SqlClient.SqlConnection> arguments passed to the <xref:System.Data.SqlClient.SqlDataAdapter> constructor are used to create the <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter>.</span></span>  
  
## <a name="example"></a><span data-ttu-id="57abb-132">Beispiel</span><span class="sxs-lookup"><span data-stu-id="57abb-132">Example</span></span>  
  
```vb  
' Assumes that connection is a valid SqlConnection object.  
Dim queryString As String = _  
  "SELECT CustomerID, CompanyName FROM dbo.Customers"  
Dim adapter As SqlDataAdapter = New SqlDataAdapter( _  
  queryString, connection)  
  
Dim customers As DataSet = New DataSet  
adapter.Fill(customers, "Customers")  
```  
  
```csharp  
// Assumes that connection is a valid SqlConnection object.  
string queryString =
  "SELECT CustomerID, CompanyName FROM dbo.Customers";  
SqlDataAdapter adapter = new SqlDataAdapter(queryString, connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
```  
  
> [!NOTE]
> <span data-ttu-id="57abb-133">Der in diesem Beispiel dargestellte Code öffnet und schließt die `Connection`nicht explizit.</span><span class="sxs-lookup"><span data-stu-id="57abb-133">The code shown in this example does not explicitly open and close the `Connection`.</span></span> <span data-ttu-id="57abb-134">Die `Fill` -Methode öffnet implizit die `Connection` , die vom `DataAdapter` verwendet wird, wenn die Verbindung nicht bereits geöffnet ist.</span><span class="sxs-lookup"><span data-stu-id="57abb-134">The `Fill` method implicitly opens the `Connection` that the `DataAdapter` is using if it finds that the connection is not already open.</span></span> <span data-ttu-id="57abb-135">Wenn die Verbindung durch `Fill` geöffnet wurde, wird sie nach dem `Fill` -Vorgang auch wieder geschlossen.</span><span class="sxs-lookup"><span data-stu-id="57abb-135">If `Fill` opened the connection, it also closes the connection when `Fill` is finished.</span></span> <span data-ttu-id="57abb-136">Bei einzelnen Vorgängen wie `Fill` oder `Update`kann der Code auf diese Weise vereinfacht werden.</span><span class="sxs-lookup"><span data-stu-id="57abb-136">This can simplify your code when you deal with a single operation such as a `Fill` or an `Update`.</span></span> <span data-ttu-id="57abb-137">Wenn Sie jedoch mehrere Vorgänge durchführen, für die eine geöffnete Verbindung erforderlich ist, können Sie die Leistung der Anwendung verbessern, indem Sie explizit die `Open` -Methode der `Connection`aufrufen, die Vorgänge für die Datenquelle durchführen und anschließend die `Close` -Methode der `Connection`aufrufen.</span><span class="sxs-lookup"><span data-stu-id="57abb-137">However, if you are performing multiple operations that require an open connection, you can improve the performance of your application by explicitly calling the `Open` method of the `Connection`, performing the operations against the data source, and then calling the `Close` method of the `Connection`.</span></span> <span data-ttu-id="57abb-138">Sie sollten die Verbindungen zur Datenquelle so kurz wie möglich geöffnet lassen, um die Ressourcen freizugeben, die von anderen Clientanwendungen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="57abb-138">You should try to keep connections to the data source open as briefly as possible to free resources for use by other client applications.</span></span>  
  
## <a name="multiple-result-sets"></a><span data-ttu-id="57abb-139">Mehrere Resultsets</span><span class="sxs-lookup"><span data-stu-id="57abb-139">Multiple Result Sets</span></span>  

 <span data-ttu-id="57abb-140">Wenn der `DataAdapter` mehrere Resultsets ermittelt, werden mehrere Tabellen im `DataSet`erstellt.</span><span class="sxs-lookup"><span data-stu-id="57abb-140">If the `DataAdapter` encounters multiple result sets, it creates multiple tables in the `DataSet`.</span></span> <span data-ttu-id="57abb-141">Diesen Tabellen werden standardmäßig Namen nach dem Schema Table*N*, beginnend mit "Table" für Table0, zugewiesen, die jeweils um eins erhöht werden.</span><span class="sxs-lookup"><span data-stu-id="57abb-141">The tables are given an incremental default name of Table*N*, starting with "Table" for Table0.</span></span> <span data-ttu-id="57abb-142">Wenn der Tabellenname als Argument an die `Fill` -Methode übergeben wird, erhalten die Tabellen standardmäßig Namen nach dem Schema TableName*N*, beginnend mit "TableName" für TableName0, die jeweils um eins erhöht werden.</span><span class="sxs-lookup"><span data-stu-id="57abb-142">If a table name is passed as an argument to the `Fill` method, the tables are given an incremental default name of TableName*N*, starting with "TableName" for TableName0.</span></span>  
  
## <a name="populating-a-dataset-from-multiple-dataadapters"></a><span data-ttu-id="57abb-143">Auffüllen eines DataSets mit mehreren DataAdapter-Objekten</span><span class="sxs-lookup"><span data-stu-id="57abb-143">Populating a DataSet from Multiple DataAdapters</span></span>  

 <span data-ttu-id="57abb-144">Eine beliebige Anzahl von- `DataAdapter` Objekten kann mit einem verwendet werden `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="57abb-144">Any number of `DataAdapter` objects can be used with a `DataSet`.</span></span> <span data-ttu-id="57abb-145">Mit jedem `DataAdapter` -Objekt können ein oder mehrere `DataTable` -Objekte gefüllt und Updates in die zugehörige Datenquelle übernommen werden.</span><span class="sxs-lookup"><span data-stu-id="57abb-145">Each `DataAdapter` can be used to fill one or more `DataTable` objects and resolve updates back to the relevant data source.</span></span> <span data-ttu-id="57abb-146">Das`DataRelation` -Objekt und das `Constraint` -Objekt können dem `DataSet` lokal hinzugefügt werden. Dadurch haben Sie die Möglichkeit, Daten aus mehreren unähnlichen Datenquellen zu verbinden.</span><span class="sxs-lookup"><span data-stu-id="57abb-146">`DataRelation` and `Constraint` objects can be added to the `DataSet` locally, which enables you to relate data from dissimilar data sources.</span></span> <span data-ttu-id="57abb-147">Ein `DataSet` kann beispielsweise Daten aus einer Microsoft SQL Server-Datenbank, einer über OLE DB verfügbar gemachten IBM DB2-Datenbank und einer XML-Datenquelle enthalten.</span><span class="sxs-lookup"><span data-stu-id="57abb-147">For example, a `DataSet` can contain data from a Microsoft SQL Server database, an IBM DB2 database exposed through OLE DB, and a data source that streams XML.</span></span> <span data-ttu-id="57abb-148">Für die Kommunikation mit den einzelnen Datenquellen sind ein oder mehrere `DataAdapter` -Objekte zuständig.</span><span class="sxs-lookup"><span data-stu-id="57abb-148">One or more `DataAdapter` objects can handle communication to each data source.</span></span>  
  
### <a name="example"></a><span data-ttu-id="57abb-149">Beispiel</span><span class="sxs-lookup"><span data-stu-id="57abb-149">Example</span></span>  

 <span data-ttu-id="57abb-150">Im folgenden Codebeispiel wird eine Kundenliste aus der `Northwind` -Datenbank unter Microsoft SQL Server sowie eine Auftragsliste aus der in Microsoft Access 2000 gespeicherten `Northwind` -Datenbank aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="57abb-150">The following code example populates a list of customers from the `Northwind` database on Microsoft SQL Server, and a list of orders from the `Northwind` database stored in Microsoft Access 2000.</span></span> <span data-ttu-id="57abb-151">Die gefüllten Tabellen werden mit einer `DataRelation`verbunden, und die Kundenliste wird anschließend mit Aufträgen für den jeweiligen Kunden angezeigt.</span><span class="sxs-lookup"><span data-stu-id="57abb-151">The filled tables are related with a `DataRelation`, and the list of customers is then displayed with the orders for that customer.</span></span> <span data-ttu-id="57abb-152">Weitere Informationen zu `DataRelation` Objekten finden Sie unter [Hinzufügen von DataRelations](./dataset-datatable-dataview/adding-datarelations.md) und [Navigieren in DataRelations](./dataset-datatable-dataview/navigating-datarelations.md).</span><span class="sxs-lookup"><span data-stu-id="57abb-152">For more information about `DataRelation` objects, see [Adding DataRelations](./dataset-datatable-dataview/adding-datarelations.md) and [Navigating DataRelations](./dataset-datatable-dataview/navigating-datarelations.md).</span></span>  
  
```vb  
' Assumes that customerConnection is a valid SqlConnection object.  
' Assumes that orderConnection is a valid OleDbConnection object.  
Dim custAdapter As SqlDataAdapter = New SqlDataAdapter( _  
  "SELECT * FROM dbo.Customers", customerConnection)  
  
Dim ordAdapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SELECT * FROM Orders", orderConnection)  
  
Dim customerOrders As DataSet = New DataSet()  
custAdapter.Fill(customerOrders, "Customers")  
ordAdapter.Fill(customerOrders, "Orders")  
  
Dim relation As DataRelation = _  
  customerOrders.Relations.Add("CustOrders", _  
  customerOrders.Tables("Customers").Columns("CustomerID"), _
  customerOrders.Tables("Orders").Columns("CustomerID"))  
  
Dim pRow, cRow As DataRow  
For Each pRow In customerOrders.Tables("Customers").Rows  
  Console.WriteLine(pRow("CustomerID").ToString())  
  
  For Each cRow In pRow.GetChildRows(relation)  
    Console.WriteLine(vbTab & cRow("OrderID").ToString())  
  Next  
Next  
```  
  
```csharp  
// Assumes that customerConnection is a valid SqlConnection object.  
// Assumes that orderConnection is a valid OleDbConnection object.  
SqlDataAdapter custAdapter = new SqlDataAdapter(  
  "SELECT * FROM dbo.Customers", customerConnection);  
OleDbDataAdapter ordAdapter = new OleDbDataAdapter(  
  "SELECT * FROM Orders", orderConnection);  
  
DataSet customerOrders = new DataSet();  
  
custAdapter.Fill(customerOrders, "Customers");  
ordAdapter.Fill(customerOrders, "Orders");  
  
DataRelation relation = customerOrders.Relations.Add("CustOrders",  
  customerOrders.Tables["Customers"].Columns["CustomerID"],  
  customerOrders.Tables["Orders"].Columns["CustomerID"]);  
  
foreach (DataRow pRow in customerOrders.Tables["Customers"].Rows)  
{  
  Console.WriteLine(pRow["CustomerID"]);  
   foreach (DataRow cRow in pRow.GetChildRows(relation))  
    Console.WriteLine("\t" + cRow["OrderID"]);  
}  
```  
  
## <a name="sql-server-decimal-type"></a><span data-ttu-id="57abb-153">SQL Server-Typ "decimal"</span><span class="sxs-lookup"><span data-stu-id="57abb-153">SQL Server Decimal Type</span></span>  

 <span data-ttu-id="57abb-154">Standardmäßig speichert die `DataSet` Daten mithilfe .NET Framework-Datentypen.</span><span class="sxs-lookup"><span data-stu-id="57abb-154">By default, the `DataSet` stores data by using .NET Framework data types.</span></span> <span data-ttu-id="57abb-155">Für die meisten Anwendungen sind diese sehr gut zur Darstellung der Informationen aus der Datenquelle geeignet.</span><span class="sxs-lookup"><span data-stu-id="57abb-155">For most applications, these provide a convenient representation of data source information.</span></span> <span data-ttu-id="57abb-156">Diese Darstellung kann jedoch problematisch werden, wenn es sich bei dem Datentyp in der Datenquelle um den SQL Server-Datentyp „decimal“ oder um einen numerischen Datentyp handelt.</span><span class="sxs-lookup"><span data-stu-id="57abb-156">However, this representation may cause a problem when the data type in the data source is a SQL Server decimal or numeric data type.</span></span> <span data-ttu-id="57abb-157">Der .NET Framework- `decimal` Datentyp lässt maximal 28 signifikante Ziffern zu, während der SQL Server- `decimal` Datentyp 38 signifikante Ziffern zulässt.</span><span class="sxs-lookup"><span data-stu-id="57abb-157">The .NET Framework `decimal` data type allows a maximum of 28 significant digits, whereas the SQL Server `decimal` data type allows 38 significant digits.</span></span> <span data-ttu-id="57abb-158">Wenn der `SqlDataAdapter` während eines `Fill` -Vorgangs feststellt, dass die Präzision eines SQL Server-Felds mit dem Datentyp `decimal` mehr als 28 Zeichen beträgt, wird der `DataTable`die aktuelle Zeile nicht hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="57abb-158">If the `SqlDataAdapter` determines during a `Fill` operation that the precision of a SQL Server `decimal` field is larger than 28 characters, the current row is not added to the `DataTable`.</span></span> <span data-ttu-id="57abb-159">Stattdessen tritt das `FillError` -Ereignis auf. Dadurch können Sie überprüfen, ob ein Präzisionsverlust eintritt, und Sie können entsprechend reagieren.</span><span class="sxs-lookup"><span data-stu-id="57abb-159">Instead the `FillError` event occurs, which enables you to determine whether a loss of precision will occur, and respond appropriately.</span></span> <span data-ttu-id="57abb-160">Weitere Informationen zum- `FillError` Ereignis finden Sie unter [Handling DataAdapter-Ereignisse](handling-dataadapter-events.md).</span><span class="sxs-lookup"><span data-stu-id="57abb-160">For more information about the `FillError` event, see [Handling DataAdapter Events](handling-dataadapter-events.md).</span></span> <span data-ttu-id="57abb-161">Den SQL Server-Wert `decimal` erhalten Sie auch, indem Sie ein <xref:System.Data.SqlClient.SqlDataReader> -Objekt verwenden und die <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> -Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="57abb-161">To get the SQL Server `decimal` value, you can also use a <xref:System.Data.SqlClient.SqlDataReader> object and call the <xref:System.Data.SqlClient.SqlDataReader.GetSqlDecimal%2A> method.</span></span>  
  
 <span data-ttu-id="57abb-162">ADO.NET 2,0 hat eine verbesserte Unterstützung für <xref:System.Data.SqlTypes> in eingeführt `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="57abb-162">ADO.NET 2.0 introduced enhanced support for <xref:System.Data.SqlTypes> in the `DataSet`.</span></span> <span data-ttu-id="57abb-163">Weitere Informationen finden Sie unter [SqlTypes and the DataSet](./sql/sqltypes-and-the-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="57abb-163">For more information, see [SqlTypes and the DataSet](./sql/sqltypes-and-the-dataset.md).</span></span>  
  
## <a name="ole-db-chapters"></a><span data-ttu-id="57abb-164">OLE DB-Kapitel</span><span class="sxs-lookup"><span data-stu-id="57abb-164">OLE DB Chapters</span></span>  

 <span data-ttu-id="57abb-165">Hierarchische Rowsets oder Kapitel (OLE DB-Typ `DBTYPE_HCHAPTER`, ADO-Typ `adChapter`) können zum Füllen des `DataSet`-Inhalts verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="57abb-165">Hierarchical rowsets, or chapters (OLE DB type `DBTYPE_HCHAPTER`, ADO type `adChapter`) can be used to fill the contents of a `DataSet`.</span></span> <span data-ttu-id="57abb-166">Wenn das <xref:System.Data.OleDb.OleDbDataAdapter> -Objekt während eines `Fill` -Vorgangs eine in Kapitel unterteilte Spalte ermittelt, wird für diese Spalte eine `DataTable` erstellt, die mit den Spalten und Zeilen aus dem Kapitel gefüllt wird.</span><span class="sxs-lookup"><span data-stu-id="57abb-166">When the <xref:System.Data.OleDb.OleDbDataAdapter> encounters a chaptered column during a `Fill` operation, a `DataTable` is created for the chaptered column, and that table is filled with the columns and rows from the chapter.</span></span> <span data-ttu-id="57abb-167">Als Name der Tabelle, die für die in Kapitel unterteilte Spalte erstellt wird, werden der Name der übergeordneten Tabelle und der Name der in Kapitel unterteilten Spalte im folgenden Format verwendet: "*ParentTableNameChapteredColumnName*".</span><span class="sxs-lookup"><span data-stu-id="57abb-167">The table created for the chaptered column is named by using both the parent table name and the chaptered column name in the form "*ParentTableNameChapteredColumnName*".</span></span> <span data-ttu-id="57abb-168">Wenn im `DataSet` bereits eine Tabelle vorhanden ist, deren Name dem Namen der in Kapitel unterteilten Spalte entspricht, wird die aktuelle Tabelle mit den Kapiteldaten gefüllt.</span><span class="sxs-lookup"><span data-stu-id="57abb-168">If a table already exists in the `DataSet` that matches the name of the chaptered column, the current table is filled with the chapter data.</span></span> <span data-ttu-id="57abb-169">Wenn in einer vorhandenen Tabelle keine Spalte existiert, die einer Spalte im Kapitel entspricht, wird eine neue Spalte hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="57abb-169">If there is no column in an existing table that matches a column found in the chapter, a new column is added.</span></span>  
  
 <span data-ttu-id="57abb-170">Bevor die Tabellen im `DataSet` mit den Daten in den in Kapitel unterteilten Spalten gefüllt werden, wird eine Beziehung zwischen der übergeordneten und der untergeordneten Tabelle des hierarchischen Rowsets erstellt, indem sowohl der übergeordneten als auch der untergeordneten Tabelle eine Ganzzahlenspalte hinzugefügt wird. Für die übergeordnete Spalte wird die automatische Erhöhung festgelegt, und mit den hinzugefügten Spalten beider Tabellen wird eine `DataRelation` erstellt.</span><span class="sxs-lookup"><span data-stu-id="57abb-170">Before the tables in the `DataSet` are filled with the data in the chaptered columns, a relation is created between the parent and child tables of the hierarchical rowset by adding an integer column to both the parent and child table, setting the parent column to auto-increment, and creating a `DataRelation` using the added columns from both tables.</span></span> <span data-ttu-id="57abb-171">Die hinzugefügte Beziehung wird unter Verwendung des Namens der übergeordneten Tabelle und des Namens der Kapitelspalte folgendermaßen benannt: "*ParentTableNameChapterColumnName*".</span><span class="sxs-lookup"><span data-stu-id="57abb-171">The added relation is named by using the parent table and chapter column names in the form "*ParentTableNameChapterColumnName*".</span></span>  
  
 <span data-ttu-id="57abb-172">Beachten Sie, dass die entsprechende Spalte nur im `DataSet`vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="57abb-172">Note that the related column only exists in the `DataSet`.</span></span> <span data-ttu-id="57abb-173">Bei nachfolgenden Füllungen aus der Datenquelle werden den Tabellen möglicherweise neue Zeilen hinzugefügt, anstatt die Änderungen in vorhandene Zeilen zusammenzuführen.</span><span class="sxs-lookup"><span data-stu-id="57abb-173">Subsequent fills from the data source can cause new rows to be added to the tables instead of changes being merged into existing rows.</span></span>  
  
 <span data-ttu-id="57abb-174">Beachten Sie auch, dass bei Verwendung der `DataAdapter.Fill` -Überladung mit einer `DataTable`nur diese Tabelle gefüllt wird.</span><span class="sxs-lookup"><span data-stu-id="57abb-174">Note also that, if you use the `DataAdapter.Fill` overload that takes a `DataTable`, only that table will be filled.</span></span> <span data-ttu-id="57abb-175">Eine Ganzzahlenspalte mit automatischer Erhöhung wird der Tabelle ebenfalls hinzugefügt, es wird jedoch keine untergeordnete Tabelle erstellt oder gefüllt und keine Beziehung erstellt.</span><span class="sxs-lookup"><span data-stu-id="57abb-175">An auto-incrementing integer column will still be added to the table, but no child table will be created or filled, and no relation will be created.</span></span>  
  
 <span data-ttu-id="57abb-176">Im folgenden Beispiel wird mit dem MSDataShape-Anbieter eine Kapitelspalte von Bestellungen für jeden Kunden aus einer Kundenliste generiert.</span><span class="sxs-lookup"><span data-stu-id="57abb-176">The following example uses the MSDataShape Provider to generate a chapter column of orders for each customer in a list of customers.</span></span> <span data-ttu-id="57abb-177">Anschließend wird ein `DataSet` mit den Daten gefüllt.</span><span class="sxs-lookup"><span data-stu-id="57abb-177">A `DataSet` is then filled with the data.</span></span>  
  
```vb  
Using connection As OleDbConnection = New OleDbConnection( _  
  "Provider=MSDataShape;Data Provider=SQLOLEDB;" & _  
  "Data Source=(local);Integrated " & _  
  "Security=SSPI;Initial Catalog=northwind")  
  
Dim adapter As OleDbDataAdapter = New OleDbDataAdapter( _  
  "SHAPE {SELECT CustomerID, CompanyName FROM Customers} " & _  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " & _  
  "RELATE CustomerID TO CustomerID)", connection)  
  
Dim customers As DataSet = New DataSet()  
  
adapter.Fill(customers, "Customers")  
End Using  
```  
  
```csharp  
using (OleDbConnection connection = new OleDbConnection("Provider=MSDataShape;Data Provider=SQLOLEDB;" +  
  "Data Source=(local);Integrated Security=SSPI;Initial Catalog=northwind"))  
{  
OleDbDataAdapter adapter = new OleDbDataAdapter("SHAPE {SELECT CustomerID, CompanyName FROM Customers} " +  
  "APPEND ({SELECT CustomerID, OrderID FROM Orders} AS Orders " +  
  "RELATE CustomerID TO CustomerID)", connection);  
  
DataSet customers = new DataSet();  
adapter.Fill(customers, "Customers");  
}  
```  
  
 <span data-ttu-id="57abb-178">Nach Abschluss des `Fill` -Vorgangs enthält das `DataSet` zwei Tabellen: `Customers` und `CustomersOrders`, wobei `CustomersOrders` die in Kapitel unterteilte Spalte darstellt.</span><span class="sxs-lookup"><span data-stu-id="57abb-178">When the `Fill` operation is complete, the `DataSet` contains two tables: `Customers` and `CustomersOrders`, where `CustomersOrders` represents the chaptered column.</span></span> <span data-ttu-id="57abb-179">Eine weitere Spalte mit dem Namen `Orders` wird der Tabelle `Customers` hinzugefügt. Der Tabelle `CustomersOrders` wird eine zusätzliche Spalte mit dem Namen `CustomersOrders` hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="57abb-179">An additional column named `Orders` is added to the `Customers` table, and an additional column named `CustomersOrders` is added to the `CustomersOrders` table.</span></span> <span data-ttu-id="57abb-180">Die Spalte `Orders` in der Tabelle `Customers` wird auf die automatische Erhöhung festgelegt.</span><span class="sxs-lookup"><span data-stu-id="57abb-180">The `Orders` column in the `Customers` table is set to auto-increment.</span></span> <span data-ttu-id="57abb-181">Eine `DataRelation`, nämlich `CustomersOrders`, wird mithilfe der Spalten erstellt, die den Tabellen mit `Customers` als übergeordnete Tabelle hinzugefügt wurden.</span><span class="sxs-lookup"><span data-stu-id="57abb-181">A `DataRelation`, `CustomersOrders`, is created by using the columns that were added to the tables with `Customers` as the parent table.</span></span> <span data-ttu-id="57abb-182">In den folgenden Tabellen sind einige Beispiele dargestellt.</span><span class="sxs-lookup"><span data-stu-id="57abb-182">The following tables show some sample results.</span></span>  
  
### <a name="tablename-customers"></a><span data-ttu-id="57abb-183">TableName: Customers</span><span class="sxs-lookup"><span data-stu-id="57abb-183">TableName: Customers</span></span>  
  
|<span data-ttu-id="57abb-184">CustomerID</span><span class="sxs-lookup"><span data-stu-id="57abb-184">CustomerID</span></span>|<span data-ttu-id="57abb-185">CompanyName</span><span class="sxs-lookup"><span data-stu-id="57abb-185">CompanyName</span></span>|<span data-ttu-id="57abb-186">Orders</span><span class="sxs-lookup"><span data-stu-id="57abb-186">Orders</span></span>|  
|----------------|-----------------|------------|  
|<span data-ttu-id="57abb-187">ALFKI</span><span class="sxs-lookup"><span data-stu-id="57abb-187">ALFKI</span></span>|<span data-ttu-id="57abb-188">Alfreds Futterkiste</span><span class="sxs-lookup"><span data-stu-id="57abb-188">Alfreds Futterkiste</span></span>|<span data-ttu-id="57abb-189">0</span><span class="sxs-lookup"><span data-stu-id="57abb-189">0</span></span>|  
|<span data-ttu-id="57abb-190">ANATR</span><span class="sxs-lookup"><span data-stu-id="57abb-190">ANATR</span></span>|<span data-ttu-id="57abb-191">Ana Trujillo Emparedados y helados</span><span class="sxs-lookup"><span data-stu-id="57abb-191">Ana Trujillo Emparedados y helados</span></span>|<span data-ttu-id="57abb-192">1</span><span class="sxs-lookup"><span data-stu-id="57abb-192">1</span></span>|  
  
### <a name="tablename-customersorders"></a><span data-ttu-id="57abb-193">TableName: CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="57abb-193">TableName: CustomersOrders</span></span>  
  
|<span data-ttu-id="57abb-194">CustomerID</span><span class="sxs-lookup"><span data-stu-id="57abb-194">CustomerID</span></span>|<span data-ttu-id="57abb-195">OrderID</span><span class="sxs-lookup"><span data-stu-id="57abb-195">OrderID</span></span>|<span data-ttu-id="57abb-196">CustomersOrders</span><span class="sxs-lookup"><span data-stu-id="57abb-196">CustomersOrders</span></span>|  
|----------------|-------------|---------------------|  
|<span data-ttu-id="57abb-197">ALFKI</span><span class="sxs-lookup"><span data-stu-id="57abb-197">ALFKI</span></span>|<span data-ttu-id="57abb-198">10643</span><span class="sxs-lookup"><span data-stu-id="57abb-198">10643</span></span>|<span data-ttu-id="57abb-199">0</span><span class="sxs-lookup"><span data-stu-id="57abb-199">0</span></span>|  
|<span data-ttu-id="57abb-200">ALFKI</span><span class="sxs-lookup"><span data-stu-id="57abb-200">ALFKI</span></span>|<span data-ttu-id="57abb-201">10692</span><span class="sxs-lookup"><span data-stu-id="57abb-201">10692</span></span>|<span data-ttu-id="57abb-202">0</span><span class="sxs-lookup"><span data-stu-id="57abb-202">0</span></span>|  
|<span data-ttu-id="57abb-203">ANATR</span><span class="sxs-lookup"><span data-stu-id="57abb-203">ANATR</span></span>|<span data-ttu-id="57abb-204">10308</span><span class="sxs-lookup"><span data-stu-id="57abb-204">10308</span></span>|<span data-ttu-id="57abb-205">1</span><span class="sxs-lookup"><span data-stu-id="57abb-205">1</span></span>|  
|<span data-ttu-id="57abb-206">ANATR</span><span class="sxs-lookup"><span data-stu-id="57abb-206">ANATR</span></span>|<span data-ttu-id="57abb-207">10625</span><span class="sxs-lookup"><span data-stu-id="57abb-207">10625</span></span>|<span data-ttu-id="57abb-208">1</span><span class="sxs-lookup"><span data-stu-id="57abb-208">1</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="57abb-209">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="57abb-209">See also</span></span>

- [<span data-ttu-id="57abb-210">"DataAdapters" und "DataReaders"</span><span class="sxs-lookup"><span data-stu-id="57abb-210">DataAdapters and DataReaders</span></span>](dataadapters-and-datareaders.md)
- [<span data-ttu-id="57abb-211">Datentypzuordnungen in ADO.NET</span><span class="sxs-lookup"><span data-stu-id="57abb-211">Data Type Mappings in ADO.NET</span></span>](data-type-mappings-in-ado-net.md)
- [<span data-ttu-id="57abb-212">Ändern von Daten mit "DbDataAdapter"</span><span class="sxs-lookup"><span data-stu-id="57abb-212">Modifying Data with a DbDataAdapter</span></span>](modifying-data-with-a-dbdataadapter.md)
- [<span data-ttu-id="57abb-213">Mehrere aktive Resultsets (MARS)</span><span class="sxs-lookup"><span data-stu-id="57abb-213">Multiple Active Result Sets (MARS)</span></span>](./sql/multiple-active-result-sets-mars.md)
- [<span data-ttu-id="57abb-214">Übersicht über ADO.NET</span><span class="sxs-lookup"><span data-stu-id="57abb-214">ADO.NET Overview</span></span>](ado-net-overview.md)
