---
title: Verwalten des Datendienstkontextes (WCF Data Services)
ms.date: 03/30/2017
ms.assetid: 15b19d09-7de7-4638-9556-6ef396cc45ec
ms.openlocfilehash: e67f7280bc85c7577f960707659890f59470e535
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/24/2020
ms.locfileid: "91194296"
---
# <a name="managing-the-data-service-context-wcf-data-services"></a>Verwalten des Datendienstkontextes (WCF Data Services)

Die <xref:System.Data.Services.Client.DataServiceContext>-Klasse kapselt Vorgänge, die für einen angegebenen Datendienst unterstützt werden. Obwohl odata-Dienste zustandslos sind, ist der Kontext nicht. Daher können Sie die- <xref:System.Data.Services.Client.DataServiceContext> Klasse verwenden, um den Zustand auf dem Client zwischen Interaktionen mit dem Datendienst aufrechtzuerhalten, um Funktionen wie z. b. Change Management zu unterstützen. Von dieser Klasse werden auch Identitäten verwaltet und Änderungen nachverfolgt.  
  
## <a name="merge-options-and-identity-resolution"></a>Zusammenführungsoptionen und Identitätsauflösung  

 Wenn eine <xref:System.Data.Services.Client.DataServiceQuery%601> ausgeführt wird, werden die Entitäten im Antwortfeed in Objekte materialisiert. Weitere Informationen finden Sie unter [Objektmaterialisierung](object-materialization-wcf-data-services.md). Die Methode, mit der Einträge in einer Antwortnachricht in Objekte materialisiert werden, ist von der Identitätsauflösung und von der Mergeoption abhängig, mit der die Abfrage ausgeführt wurde. Wenn mehrere Abfragen oder Ladeanforderungen im Bereich eines einzelnen ausgeführt werden <xref:System.Data.Services.Client.DataServiceContext> , verfolgt der WCF Data Services Client nur eine einzelne Instanz eines Objekts, das über einen bestimmten Schlüsselwert verfügt. Dieser Schlüssel, der für das Ausführen einer Identitätsauflösung verwendet wird, identifiziert eine Entität eindeutig.  
  
 In der Standardeinstellung wird vom Client nur ein Eintrag im Antwortfeed in ein Objekt für Entitäten materialisiert, die noch nicht vom <xref:System.Data.Services.Client.DataServiceContext> verfolgt werden. Dies bedeutet, dass Änderungen an Objekten, die sich bereits im Cache befinden, nicht überschrieben werden. Dieses Verhalten wird gesteuert, indem für Abfragen und Ladevorgänge ein <xref:System.Data.Services.Client.MergeOption>-Wert angegeben wird. Diese Option wird festgelegt, indem die <xref:System.Data.Services.Client.DataServiceContext.MergeOption%2A>-Eigenschaft auf dem <xref:System.Data.Services.Client.DataServiceContext> festgelegt wird. Der Standardwert der Zusammenführungsoption lautet <xref:System.Data.Services.Client.MergeOption.AppendOnly>. Mit dieser Einstellung werden nur Objekte für Entitäten materialisiert, die noch nicht verfolgt werden, d. h. vorhandene Objekte werden nicht überschrieben. Um zu verhindern, dass Änderungen an Objekten auf dem Client durch Aktualisierungen des Datendiensts überschrieben werden, kann auch die Option <xref:System.Data.Services.Client.MergeOption.PreserveChanges> festgelegt werden. Wenn <xref:System.Data.Services.Client.MergeOption.OverwriteChanges> festgelegt wird, werden Werte von Objekten des Clients durch die aktuellen Werte aus Einträgen im Antwortfeed ersetzt. Dies gilt auch, wenn an diesen Objekten bereits Änderungen vorgenommen wurden. Wenn eine <xref:System.Data.Services.Client.MergeOption.NoTracking>-Zusammenführungsoption verwendet wird, kann der <xref:System.Data.Services.Client.DataServiceContext> keine Änderungen, die an Clientobjekten gemacht wurden, an den Datendienst senden. Mit dieser Option werden Änderungen immer durch Werte des Datendiensts überschrieben.  
  
## <a name="managing-concurrency"></a>Verwalten von Nebenläufigkeit  

 Odata unterstützt optimistische Parallelität, die es dem Datendienst ermöglicht, Update Konflikte zu erkennen. Der Datendienstanbieter kann so konfiguriert werden, dass der Datendienst mithilfe eines Parallelitätstokens nach Änderungen an Entitäten sucht. Dieses Token beinhaltet mindestens eine Eigenschaft eines Entitätstyps, die vom Datendienst überprüft wird, um zu bestimmen, ob sich eine Ressource geändert hat. Parallelitäts Token, die im ETag-Header von Anforderungen an und Antworten vom Datendienst enthalten sind, werden vom WCF Data Services Client für Sie verwaltet. Weitere Informationen finden Sie unter [Aktualisieren des Daten Dienstanbieter](updating-the-data-service-wcf-data-services.md).  
  
 Der <xref:System.Data.Services.Client.DataServiceContext> verfolgt Änderungen, die an Objekten vorgenommen wurden, die manuell mit <xref:System.Data.Services.Client.DataServiceContext.AddObject%2A>, <xref:System.Data.Services.Client.DataServiceContext.UpdateObject%2A> und <xref:System.Data.Services.Client.DataServiceContext.DeleteObject%2A> oder von einer <xref:System.Data.Services.Client.DataServiceCollection%601> gemeldet wurden. Wenn die <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A>-Methode aufgerufen wird, sendet der Client die Änderungen zurück an den Datendienst. <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A> kann fehlschlagen, wenn zwischen den Datenänderungen auf dem Client und den Änderungen im Datendienst ein Konflikt auftritt. In einem solchen Fall müssen Sie die Entitätsressource erneut abfragen, um die Updatedaten zu erhalten. Um Änderungen im Datendienst zu überschreiben, führen Sie die Abfrage mit der <xref:System.Data.Services.Client.MergeOption.PreserveChanges>-Zusammenführungsoption aus. Wenn Sie <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A> erneut aufrufen, werden die auf dem Client beibehaltenen Änderungen im Datendienst beibehalten, sofern an der Ressource im Datendienst noch keine anderen Änderungen vorgenommen wurden.  
  
## <a name="saving-changes"></a>Speichern von Änderungen  

 Änderungen werden in der <xref:System.Data.Services.Client.DataServiceContext>-Instanz nachverfolgt, jedoch nicht unmittelbar an den Server gesendet. Wenn Sie die erforderlichen Änderungen für eine bestimmte Aktivität vorgenommen haben, rufen Sie <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A> auf, um alle Änderungen an den Datendienst zu übergeben. Ein <xref:System.Data.Services.Client.DataServiceResponse>-Objekt wird zurückgegeben, nachdem der <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A>-Vorgang abgeschlossen wurde. Das <xref:System.Data.Services.Client.DataServiceResponse>-Objekt enthält eine Folge von <xref:System.Data.Services.Client.OperationResponse>-Objekten, die wiederum eine Folge von <xref:System.Data.Services.Client.EntityDescriptor>-Instanzen oder <xref:System.Data.Services.Client.LinkDescriptor>-Instanzen enthalten, die die beibehaltenen Änderungen oder Änderungsversuche darstellen. Wenn eine Entität im Datendienst erstellt oder geändert wird, schließt der <xref:System.Data.Services.Client.EntityDescriptor> einen Verweis auf die aktualisierte Entität ein, der alle vom Server generierten Eigenschaftswerte enthält, z. B. den generierten `ProductID`-Wert im vorherigen Beispiel. Das .NET Framework-Objekt wird von der Clientbibliothek automatisch mit diesen neuen Werten aktualisiert.  
  
 Bei erfolgreichen Einfüge- und Aktualisierungsvorgängen wird die Zustandseigenschaft des <xref:System.Data.Services.Client.EntityDescriptor>- oder <xref:System.Data.Services.Client.LinkDescriptor>-Objekts, das dem Vorgang zugeordnet ist, auf <xref:System.Data.Services.Client.EntityStates.Unchanged> festgelegt, und die neuen Werte werden mithilfe von <xref:System.Data.Services.Client.MergeOption.OverwriteChanges> zusammengeführt. Wenn im Datendienst ein Einfüge-, Aktualisierungs- oder Löschvorgang fehlschlägt, entspricht der Entitätszustand weiterhin dem Zustand vor dem Aufrufen von <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A>, und die <xref:System.Data.Services.Client.OperationResponse.Error%2A>-Eigenschaft der <xref:System.Data.Services.Client.OperationResponse> wird auf eine <xref:System.Data.Services.Client.DataServiceRequestException> festgelegt, die Informationen zum Fehler enthält. Weitere Informationen finden Sie unter [Aktualisieren des Daten Dienstanbieter](updating-the-data-service-wcf-data-services.md).  
  
### <a name="setting-the-http-method-for-updates"></a>Festlegen der HTTP-Methode für Updates  

 Die .NET Framework-Clientbibliothek sendet Updates an vorhandenen Entitäten standardmäßig als MERGE-Anforderungen. Durch eine MERGE-Anforderung werden ausgewählte Eigenschaften der Entität aktualisiert. Der Client schließt jedoch immer alle Eigenschaften in die MERGE-Anforderung ein, auch Eigenschaften, die nicht geändert wurden. Das odata-Protokoll unterstützt auch das Senden von Put-Anforderungen an Update Entitäten. In einer PUT-Anforderung wird eine vorhandene Entität im Grunde durch eine neue Instanz der Entität mit Eigenschaftswerten vom Client ersetzt. Legen Sie zum Verwenden von PUT-Anforderungen das <xref:System.Data.Services.Client.SaveChangesOptions.ReplaceOnUpdate>-Flag für die <xref:System.Data.Services.Client.SaveChangesOptions>-Enumeration fest, wenn Sie <xref:System.Data.Services.Client.DataServiceContext.SaveChanges%2A> aufrufen.  
  
> [!NOTE]
> Eine PUT-Anforderung verhält sich anders als eine MERGE-Anforderung, wenn der Client nicht alle Eigenschaften der Entität kennt. Dies kann vorkommen, wenn ein Entitätstyp in einen neuen Typ auf dem Client projiziert wird. Diese Situation kann auch auftreten, wenn der Entität im Datenmodell des Diensts neue Eigenschaften hinzugefügt wurden und die <xref:System.Data.Services.Client.DataServiceContext.IgnoreMissingProperties%2A>-Eigenschaft des <xref:System.Data.Services.Client.DataServiceContext> auf `true` festgelegt ist, um solche Clientzuordnungsfehler zu ignorieren. In diesen Fällen werden bei einer PUT-Anforderung alle Eigenschaften, die dem Client nicht bekannt sind, auf die Standardwerte zurückgesetzt.  
  
### <a name="post-tunneling"></a>POST-Tunneln  

 Standardmäßig sendet die Client Bibliothek Erstellungs-, Lese-, Aktualisierungs-und Lösch Anforderungen an einen odata-Dienst, indem die entsprechenden HTTP-Methoden "Post", "Get", "Put/Merge/Patch" und "Delete" verwendet werden. Auf diese Weise werden die grundlegenden REST-Prinzipien (Representational State Transfer) aufrechterhalten. Nicht jede Webserverimplementierung unterstützt jedoch den vollständigen Satz von HTTP-Methoden. In einigen Fällen könnten die unterstützten Methoden nur auf GET und POST beschränkt sein. Dies kann geschehen, wenn ein Vermittler, z. B. eine Firewall, Anforderungen mit bestimmten Methoden blockiert. Da die Get-Methode und die Post-Methode am häufigsten unterstützt werden, schreibt odata eine Methode zum Ausführen von nicht unterstützten HTTP-Methoden mithilfe einer POST-Anforderung vor. Dies wird als *Methoden Tunnelung* oder *posttunnelung*bezeichnet und ermöglicht es einem Client, eine Post-Anforderung mit der eigentlichen Methode zu senden, die im benutzerdefinierten Header angegeben ist `X-HTTP-Method` . Um POST-Tunneln für Anforderungen zu ermöglichen, legen Sie die <xref:System.Data.Services.Client.DataServiceContext.UsePostTunneling%2A>-Eigenschaft der <xref:System.Data.Services.Client.DataServiceContext>-Instanz auf `true` fest.  
  
## <a name="see-also"></a>Weitere Informationen

- [WCF Data Services-Clientbibliothek](wcf-data-services-client-library.md)
- [Aktualisieren des Datendiensts](updating-the-data-service-wcf-data-services.md)
- [Asynchrone Vorgänge](asynchronous-operations-wcf-data-services.md)
- [Batchvorgänge](batching-operations-wcf-data-services.md)
