---
title: Ausführliche Erläuterung der XAML-Syntax
description: Erfahren Sie mehr über Begriffe, die verwendet werden, um die Elemente der XAML-Syntax für Windows Presentation Foundation und andere Frameworks zu beschreiben, die XAML verwenden.
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 6ef217a646b14f02c0b812f6316ec84f26d4b660
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/24/2020
ms.locfileid: "87168350"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="569b7-103">Ausführliche Erläuterung der XAML-Syntax</span><span class="sxs-lookup"><span data-stu-id="569b7-103">XAML Syntax In Detail</span></span>
<span data-ttu-id="569b7-104">In diesem Thema werden die Begriffe definiert, die verwendet werden, um die Elemente der XAML-Syntax zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="569b7-104">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="569b7-105">Diese Begriffe werden im restlichen Teil dieser Dokumentation häufig verwendet, sowohl für die WPF-Dokumentation als auch für die anderen Frameworks, die XAML oder die grundlegenden XAML-Konzepte verwenden, die von der XAML-Sprachunterstützung auf der System. XAML-Ebene aktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-105">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="569b7-106">Dieses Thema erweitert die grundlegende Terminologie, die im Thema [Übersicht über XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md)vorgestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="569b7-106">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a><span data-ttu-id="569b7-107">Die XAML-Sprachspezifikation</span><span class="sxs-lookup"><span data-stu-id="569b7-107">The XAML Language Specification</span></span>  
 <span data-ttu-id="569b7-108">Die hier definierte XAML-Syntax Terminologie ist auch definiert oder wird innerhalb der XAML-Sprachspezifikation referenziert.</span><span class="sxs-lookup"><span data-stu-id="569b7-108">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="569b7-109">XAML ist eine Sprache, die auf XML basiert und auf XML-Struktur Regeln folgt oder Sie erweitert.</span><span class="sxs-lookup"><span data-stu-id="569b7-109">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="569b7-110">Einige der Begriffe werden von freigegeben oder basieren auf der Terminologie, die häufig verwendet wird, wenn die XML-Sprache oder das XML-Dokument Objektmodell beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-110">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="569b7-111">Weitere Informationen zur XAML-Sprachspezifikation finden Sie unter Herunterladen von [ \[ MS- \] XAML](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) aus dem Microsoft Download Center.</span><span class="sxs-lookup"><span data-stu-id="569b7-111">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a><span data-ttu-id="569b7-112">XAML und CLR</span><span class="sxs-lookup"><span data-stu-id="569b7-112">XAML and CLR</span></span>  
 <span data-ttu-id="569b7-113">XAML ist eine Markup Sprache.</span><span class="sxs-lookup"><span data-stu-id="569b7-113">XAML is a markup language.</span></span> <span data-ttu-id="569b7-114">Der Common Language Runtime (CLR), wie er durch seinen Namen impliziert, ermöglicht die Lauf Zeit Ausführung.</span><span class="sxs-lookup"><span data-stu-id="569b7-114">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="569b7-115">Bei XAML handelt es sich nicht um eine der allgemeinen Sprachen, die von der CLR-Laufzeit direkt genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-115">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="569b7-116">Stattdessen können Sie sich XAML als Unterstützung eines eigenen Typsystems vorstellen.</span><span class="sxs-lookup"><span data-stu-id="569b7-116">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="569b7-117">Das spezielle von WPF verwendete XAML-Erstellungs System basiert auf der CLR und dem CLR-Typsystem.</span><span class="sxs-lookup"><span data-stu-id="569b7-117">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="569b7-118">XAML-Typen werden CLR-Typen zugeordnet, um eine Lauf Zeit Darstellung zu instanziieren, wenn die XAML für WPF analysiert wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-118">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="569b7-119">Aus diesem Grund enthält der Rest der Erörterung der Syntax in diesem Dokument Verweise auf das CLR-Typsystem, auch wenn die entsprechenden Syntax Diskussionen in der XAML-Sprachspezifikation dies nicht tun.</span><span class="sxs-lookup"><span data-stu-id="569b7-119">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="569b7-120">(Gemäß der XAML-sprach Spezifikations Ebene können XAML-Typen einem beliebigen anderen Typsystem zugeordnet werden, was nicht die CLR sein muss, aber dies erfordert die Erstellung und Verwendung eines anderen XAML-Parsers.)</span><span class="sxs-lookup"><span data-stu-id="569b7-120">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="569b7-121">Member von Typen und Klassen Vererbung</span><span class="sxs-lookup"><span data-stu-id="569b7-121">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="569b7-122">Eigenschaften und Ereignisse, die als XAML-Member eines [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Typs angezeigt werden, werden oft von Basis Typen geerbt.</span><span class="sxs-lookup"><span data-stu-id="569b7-122">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="569b7-123">Sehen Sie sich beispielsweise Folgendes Beispiel an: `<Button Background="Blue" .../>` .</span><span class="sxs-lookup"><span data-stu-id="569b7-123">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="569b7-124">Die- <xref:System.Windows.Controls.Control.Background%2A> Eigenschaft ist keine sofort deklarierte Eigenschaft in der <xref:System.Windows.Controls.Button> Klasse, wenn Sie die Klassendefinition, die Reflektionsergebnisse oder die Dokumentation betrachten.</span><span class="sxs-lookup"><span data-stu-id="569b7-124">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="569b7-125">Stattdessen <xref:System.Windows.Controls.Control.Background%2A> wird von der-Basis <xref:System.Windows.Controls.Control> Klasse geerbt.</span><span class="sxs-lookup"><span data-stu-id="569b7-125">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="569b7-126">Das Klassen Vererbungs Verhalten von [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML-Elementen ist eine bedeutende Abkehr von der durch das Schema erzwungene Interpretation von XML-Markup.</span><span class="sxs-lookup"><span data-stu-id="569b7-126">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="569b7-127">Die Klassen Vererbung kann komplex werden, insbesondere dann, wenn zwischen Basisklassen abstrakt sind oder wenn Schnittstellen beteiligt sind.</span><span class="sxs-lookup"><span data-stu-id="569b7-127">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="569b7-128">Dies ist ein Grund, warum der Satz von XAML-Elementen und deren zulässige Attribute schwierig und vollständig mit den Schema Typen, die normalerweise für die XML-Programmierung verwendet werden, wie z. b. DTD oder XSD-Format, darstellen kann.</span><span class="sxs-lookup"><span data-stu-id="569b7-128">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="569b7-129">Ein weiterer Grund ist, dass Erweiterbarkeits-und Typmapping-Features der XAML-Sprache selbst die Vollständigkeit jeder festgelegten Darstellung der zulässigen Typen und Member ausschließen.</span><span class="sxs-lookup"><span data-stu-id="569b7-129">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a><span data-ttu-id="569b7-130">Objektelementsyntax</span><span class="sxs-lookup"><span data-stu-id="569b7-130">Object Element Syntax</span></span>  
 <span data-ttu-id="569b7-131">Die *Objekt Element Syntax* ist die XAML-Markup Syntax, die eine CLR-Klasse oder-Struktur durch Deklarieren eines XML-Elements instanziiert.</span><span class="sxs-lookup"><span data-stu-id="569b7-131">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="569b7-132">Diese Syntax ähnelt der Element Syntax anderer Markup Sprachen, wie z. b. html.</span><span class="sxs-lookup"><span data-stu-id="569b7-132">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="569b7-133">Die Objekt Element Syntax beginnt mit einer öffnende spitze Klammer ( \< ), gefolgt von dem Typnamen der Klasse oder Struktur, die instanziiert wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-133">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="569b7-134">0 (null) oder mehr Leerzeichen können dem Typnamen folgen, und NULL oder mehr Attribute können auch für das Object-Element deklariert werden, wobei ein oder mehrere Leerzeichen das Paar Attribute Name = "Wert" trennen.</span><span class="sxs-lookup"><span data-stu-id="569b7-134">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="569b7-135">Schließlich muss einer der folgenden Punkte zutreffen:</span><span class="sxs-lookup"><span data-stu-id="569b7-135">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="569b7-136">Das Element und das Tag müssen mit einem Schrägstrich (/) geschlossen werden, gefolgt von einer rechten Spitze Klammer (>).</span><span class="sxs-lookup"><span data-stu-id="569b7-136">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="569b7-137">Das öffnende Tag muss durch eine schließende spitze Klammer (>) abgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-137">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="569b7-138">Andere Objekt Elemente, Eigenschaften Elemente oder innerer Text können dem öffnenden Tag folgen.</span><span class="sxs-lookup"><span data-stu-id="569b7-138">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="569b7-139">Der Inhalt, der hier enthalten sein kann, wird in der Regel durch das Objektmodell des Elements eingeschränkt.</span><span class="sxs-lookup"><span data-stu-id="569b7-139">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="569b7-140">Das entsprechende schließende Tag für das Object-Element muss auch vorhanden sein, in ordnungsgemäßer Schachtelung und in Einklang mit anderen öffnenden und schließenden Tagpaaren.</span><span class="sxs-lookup"><span data-stu-id="569b7-140">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="569b7-141">XAML, wie von .NET implementiert, verfügt über eine Reihe von Regeln, die Objekt Elemente Typen, Attributen in Eigenschaften oder Ereignissen und XAML-Namespaces in CLR-Namespaces Plus Assembly zuordnen.</span><span class="sxs-lookup"><span data-stu-id="569b7-141">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="569b7-142">Für WPF und .net werden XAML-Objekt Elemente .NET-Typen entsprechend den in referenzierten Assemblys definierten zugeordnet, und die Attribute werden den Membern dieser Typen zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="569b7-142">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="569b7-143">Wenn Sie in XAML auf einen CLR-Typ verweisen, haben Sie auch Zugriff auf die geerbten Member dieses Typs.</span><span class="sxs-lookup"><span data-stu-id="569b7-143">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="569b7-144">Beispielsweise ist das folgende Beispiel eine Objekt Element Syntax, die eine neue Instanz der-Klasse instanziiert <xref:System.Windows.Controls.Button> und außerdem ein <xref:System.Windows.FrameworkElement.Name%2A> -Attribut und einen Wert für dieses Attribut angibt:</span><span class="sxs-lookup"><span data-stu-id="569b7-144">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="569b7-145">Das folgende Beispiel ist eine Objekt Element Syntax, die auch die Syntax der XAML-Inhalts Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="569b7-145">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="569b7-146">Der innere Text, der in enthalten ist, wird verwendet <xref:System.Windows.Controls.TextBox> , um die XAML-Inhalts Eigenschaft festzulegen <xref:System.Windows.Controls.TextBox.Text%2A> .</span><span class="sxs-lookup"><span data-stu-id="569b7-146">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="569b7-147">Inhalts Modelle</span><span class="sxs-lookup"><span data-stu-id="569b7-147">Content Models</span></span>  
 <span data-ttu-id="569b7-148">Eine Klasse unterstützt möglicherweise eine Verwendung als XAML-Objekt Element in Bezug auf die Syntax, dieses Element funktioniert jedoch nur ordnungsgemäß in einer Anwendung oder einer Seite, wenn es an einer erwarteten Position eines gesamten Inhalts Modells oder einer Elementstruktur platziert wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-148">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="569b7-149">Beispielsweise sollte eine <xref:System.Windows.Controls.MenuItem> in der Regel nur als untergeordnetes Element einer <xref:System.Windows.Controls.Primitives.MenuBase> abgeleiteten Klasse, z. b., platziert werden <xref:System.Windows.Controls.Menu> .</span><span class="sxs-lookup"><span data-stu-id="569b7-149">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="569b7-150">Inhalts Modelle für bestimmte Elemente werden als Teil der Hinweise auf die Klassen Seiten für Steuerelemente und andere [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Klassen dokumentiert, die als XAML-Elemente verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="569b7-150">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a><span data-ttu-id="569b7-151">Eigenschaften von Objekt Elementen</span><span class="sxs-lookup"><span data-stu-id="569b7-151">Properties of Object Elements</span></span>  
 <span data-ttu-id="569b7-152">Eigenschaften in XAML werden durch eine Vielzahl von Syntax Möglichkeiten festgelegt.</span><span class="sxs-lookup"><span data-stu-id="569b7-152">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="569b7-153">Welche Syntax für eine bestimmte Eigenschaft verwendet werden kann, hängt von den zugrunde liegenden typsystemmerkmalen der Eigenschaft ab, die Sie festlegen.</span><span class="sxs-lookup"><span data-stu-id="569b7-153">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="569b7-154">Wenn Sie Werte für Eigenschaften festlegen, fügen Sie Objekten Funktionen oder Eigenschaften hinzu, wie Sie im Laufzeitobjekt Diagramm vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="569b7-154">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="569b7-155">Der ursprüngliche Zustand des erstellten Objekts aus einem-Objekt Element basiert auf dem Parameter losen konstruktorverhalten.</span><span class="sxs-lookup"><span data-stu-id="569b7-155">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="569b7-156">In der Regel verwendet Ihre Anwendung etwas anderes als eine vollständig Standard Instanz eines beliebigen Objekts.</span><span class="sxs-lookup"><span data-stu-id="569b7-156">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a><span data-ttu-id="569b7-157">Attributsyntax (Eigenschaften)</span><span class="sxs-lookup"><span data-stu-id="569b7-157">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="569b7-158">Die Attribut Syntax ist die XAML-Markup Syntax, mit der ein Wert für eine Eigenschaft festgelegt wird, indem ein Attribut für ein vorhandenes Objekt Element deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-158">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="569b7-159">Der Attribut Name muss mit dem CLR-Elementnamen der-Eigenschaft der-Klasse, die das relevante Object-Element sichert, identisch sein.</span><span class="sxs-lookup"><span data-stu-id="569b7-159">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="569b7-160">Auf den Attributnamen folgt ein Zuweisungs Operator (=).</span><span class="sxs-lookup"><span data-stu-id="569b7-160">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="569b7-161">Der Attribut Wert muss eine in Anführungszeichen eingeschlossene Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="569b7-161">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="569b7-162">Sie können abwechselnde Anführungszeichen verwenden, um ein literales Anführungszeichen innerhalb eines Attributs zu platzieren.</span><span class="sxs-lookup"><span data-stu-id="569b7-162">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="569b7-163">Beispielsweise können Sie einfache Anführungszeichen als Mittel zum Deklarieren einer Zeichenfolge verwenden, die ein doppeltes Anführungszeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="569b7-163">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="569b7-164">Unabhängig davon, ob Sie einfache oder doppelte Anführungszeichen verwenden, sollten Sie ein entsprechendes Paar zum Öffnen und Schließen der Zeichenfolge für den Attribut Wert verwenden.</span><span class="sxs-lookup"><span data-stu-id="569b7-164">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="569b7-165">Es gibt auch Escapesequenzen oder andere Techniken zum Umgehen von Zeichen Einschränkungen, die von einer bestimmten XAML-Syntax auferlegt werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-165">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="569b7-166">Siehe [XML-Zeichen Entitäten und XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span><span class="sxs-lookup"><span data-stu-id="569b7-166">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="569b7-167">Damit eine Eigenschaft über die Attribut Syntax festgelegt werden kann, muss sie öffentlich sein und beschreibbar sein.</span><span class="sxs-lookup"><span data-stu-id="569b7-167">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="569b7-168">Der Wert der Eigenschaft im Unterstützungs-Typsystem muss ein Werttyp oder ein Verweistyp sein, der beim Zugriff auf den entsprechenden Sicherungstyp von einem XAML-Prozessor instanziiert oder referenziert werden kann.</span><span class="sxs-lookup"><span data-stu-id="569b7-168">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="569b7-169">Bei WPF-XAML-Ereignissen muss das Ereignis, auf das als Attribut Name verwiesen wird, öffentlich sein und über einen öffentlichen Delegaten verfügen.</span><span class="sxs-lookup"><span data-stu-id="569b7-169">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="569b7-170">Die Eigenschaft oder das Ereignis muss ein Member der Klasse oder Struktur sein, die vom enthaltenden Objekt Element instanziiert wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-170">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="569b7-171">Verarbeiten von Attributwerten</span><span class="sxs-lookup"><span data-stu-id="569b7-171">Processing of Attribute Values</span></span>  
 <span data-ttu-id="569b7-172">Der Zeichen folgen Wert, der in den öffnenden und schließenden Anführungszeichen enthalten ist, wird von einem XAML-Prozessor verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="569b7-172">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="569b7-173">Bei-Eigenschaften wird das Standard Verarbeitungs Verhalten durch den Typ der zugrunde liegenden CLR-Eigenschaft bestimmt.</span><span class="sxs-lookup"><span data-stu-id="569b7-173">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="569b7-174">Der Attribut Wert wird mithilfe der folgenden Verarbeitungsreihenfolge von einem der folgenden Werte aufgefüllt:</span><span class="sxs-lookup"><span data-stu-id="569b7-174">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="569b7-175">Wenn der XAML-Prozessor auf eine geschweifte Klammer oder ein Objekt Element trifft, das von abgeleitet <xref:System.Windows.Markup.MarkupExtension> wird, wird die referenzierte Markup Erweiterung zuerst ausgewertet, anstatt den Wert als Zeichenfolge zu verarbeiten, und das von der Markup Erweiterung zurückgegebene Objekt wird als Wert verwendet.</span><span class="sxs-lookup"><span data-stu-id="569b7-175">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="569b7-176">In vielen Fällen handelt es sich bei dem Objekt, das von einer Markup Erweiterung zurückgegeben wird, um einen Verweis auf ein vorhandenes Objekt oder um einen Ausdruck, der die Auswertung bis zur Laufzeit auswertet und kein neu instanziierenes Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-176">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="569b7-177">Wenn die Eigenschaft mit einem attributierten deklariert wird <xref:System.ComponentModel.TypeConverter> oder der Werttyp dieser Eigenschaft mit einem attributierten deklariert wird <xref:System.ComponentModel.TypeConverter> , wird der Zeichen folgen Wert des Attributs als Konvertierungs Eingabe an den Typkonverter übermittelt, und der Konverter gibt eine neue Objektinstanz zurück.</span><span class="sxs-lookup"><span data-stu-id="569b7-177">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="569b7-178">Wenn keine vorhanden ist <xref:System.ComponentModel.TypeConverter> , wird versucht, eine direkte Konvertierung in den Eigenschaftentyp auszuführen.</span><span class="sxs-lookup"><span data-stu-id="569b7-178">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="569b7-179">Diese abschließende Ebene ist eine direkte Konvertierung bei dem Parser-systemeigenen Wert zwischen XAML-sprach primitiven Typen oder eine Überprüfung der Namen von benannten Konstanten in einer Enumeration (der Parser greift dann auf die übereinstimmenden Werte zu).</span><span class="sxs-lookup"><span data-stu-id="569b7-179">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="569b7-180">Enumerationsattributwerte</span><span class="sxs-lookup"><span data-stu-id="569b7-180">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="569b7-181">Enumerationen in XAML werden intrinsisch von XAML-Parser verarbeitet, und die Member einer Enumeration sollten durch Angabe des Zeichen folgen Namens einer der benannten Konstanten der Enumeration angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-181">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="569b7-182">Für nicht-Flag-Enumerationswerte besteht das Native Verhalten darin, die Zeichenfolge eines Attribut Werts zu verarbeiten und in einen der Enumerationswerte aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="569b7-182">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="569b7-183">Sie geben die Enumeration nicht in der *formatenumeration*an. - *Wert*, wie im Code.</span><span class="sxs-lookup"><span data-stu-id="569b7-183">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="569b7-184">Stattdessen geben Sie nur den *Wert*an, und die *Enumeration* wird durch den Typ der Eigenschaft abgeleitet, die Sie festlegen.</span><span class="sxs-lookup"><span data-stu-id="569b7-184">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="569b7-185">Wenn Sie ein Attribut in der- *Enumeration*angeben. *Wertformular* , das nicht ordnungsgemäß aufgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-185">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="569b7-186">Bei gekennzeichneten Enumerationen basiert das Verhalten auf der- <xref:System.Enum.Parse%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="569b7-186">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="569b7-187">Sie können mehrere Werte für eine flagweise Enumeration angeben, indem Sie die einzelnen Werte durch ein Komma voneinander trennen.</span><span class="sxs-lookup"><span data-stu-id="569b7-187">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="569b7-188">Enumerationswerte, die nicht flagweise sind, können jedoch nicht kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-188">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="569b7-189">Beispielsweise können Sie nicht die Komma Syntax verwenden, um zu versuchen, eine zu erstellen <xref:System.Windows.Trigger> , die mehrere Bedingungen einer Enumeration vom Typ nonflag bearbeitet:</span><span class="sxs-lookup"><span data-stu-id="569b7-189">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="569b7-190">Flagweise Enumerationen, die Attribute unterstützen, die in XAML festgelegt werden können, sind in WPF selten.</span><span class="sxs-lookup"><span data-stu-id="569b7-190">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="569b7-191">Eine solche Enumeration ist jedoch <xref:System.Windows.Media.StyleSimulations> .</span><span class="sxs-lookup"><span data-stu-id="569b7-191">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="569b7-192">Sie könnten z. b. die durch Kommas getrennte Flag-Attribut Syntax verwenden, um das in den Hinweisen für die-Klasse bereitgestellte Beispiel zu ändern <xref:System.Windows.Documents.Glyphs> `StyleSimulations = "BoldSimulation"` . könnte z `StyleSimulations = "BoldSimulation,ItalicSimulation"` . b. werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-192">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="569b7-193"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>eine andere Eigenschaft, bei der mehr als ein Enumerationswert angegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="569b7-193"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="569b7-194">Diese Eigenschaft ist jedoch ein Sonderfall, da die <xref:System.Windows.Input.ModifierKeys> Enumeration ihren eigenen Typkonverter unterstützt.</span><span class="sxs-lookup"><span data-stu-id="569b7-194">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="569b7-195">Der Typkonverter für Modifizierer verwendet ein Pluszeichen (+) als Trennzeichen anstelle eines Kommas (,).</span><span class="sxs-lookup"><span data-stu-id="569b7-195">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="569b7-196">Diese Konvertierung unterstützt die herkömmlichere Syntax zur Darstellung von Tastenkombinationen in der Microsoft Windows-Programmierung, z. b. "Strg + Alt".</span><span class="sxs-lookup"><span data-stu-id="569b7-196">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="569b7-197">Verweise auf Eigenschaften und Namen von Ereignis Membern</span><span class="sxs-lookup"><span data-stu-id="569b7-197">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="569b7-198">Wenn Sie ein Attribut angeben, können Sie auf eine beliebige Eigenschaft oder ein Ereignis verweisen, das als Member des CLR-Typs vorhanden ist, den Sie für das enthaltende Objekt Element instanziiert haben.</span><span class="sxs-lookup"><span data-stu-id="569b7-198">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="569b7-199">Oder Sie können unabhängig vom enthaltenden Objekt Element auf eine angefügte Eigenschaft oder ein angefügtes Ereignis verweisen.</span><span class="sxs-lookup"><span data-stu-id="569b7-199">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="569b7-200">(Angefügte Eigenschaften werden in einem zukünftigen Abschnitt erläutert.)</span><span class="sxs-lookup"><span data-stu-id="569b7-200">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="569b7-201">Sie können auch ein beliebiges Ereignis aus jedem Objekt benennen, auf das über den Standard Namespace mit einem *Typnamen*zugegriffen werden kann. teilweise qualifizierter *Ereignis* Name; Diese Syntax unterstützt das Anfügen von Handlern für Routing Ereignisse, bei denen der Handler das Routing von Ereignissen aus untergeordneten Elementen verarbeiten soll, aber das übergeordnete Element verfügt nicht auch über dieses Ereignis in der Members-Tabelle.</span><span class="sxs-lookup"><span data-stu-id="569b7-201">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="569b7-202">Diese Syntax ähnelt der Syntax des angefügten Ereignisses, aber das Ereignis hier ist kein true angefügtes Ereignis.</span><span class="sxs-lookup"><span data-stu-id="569b7-202">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="569b7-203">Stattdessen verweisen Sie auf ein Ereignis mit einem qualifizierten Namen.</span><span class="sxs-lookup"><span data-stu-id="569b7-203">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="569b7-204">Weitere Informationen finden Sie unter [Übersicht über Routingereignisse](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="569b7-204">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="569b7-205">In einigen Szenarios werden Eigenschaftsnamen manchmal als Wert eines Attributs und nicht als Attribut Name bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="569b7-205">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="569b7-206">Dieser Eigenschaftsname kann auch Qualifizierer einschließen, wie z. b. die Eigenschaft, die im Formular Besitzer *Type*angegeben ist. *dependencypropertyname*.</span><span class="sxs-lookup"><span data-stu-id="569b7-206">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="569b7-207">Dieses Szenario kommt häufig beim Schreiben von Stilen oder Vorlagen in XAML vor.</span><span class="sxs-lookup"><span data-stu-id="569b7-207">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="569b7-208">Die Verarbeitungs Regeln für Eigenschaftsnamen, die als Attribut Wert bereitgestellt werden, unterscheiden sich voneinander und werden durch den Typ der festzulegenden Eigenschaft oder durch das Verhalten bestimmter WPF-Subsysteme gesteuert.</span><span class="sxs-lookup"><span data-stu-id="569b7-208">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="569b7-209">Weitere Informationen finden Sie unter Erstellen von Formaten [und](../../../desktop-wpf/fundamentals/styles-templates-overview.md)Vorlagen.</span><span class="sxs-lookup"><span data-stu-id="569b7-209">For details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>  
  
 <span data-ttu-id="569b7-210">Eine weitere Verwendung für Eigenschaftsnamen ist, wenn ein Attribut Wert eine Eigenschafts Eigenschafts Beziehung beschreibt.</span><span class="sxs-lookup"><span data-stu-id="569b7-210">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="569b7-211">Diese Funktion wird für die Datenbindung und für Storyboard-Ziele verwendet und wird durch die <xref:System.Windows.PropertyPath> -Klasse und deren Typkonverter ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="569b7-211">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="569b7-212">Eine ausführlichere Beschreibung der Such Semantik finden Sie unter [PropertyPath-XAML-Syntax](propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="569b7-212">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a><span data-ttu-id="569b7-213">Eigenschaftenelement-Syntax</span><span class="sxs-lookup"><span data-stu-id="569b7-213">Property Element Syntax</span></span>  
 <span data-ttu-id="569b7-214">Die *Syntax von Eigenschafts Elementen* ist eine Syntax, die von den grundlegenden XML-Syntax Regeln für Elemente abweicht.</span><span class="sxs-lookup"><span data-stu-id="569b7-214">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="569b7-215">In XML ist der Wert eines Attributs eine de-facto-Zeichenfolge, wobei die einzige mögliche Variation darin besteht, welches Zeichen folgen Codierungsformat verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-215">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="569b7-216">In XAML können Sie andere Objekt Elemente als Wert einer Eigenschaft zuweisen.</span><span class="sxs-lookup"><span data-stu-id="569b7-216">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="569b7-217">Diese Funktion wird durch die Eigenschafts Element Syntax aktiviert.</span><span class="sxs-lookup"><span data-stu-id="569b7-217">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="569b7-218">Anstelle der Eigenschaft, die als Attribut innerhalb des Elementtags angegeben wird, wird die Eigenschaft mithilfe eines öffnenden Elementtags in *elementtykename*angegeben. *propertyName* -Formular, der Wert der-Eigenschaft wird in angegeben, und dann wird das Property-Element geschlossen.</span><span class="sxs-lookup"><span data-stu-id="569b7-218">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="569b7-219">Die Syntax beginnt mit einer linken spitzen Klammer ( \<), followed immediately by the type name of the class or structure that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (> ).</span><span class="sxs-lookup"><span data-stu-id="569b7-219">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="569b7-220">Wie bei der Attribut Syntax muss diese Eigenschaft innerhalb der deklarierten öffentlichen Member des angegebenen Typs vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="569b7-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="569b7-221">Der Wert, der der Eigenschaft zugewiesen werden soll, ist im Property-Element enthalten.</span><span class="sxs-lookup"><span data-stu-id="569b7-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="569b7-222">In der Regel wird der Wert als ein oder mehrere Objekt Elemente angegeben, da die Angabe von Objekten als Werte das Szenario ist, mit dem die Eigenschaften Element Syntax adressiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="569b7-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="569b7-223">Und schließlich ein entsprechendes Schließ Endes Tag, das denselben *elementtykename*angibt. die Kombination aus *propertyName* muss bereitgestellt werden, und zwar in angemessener Schachtelung und mit anderen Element Tags.</span><span class="sxs-lookup"><span data-stu-id="569b7-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="569b7-224">Beispielsweise ist die Syntax des Eigenschafts Elements für die- <xref:System.Windows.FrameworkElement.ContextMenu%2A> Eigenschaft eines <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="569b7-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="569b7-225">Der Wert in einem Property-Element kann auch als innerer Text angegeben werden, in Fällen, in denen der angegebene Eigenschaftentyp ein primitiver Werttyp (z. b.) <xref:System.String> oder eine Enumeration ist, in der ein Name angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="569b7-226">Diese beiden Verwendungen sind etwas ungewöhnlich, da in jedem dieser Fälle auch eine einfachere Attribut Syntax verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="569b7-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="569b7-227">Ein Szenario zum Auffüllen eines Eigenschafts Elements mit einer Zeichenfolge ist für Eigenschaften, die nicht die XAML-Inhalts Eigenschaft sind, aber immer noch für die Darstellung von UI-Text verwendet werden, und bestimmte leer Raumelemente (z. b. Zeilen Vorschübe) müssen in diesem Benutzeroberflächen Text angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="569b7-228">Die Attribut Syntax kann Linefeeds nicht beibehalten, aber die Syntax von Eigenschafts Elementen kann so lange sein, dass eine bedeutende Leerraum Beibehaltung aktiv ist (Ausführliche Informationen finden Sie unter [Leerraum Verarbeitung in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span><span class="sxs-lookup"><span data-stu-id="569b7-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="569b7-229">Ein anderes Szenario besteht darin, dass die [x:UID-Direktive](../../../desktop-wpf/xaml-services/xuid-directive.md) auf das Property-Element angewendet werden kann, wodurch der Wert in als Wert markiert wird, der in der WPF-Ausgabe-BAML oder in anderen Techniken lokalisiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="569b7-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="569b7-230">Ein Property-Element wird nicht in der logischen WPF-Struktur dargestellt.</span><span class="sxs-lookup"><span data-stu-id="569b7-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="569b7-231">Ein Eigenschafts Element ist nur eine bestimmte Syntax zum Festlegen einer Eigenschaft, und ist kein Element, das eine Instanz oder ein Objekt unterstützt.</span><span class="sxs-lookup"><span data-stu-id="569b7-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="569b7-232">(Ausführliche Informationen zum Konzept der logischen Struktur finden Sie Unterstrukturen [in WPF](trees-in-wpf.md).)</span><span class="sxs-lookup"><span data-stu-id="569b7-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="569b7-233">Bei Eigenschaften, bei denen sowohl Attribut-als auch Eigenschafts Element Syntax unterstützt wird, weisen die beiden Syntaxen im allgemeinen dasselbe Ergebnis auf, obwohl Feinheiten wie die Leerraum Behandlung leicht zwischen Syntaxen variieren können.</span><span class="sxs-lookup"><span data-stu-id="569b7-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a><span data-ttu-id="569b7-234">Auflistungssyntax</span><span class="sxs-lookup"><span data-stu-id="569b7-234">Collection Syntax</span></span>  
 <span data-ttu-id="569b7-235">Die XAML-Spezifikation erfordert XAML-Prozessor Implementierungen, um Eigenschaften zu identifizieren, bei denen der Werttyp eine Auflistung ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="569b7-236">Die allgemeine Implementierung des XAML-Prozessors in .NET basiert auf verwaltetem Code und CLR und identifiziert Auflistungs Typen mit einem der folgenden:</span><span class="sxs-lookup"><span data-stu-id="569b7-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="569b7-237">Der Typ implementiert <xref:System.Collections.IList> .</span><span class="sxs-lookup"><span data-stu-id="569b7-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="569b7-238">Der Typ implementiert <xref:System.Collections.IDictionary> .</span><span class="sxs-lookup"><span data-stu-id="569b7-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="569b7-239">Der Typ wird von abgeleitet <xref:System.Array> (Weitere Informationen zu Arrays in XAML finden Sie unter [x:Array-Markup Erweiterung](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="569b7-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="569b7-240">Wenn der Typ einer Eigenschaft eine Auflistung ist, muss der abzurufende Auflistungstyp nicht im Markup als Objekt Element angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="569b7-241">Stattdessen werden die Elemente, die als Elemente in der Auflistung dienen sollen, als ein oder mehrere untergeordnete Elemente des Property-Elements angegeben.</span><span class="sxs-lookup"><span data-stu-id="569b7-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="569b7-242">Jedes dieser Elemente wird beim Laden zu einem Objekt ausgewertet und der Auflistung hinzugefügt, indem die- `Add` Methode der impliziten Auflistung aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="569b7-243">Die- <xref:System.Windows.Style.Triggers%2A> Eigenschaft von übernimmt z <xref:System.Windows.Style> . b. den spezialisierten Sammlungstyp <xref:System.Windows.TriggerCollection> , der implementiert <xref:System.Collections.IList> .</span><span class="sxs-lookup"><span data-stu-id="569b7-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="569b7-244">Es ist nicht erforderlich, ein- <xref:System.Windows.TriggerCollection> Objekt Element im Markup zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="569b7-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="569b7-245">Stattdessen geben Sie ein oder mehrere <xref:System.Windows.Trigger> Elemente als Elemente innerhalb des `Style.Triggers` Property-Elements an, wobei <xref:System.Windows.Trigger> (oder eine abgeleitete Klasse) der Typ ist, der als Elementtyp für den stark typisierten und impliziten Wert erwartet wird <xref:System.Windows.TriggerCollection> .</span><span class="sxs-lookup"><span data-stu-id="569b7-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="569b7-246">Eine Eigenschaft kann sowohl ein Auflistungstyp als auch die XAML-Inhalts Eigenschaft für diesen Typ und die abgeleiteten Typen sein, die im nächsten Abschnitt dieses Themas erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="569b7-247">Ein implizites Auflistungs Element erstellt ein Element in der logischen Struktur Darstellung, obwohl es nicht im Markup als Element angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="569b7-248">In der Regel führt der Konstruktor des übergeordneten Typs die Instanziierung für die Auflistung aus, die eine seiner Eigenschaften ist, und die anfänglich leere Auflistung wird Teil der Objektstruktur.</span><span class="sxs-lookup"><span data-stu-id="569b7-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="569b7-249">Die generischen Listen-und Wörterbuch Schnittstellen ( <xref:System.Collections.Generic.IList%601> und <xref:System.Collections.Generic.IDictionary%602> ) werden nicht für die Sammlungs Erkennung unterstützt.</span><span class="sxs-lookup"><span data-stu-id="569b7-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="569b7-250">Allerdings können Sie die- <xref:System.Collections.Generic.List%601> Klasse als Basisklasse verwenden, da Sie <xref:System.Collections.IList> direkt implementiert, oder <xref:System.Collections.Generic.Dictionary%602> als Basisklasse, da Sie direkt implementiert <xref:System.Collections.IDictionary> .</span><span class="sxs-lookup"><span data-stu-id="569b7-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="569b7-251">In den .net-Referenzseiten für Auflistungs Typen wird diese Syntax gelegentlich in den XAML-Syntax Abschnitten als implizite Sammlungs Syntax angegeben.</span><span class="sxs-lookup"><span data-stu-id="569b7-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="569b7-252">Mit Ausnahme des Stamm Elements ist jedes Objekt Element in einer XAML-Datei, das als untergeordnetes Element eines anderen Elements als untergeordnetes Element angezeigt wird, tatsächlich ein Element, bei dem es sich um einen oder beide der folgenden Fälle handelt: ein Member einer impliziten Auflistungs Eigenschaft des übergeordneten Elements oder ein Element, das den Wert der XAML-Inhalts Eigenschaft für das übergeordnete Element angibt (XAML-Inhalts Eigenschaften werden in einem kommenden Abschnitt erläutert).</span><span class="sxs-lookup"><span data-stu-id="569b7-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="569b7-253">Anders ausgedrückt: die Beziehung zwischen übergeordneten Elementen und untergeordneten Elementen in einer Markup Seite ist tatsächlich ein einzelnes Objekt am Stamm, und jedes Objekt Element unterhalb des Stamms ist entweder eine einzelne Instanz, die einen Eigenschafts Wert des übergeordneten Elements bereitstellt, oder eines der Elemente in einer Auflistung, bei dem es sich auch um einen Auflistungstyp-Eigenschafts Wert des übergeordneten Elements handelt</span><span class="sxs-lookup"><span data-stu-id="569b7-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="569b7-254">Dieses Single-root-Konzept ist in XML üblich und wird häufig durch das Verhalten von APIs verstärkt, die XAML wie laden <xref:System.Windows.Markup.XamlReader.Load%2A> .</span><span class="sxs-lookup"><span data-stu-id="569b7-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="569b7-255">Das folgende Beispiel ist eine Syntax, bei der das Object-Element für eine Auflistung ( <xref:System.Windows.Media.GradientStopCollection> ) explizit angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="569b7-256">Beachten Sie, dass es nicht immer möglich ist, die Auflistung explizit zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="569b7-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="569b7-257">Wenn Sie z. b. versuchen, <xref:System.Windows.TriggerCollection> explizit im zuvor gezeigten Beispiel zu deklarieren, tritt ein Fehler auf <xref:System.Windows.Style.Triggers%2A> .</span><span class="sxs-lookup"><span data-stu-id="569b7-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="569b7-258">Die explizite Deklaration der Auflistung erfordert, dass die Auflistungs Klasse einen Parameter losen Konstruktor unterstützen muss und <xref:System.Windows.TriggerCollection> keinen Parameter losen Konstruktor hat.</span><span class="sxs-lookup"><span data-stu-id="569b7-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a><span data-ttu-id="569b7-259">XAML-Inhaltseigenschaften</span><span class="sxs-lookup"><span data-stu-id="569b7-259">XAML Content Properties</span></span>  
 <span data-ttu-id="569b7-260">Die XAML-Inhalts Syntax ist eine Syntax, die nur für Klassen aktiviert ist, die <xref:System.Windows.Markup.ContentPropertyAttribute> als Teil ihrer Klassen Deklaration angeben.</span><span class="sxs-lookup"><span data-stu-id="569b7-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="569b7-261">Der <xref:System.Windows.Markup.ContentPropertyAttribute> verweist auf den Eigenschaftsnamen, der die Content-Eigenschaft für diesen Elementtyp (einschließlich abgeleiteter Klassen) ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="569b7-262">Bei der Verarbeitung durch einen XAML-Prozessor werden alle untergeordneten Elemente oder inneren Text, die zwischen den öffnenden und schließenden Tags des Object-Elements gefunden werden, dem Wert der XAML-Inhalts Eigenschaft für dieses Objekt zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="569b7-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="569b7-263">Sie sind berechtigt, explizite Eigenschaften Elemente für die Content-Eigenschaft anzugeben. diese Verwendung wird jedoch im Allgemeinen nicht in den XAML-Syntax Abschnitten in der .net-Referenz aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="569b7-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="569b7-264">Das explizite/ausführliche Verfahren hat einen gelegentlichen Wert für die Markup Übersichtlichkeit oder eine Frage des Markup Stils, aber in der Regel ist es eine Inhalts Eigenschaft, das Markup zu optimieren, sodass Elemente, die intuitiv als über-/unterordnungsweise als übergeordnetes Element verwandt sind, direkt eingefügt werden können.</span><span class="sxs-lookup"><span data-stu-id="569b7-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="569b7-265">Eigenschaften Element Tags für andere Eigenschaften eines Elements werden nicht gemäß einer strengen XAML-Sprachdefinition als "Content" zugewiesen. Sie werden zuvor in der Verarbeitungsreihenfolge des XAML-Parsers verarbeitet und werden nicht als "Content" betrachtet.</span><span class="sxs-lookup"><span data-stu-id="569b7-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="569b7-266">XAML-Inhalts Eigenschaftswerte müssen zusammenhängend sein.</span><span class="sxs-lookup"><span data-stu-id="569b7-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="569b7-267">Der Wert einer XAML-Inhalts Eigenschaft muss entweder vollständig vor oder vollständig nach allen anderen Eigenschafts Elementen für dieses Objekt Element angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="569b7-268">Dies gilt unabhängig davon, ob der Wert einer XAML-Inhalts Eigenschaft als Zeichenfolge oder als ein oder mehrere-Objekte angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="569b7-269">Beispielsweise wird das folgende Markup nicht analysiert:</span><span class="sxs-lookup"><span data-stu-id="569b7-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="569b7-270">Dies ist im Wesentlichen der Fall, wenn diese Syntax mithilfe der Eigenschafts Element Syntax für die Content-Eigenschaft explizit festgelegt wurde, dann wird die Content-Eigenschaft zweimal festgelegt:</span><span class="sxs-lookup"><span data-stu-id="569b7-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="569b7-271">Ein ähnliches Beispiel ist, wenn die Content-Eigenschaft eine Auflistung ist und untergeordnete Elemente mit Eigenschafts Elementen vermischt werden:</span><span class="sxs-lookup"><span data-stu-id="569b7-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="569b7-272">Inhaltseigenschaften und Auflistungssyntax in Kombination</span><span class="sxs-lookup"><span data-stu-id="569b7-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="569b7-273">Um mehr als ein einzelnes Objekt Element als Inhalt zu akzeptieren, muss der Typ der Inhalts Eigenschaft ein Sammlungstyp sein.</span><span class="sxs-lookup"><span data-stu-id="569b7-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="569b7-274">Ähnlich wie bei der Eigenschafts Element Syntax für Auflistungs Typen müssen von einem XAML-Prozessortypen identifiziert werden, die Sammlungs Typen sind.</span><span class="sxs-lookup"><span data-stu-id="569b7-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="569b7-275">Wenn ein Element über eine XAML-Inhalts Eigenschaft verfügt und der Typ der XAML-Inhalts Eigenschaft eine Auflistung ist, muss der implizite Sammlungstyp nicht im Markup als Objekt Element angegeben werden, und die XAML-Inhalts Eigenschaft muss nicht als Eigenschafts Element angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="569b7-276">Daher kann dem offensichtlich Inhalts Modell im Markup nun mehr als ein untergeordnetes Element als Inhalt zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="569b7-277">Im folgenden finden Sie eine Inhalts Syntax für eine <xref:System.Windows.Controls.Panel> abgeleitete Klasse.</span><span class="sxs-lookup"><span data-stu-id="569b7-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="569b7-278">Alle <xref:System.Windows.Controls.Panel> abgeleiteten Klassen stellen die XAML-Inhalts Eigenschaft als <xref:System.Windows.Controls.Panel.Children%2A> dar, die einen Wert vom Typ erfordert <xref:System.Windows.Controls.UIElementCollection> .</span><span class="sxs-lookup"><span data-stu-id="569b7-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="569b7-279">Beachten Sie, dass weder das Property-Element für <xref:System.Windows.Controls.Panel.Children%2A> noch das-Element für das <xref:System.Windows.Controls.UIElementCollection> im Markup erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="569b7-280">Dies ist eine Entwurfs Funktion von XAML, sodass rekursiv enthaltene Elemente, die eine definieren, intuitiver [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] als eine Struktur von untergeordneten Elementen mit direkt über-und untergeordneten Element Beziehungen dargestellt werden, ohne dass es dabei um Eigenschaften-oder Auflistungs Objekte handelt.</span><span class="sxs-lookup"><span data-stu-id="569b7-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="569b7-281">In der Tat <xref:System.Windows.Controls.UIElementCollection> kann nicht explizit im Markup als Objekt Element explizit angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="569b7-282">Da die einzige beabsichtigte Verwendung als implizite Auflistung verwendet wird, <xref:System.Windows.Controls.UIElementCollection> macht keinen öffentlichen Parameter losen Konstruktor verfügbar und kann daher nicht als Objekt Element instanziiert werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="569b7-283">Mischen von Eigenschafts Elementen und Objekt Elementen in einem Objekt mit einer Content-Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="569b7-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="569b7-284">Die XAML-Spezifikation deklariert, dass ein XAML-Prozessor erzwingen kann, dass Objekt Elemente, die zum Ausfüllen der XAML-Inhalts Eigenschaft in einem Objekt Element verwendet werden, zusammenhängend sein müssen und nicht gemischt werden dürfen.</span><span class="sxs-lookup"><span data-stu-id="569b7-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="569b7-285">Diese Einschränkung für das Mischen von Eigenschaften Elementen und Inhalten wird durch die [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML-Prozessoren erzwungen.</span><span class="sxs-lookup"><span data-stu-id="569b7-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="569b7-286">Sie können ein untergeordnetes Object-Element als erstes unmittelbares Markup innerhalb eines Object-Elements haben.</span><span class="sxs-lookup"><span data-stu-id="569b7-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="569b7-287">Anschließend können Sie Eigenschaften Elemente einführen.</span><span class="sxs-lookup"><span data-stu-id="569b7-287">Then you can introduce property elements.</span></span> <span data-ttu-id="569b7-288">Oder Sie können ein oder mehrere Eigenschaften Elemente, dann den Inhalt und dann weitere Eigenschaften Elemente angeben.</span><span class="sxs-lookup"><span data-stu-id="569b7-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="569b7-289">Wenn jedoch ein Eigenschaften Element auf den Inhalt folgt, können Sie keinen weiteren Inhalt einführen, Sie können nur Eigenschaften Elemente hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="569b7-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="569b7-290">Diese Anforderungs Anforderung für Inhalt/Eigenschaften Element gilt nicht für inneren Text, der als Inhalt verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="569b7-291">Allerdings ist es immer noch ein guter Markup Stil, um inneren Text zusammenhängend aufzubewahren, da es schwierig ist, im Markup visuell zu erkennen, wenn die Eigenschaften Elemente mit innerem Text miteinander vermischt werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a><span data-ttu-id="569b7-292">XAML-Namespaces</span><span class="sxs-lookup"><span data-stu-id="569b7-292">XAML Namespaces</span></span>  
 <span data-ttu-id="569b7-293">Keines der vorangehenden Syntax Beispiele hat einen anderen XAML-Namespace als den standardmäßigen XAML-Namespace angegeben.</span><span class="sxs-lookup"><span data-stu-id="569b7-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="569b7-294">In typischen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Anwendungen wird der XAML-Standard Namespace als [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Namespace angegeben.</span><span class="sxs-lookup"><span data-stu-id="569b7-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="569b7-295">Sie können andere XAML-Namespaces als den standardmäßigen XAML-Namespace angeben und dennoch eine ähnliche Syntax verwenden.</span><span class="sxs-lookup"><span data-stu-id="569b7-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="569b7-296">Wenn eine Klasse den Namen hat, auf die nicht innerhalb des standardmäßigen XAML-Namespace zugegriffen werden kann, muss dem Klassennamen jedoch das Präfix des XAML-Namespace vorangestellt sein, das dem entsprechenden CLR-Namespace zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="569b7-297">Beispielsweise `<custom:Example/>` ist eine Objekt Element Syntax zum Instanziieren einer Instanz der- `Example` Klasse, bei der der CLR-Namespace, der diese Klasse enthält (und möglicherweise die Informationen der externen Assembly, die Unterstützungs Typen enthalten), zuvor dem- `custom` Präfix zugeordnet wurde.</span><span class="sxs-lookup"><span data-stu-id="569b7-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="569b7-298">Weitere Informationen zu XAML-Namespaces finden Sie unter [XAML-Namespaces und Namespace Zuordnung für WPF-XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="569b7-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a><span data-ttu-id="569b7-299">Markuperweiterungen</span><span class="sxs-lookup"><span data-stu-id="569b7-299">Markup Extensions</span></span>  
 <span data-ttu-id="569b7-300">XAML definiert eine Markup-Erweiterungs Programmier Entität, die einen Escapezeichen aus der normalen XAML-Prozessor Verarbeitung von Zeichen folgen Attributwerten oder Objekt Elementen ermöglicht und die Verarbeitung einer Unterstützungs Klasse zusichert.</span><span class="sxs-lookup"><span data-stu-id="569b7-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="569b7-301">Das Zeichen, das eine Markup Erweiterung eines XAML-Prozessors identifiziert, wenn die Attribut Syntax verwendet wird, ist die öffnende geschweifte Klammer ({), gefolgt von einem beliebigen Zeichen, das keine schließende geschweifte Klammer (}) ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="569b7-302">Die erste Zeichenfolge, die auf die öffnende geschweifte Klammer folgt, muss auf die Klasse verweisen, die das jeweilige Erweiterungs Verhalten bereitstellt, wobei der Verweis die Teil Zeichenfolge "Extension" weglassen kann, wenn diese Teil Zeichenfolge Teil des echten Klassen namens ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="569b7-303">Danach kann ein einzelnes Leerzeichen angezeigt werden, und dann wird jedes nachfolgende Zeichen als Eingabe von der Erweiterungs Implementierung verwendet, bis die schließende geschweifte Klammer gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="569b7-304">Die .net XAML-Implementierung verwendet die <xref:System.Windows.Markup.MarkupExtension> abstrakte-Klasse als Grundlage für alle Markup Erweiterungen, die von unterstützt werden, sowie [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] andere Frameworks oder Technologien.</span><span class="sxs-lookup"><span data-stu-id="569b7-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="569b7-305">Die [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] speziell implementierten Markup Erweiterungen sind häufig dazu gedacht, eine Möglichkeit bereitzustellen, auf andere vorhandene Objekte zu verweisen, oder verzögerte Verweise auf Objekte zu erstellen, die zur Laufzeit ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="569b7-306">Beispielsweise wird eine einfache WPF-Datenbindung durch Angabe der `{Binding}` Markup Erweiterung anstelle des Werts durchgeführt, den eine bestimmte Eigenschaft normalerweise annehmen würde.</span><span class="sxs-lookup"><span data-stu-id="569b7-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="569b7-307">Viele der WPF-Markup Erweiterungen ermöglichen eine Attribut Syntax für Eigenschaften, bei denen andernfalls eine Attribut Syntax nicht möglich wäre.</span><span class="sxs-lookup"><span data-stu-id="569b7-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="569b7-308">Beispielsweise ist ein- <xref:System.Windows.Style> Objekt ein relativ komplexer Typ, der eine Reihe von-Objekten und-Eigenschaften enthält.</span><span class="sxs-lookup"><span data-stu-id="569b7-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="569b7-309">Stile in WPF werden in der Regel als Ressource in einer definiert <xref:System.Windows.ResourceDictionary> . Anschließend wird auf eine der beiden WPF-Markup Erweiterungen verwiesen, die eine Ressource anfordern.</span><span class="sxs-lookup"><span data-stu-id="569b7-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="569b7-310">Die Markup Erweiterung gibt die Auswertung des Eigenschafts Werts zu einer Ressourcen Suche zurück und ermöglicht die Bereitstellung des Werts der <xref:System.Windows.FrameworkElement.Style%2A> Eigenschaft, die den Typ annimmt <xref:System.Windows.Style> , in der Attribut Syntax, wie im folgenden Beispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="569b7-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="569b7-311">Hier `StaticResource` identifiziert die- <xref:System.Windows.StaticResourceExtension> Klasse, die die Implementierung der Markup Erweiterung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="569b7-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="569b7-312">Die nächste Zeichenfolge `MyStyle` wird als Eingabe für den nicht <xref:System.Windows.StaticResourceExtension> Standardkonstruktor verwendet, wobei der Parameter, der aus der Erweiterungs Zeichenfolge entnommen wurde, die angeforderte deklariert <xref:System.Windows.ResourceKey> .</span><span class="sxs-lookup"><span data-stu-id="569b7-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="569b7-313">`MyStyle`Es wird erwartet, dass es sich um den [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) -Wert einer handelt, die <xref:System.Windows.Style> als Ressource definiert ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="569b7-314">Die Verwendung der [statikresource-Markup Erweiterung](staticresource-markup-extension.md) fordert an, dass die Ressource verwendet wird, um den <xref:System.Windows.Style> Eigenschafts Wert über die statische Ressourcen Suchlogik zur Ladezeit bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="569b7-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="569b7-315">Weitere Informationen über Markuperweiterungen finden Sie unter [Markuperweiterungen und WPF XAML](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="569b7-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="569b7-316">Einen Verweis auf Markup Erweiterungen und andere XAML-Programmierfunktionen, die in der allgemeinen .net XAML-Implementierung aktiviert sind, finden Sie unter [XAML-Namespace (x:) Sprach Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="569b7-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="569b7-317">Informationen zu WPF-spezifischen Markup Erweiterungen finden Sie unter [WPF-XAML-Erweiterungen](wpf-xaml-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="569b7-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a><span data-ttu-id="569b7-318">Angefügte Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="569b7-318">Attached Properties</span></span>  
 <span data-ttu-id="569b7-319">Angefügte Eigenschaften sind ein in XAML eingeführte Programmier Konzept, bei dem Eigenschaften im Besitz eines bestimmten Typs sein können, aber als Attribute oder Eigenschaften Elemente für jedes Element festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="569b7-320">Das primäre Szenario, für das angefügte Eigenschaften vorgesehen sind, besteht darin, untergeordneten Elementen in einer Markup Struktur das Melden von Informationen an ein übergeordnetes Element zu ermöglichen, ohne dass ein umfassend frei gegebenes Objektmodell über alle Elemente hinweg</span><span class="sxs-lookup"><span data-stu-id="569b7-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="569b7-321">Umgekehrt können von übergeordneten Elementen angefügte Eigenschaften verwendet werden, um Informationen an untergeordnete Elemente zu melden.</span><span class="sxs-lookup"><span data-stu-id="569b7-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="569b7-322">Weitere Informationen zum Zweck angefügter Eigenschaften und zum Erstellen eigener angefügter Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="569b7-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="569b7-323">Angefügte Eigenschaften verwenden eine Syntax, die der Eigenschafts Element Syntax sehr ähnlich ist, da Sie auch einen *Typnamen*angeben. *propertyName* -Kombination.</span><span class="sxs-lookup"><span data-stu-id="569b7-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="569b7-324">Es gibt zwei wichtige Unterschiede:</span><span class="sxs-lookup"><span data-stu-id="569b7-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="569b7-325">Sie können den *Typnamen*verwenden. *propertyName* -Kombination, auch wenn eine angefügte Eigenschaft durch Attribut Syntax festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="569b7-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="569b7-326">Angefügte Eigenschaften sind der einzige Fall, bei dem das qualifizieren des Eigenschafts namens eine Anforderung in einer Attribut Syntax ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="569b7-327">Sie können auch die Eigenschaften Element Syntax für angefügte Eigenschaften verwenden.</span><span class="sxs-lookup"><span data-stu-id="569b7-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="569b7-328">Bei der typischen Eigenschafts Element Syntax ist der von Ihnen angegebene *Typname* jedoch das Object-Element, das das Property-Element enthält.</span><span class="sxs-lookup"><span data-stu-id="569b7-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="569b7-329">Wenn Sie auf eine angefügte Eigenschaft verweisen, ist der *Typname* die Klasse, die die angefügte Eigenschaft definiert, nicht das enthaltende Objekt Element.</span><span class="sxs-lookup"><span data-stu-id="569b7-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>
## <a name="attached-events"></a><span data-ttu-id="569b7-330">Angefügte Ereignisse</span><span class="sxs-lookup"><span data-stu-id="569b7-330">Attached Events</span></span>  
 <span data-ttu-id="569b7-331">Angefügte Ereignisse sind ein weiteres Programmier Konzept, das in XAML eingeführt wurde, in dem Ereignisse von einem bestimmten Typ definiert werden können, aber Handler können an jedes beliebige Objekt Element angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="569b7-332">In der WOF-Implementierung ist oft der Typ, der ein angefügtes Ereignis definiert, ein statischer Typ, der einen Dienst definiert, und manchmal werden diese angefügten Ereignisse von einem Alias Ereignis Alias in Typen verfügbar gemacht, die den Dienst verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="569b7-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="569b7-333">Handler für angefügte Ereignisse werden durch Attribut Syntax angegeben.</span><span class="sxs-lookup"><span data-stu-id="569b7-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="569b7-334">Wie bei angefügten Ereignissen wird die Attribut Syntax für angefügte Ereignisse so erweitert, dass ein *Typname*zulässig ist. Verwendung von *EventName* , wobei *tyadapame* die Klasse ist, die `Add` - `Remove` Ereignishandleraccessoren für die angefügte Ereignis Infrastruktur bereitstellt, und *EventName* ist der Ereignis Name.</span><span class="sxs-lookup"><span data-stu-id="569b7-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="569b7-335">Anatomie eines XAML-Stamm Elements</span><span class="sxs-lookup"><span data-stu-id="569b7-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="569b7-336">Die folgende Tabelle zeigt ein typisches XAML-Stamm Element, das die spezifischen Attribute eines Stamm Elements anzeigt:</span><span class="sxs-lookup"><span data-stu-id="569b7-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="569b7-337">Öffnen des Object-Elements des Root-Elements</span><span class="sxs-lookup"><span data-stu-id="569b7-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="569b7-338">Der Standard- [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML-Namespace ()</span><span class="sxs-lookup"><span data-stu-id="569b7-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="569b7-339">XAML-Namespace der XAML-Sprache</span><span class="sxs-lookup"><span data-stu-id="569b7-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="569b7-340">Die Deklaration der partiellen Klasse, die das Markup mit allen für die partiellen Klasse definierten Code Behind-Klassen verbindet</span><span class="sxs-lookup"><span data-stu-id="569b7-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="569b7-341">Das Ende des Objekt Elements für den Stamm.</span><span class="sxs-lookup"><span data-stu-id="569b7-341">End of object element for the root.</span></span> <span data-ttu-id="569b7-342">Das Objekt ist noch nicht geschlossen, da das Element untergeordnete Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="569b7-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="569b7-343">Optionale und nicht empfohlene XAML-Verwendungen</span><span class="sxs-lookup"><span data-stu-id="569b7-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="569b7-344">In den folgenden Abschnitten werden XAML-Verwendungen beschrieben, die in technischer Hinsicht von XAML-Prozessoren unterstützt werden, die jedoch ausführlichkeits-oder andere ästhetische Probleme mit sich bringen, die bei der Entwicklung von Anwendungen, die XAML-Quellen enthalten, eine Benutzer lesbare XAML-Datei</span><span class="sxs-lookup"><span data-stu-id="569b7-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="569b7-345">Optionale Verwendung von Eigenschafts Elementen</span><span class="sxs-lookup"><span data-stu-id="569b7-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="569b7-346">Optionale Verwendung von Eigenschafts Elementen schließt das explizite Schreiben von Element Inhalts Eigenschaften ein, die vom XAML-Prozessor als implizit betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="569b7-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="569b7-347">Wenn Sie z. b. den Inhalt eines deklarieren <xref:System.Windows.Controls.Menu> , können Sie festlegen, dass die <xref:System.Windows.Controls.ItemsControl.Items%2A> -Auflistung der <xref:System.Windows.Controls.Menu> als `<Menu.Items>` Eigenschaftenelementtag explizit deklariert und <xref:System.Windows.Controls.MenuItem> innerhalb von `<Menu.Items>` platziert wird, anstatt das implizite XAML-Prozessor Verhalten zu verwenden, dass alle untergeordneten Elemente von <xref:System.Windows.Controls.Menu> eine sein müssen <xref:System.Windows.Controls.MenuItem> und in der Auflistung platziert werden <xref:System.Windows.Controls.ItemsControl.Items%2A> .</span><span class="sxs-lookup"><span data-stu-id="569b7-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="569b7-348">Manchmal können die optionalen Verwendungen dabei helfen, die Objektstruktur visuell zu verdeutlichen, wie im Markup dargestellt.</span><span class="sxs-lookup"><span data-stu-id="569b7-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="569b7-349">Manchmal kann eine explizite Verwendung eines Eigenschafts Elements Markup vermeiden, das technisch funktional, aber visuell verwirrend ist, wie z. b. geschachtelte Markup Erweiterungen innerhalb eines Attribut Werts.</span><span class="sxs-lookup"><span data-stu-id="569b7-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="569b7-350">Vollständige Typname. Mitgliedschafts Name qualifizierte Attribute</span><span class="sxs-lookup"><span data-stu-id="569b7-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="569b7-351">Der *Typname*. das Formular für *Mitgliedsnamen* für ein Attribut funktioniert tatsächlich eher universell als nur der Routing Ereignis Fall.</span><span class="sxs-lookup"><span data-stu-id="569b7-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="569b7-352">In anderen Situationen ist das Formular jedoch überflüssig, und Sie sollten es vermeiden, wenn dies nur aus Gründen der Markup-und Lesbarkeit erfolgt.</span><span class="sxs-lookup"><span data-stu-id="569b7-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="569b7-353">Im folgenden Beispiel ist jeder der drei Verweise auf das- <xref:System.Windows.Controls.Control.Background%2A> Attribut vollständig äquivalent:</span><span class="sxs-lookup"><span data-stu-id="569b7-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="569b7-354">`Button.Background`funktioniert, weil die qualifizierte Suche für diese Eigenschaft für <xref:System.Windows.Controls.Button> erfolgreich ist ( <xref:System.Windows.Controls.Control.Background%2A> wurde von Control geerbt) und <xref:System.Windows.Controls.Button> die Klasse des Object-Elements oder einer Basisklasse ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="569b7-355">`Control.Background`funktioniert, weil die <xref:System.Windows.Controls.Control> -Klasse tatsächlich definiert <xref:System.Windows.Controls.Control.Background%2A> und <xref:System.Windows.Controls.Control> eine <xref:System.Windows.Controls.Button> Basisklasse ist.</span><span class="sxs-lookup"><span data-stu-id="569b7-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="569b7-356">Der folgende *Typname*ist jedoch. das Formular für den *Mitgliedsnamen* funktioniert nicht und wird daher als kommentiert angezeigt:</span><span class="sxs-lookup"><span data-stu-id="569b7-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="569b7-357"><xref:System.Windows.Controls.Label>ist eine andere abgeleitete Klasse von <xref:System.Windows.Controls.Control> , und wenn Sie `Label.Background` in einem- <xref:System.Windows.Controls.Label> Objekt Element angegeben haben, hätte diese Verwendung funktioniert.</span><span class="sxs-lookup"><span data-stu-id="569b7-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="569b7-358">Da jedoch <xref:System.Windows.Controls.Label> nicht die Klasse oder Basisklasse von ist <xref:System.Windows.Controls.Button> , wird das angegebene XAML-Prozessor Verhalten `Label.Background` als angefügte Eigenschaft verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="569b7-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="569b7-359">`Label.Background`ist keine verfügbare angefügte Eigenschaft, und diese Verwendung schlägt fehl.</span><span class="sxs-lookup"><span data-stu-id="569b7-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="569b7-360">basetypame. Membership Name-Eigenschafts Elemente</span><span class="sxs-lookup"><span data-stu-id="569b7-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="569b7-361">Analog zur Art des *Typnamens*. das Formular für den *Mitgliednamen* funktioniert für die Attribut Syntax, einen *basety-Name*. die Syntax des *Mitgliedschafts namens* funktioniert für die Eigenschafts Element Syntax.</span><span class="sxs-lookup"><span data-stu-id="569b7-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="569b7-362">Beispielsweise funktioniert die folgende Syntax:</span><span class="sxs-lookup"><span data-stu-id="569b7-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="569b7-363">Hier wurde das Property-Element als angegeben, `Control.Background` Obwohl das Property-Element in enthalten war `Button` .</span><span class="sxs-lookup"><span data-stu-id="569b7-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="569b7-364">Aber genau wie *tygtame*. Formular für *mitgliedschaftsnamen* für Attribute, *basetyname*. der *Name der Mitgliedschaft* ist im Markup unzureichend, und Sie sollten ihn vermeiden.</span><span class="sxs-lookup"><span data-stu-id="569b7-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="569b7-365">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="569b7-365">See also</span></span>

- [<span data-ttu-id="569b7-366">Übersicht über XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="569b7-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="569b7-367">XAML-Namespace (x:) Sprachfunktionen</span><span class="sxs-lookup"><span data-stu-id="569b7-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="569b7-368">WPF-XAML-Erweiterungen</span><span class="sxs-lookup"><span data-stu-id="569b7-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="569b7-369">Übersicht über Abhängigkeitseigenschaften</span><span class="sxs-lookup"><span data-stu-id="569b7-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="569b7-370">TypeConverter und XAML</span><span class="sxs-lookup"><span data-stu-id="569b7-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="569b7-371">XAML- und benutzerdefinierte Klassen für WPF</span><span class="sxs-lookup"><span data-stu-id="569b7-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
