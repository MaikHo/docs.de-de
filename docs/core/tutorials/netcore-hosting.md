---
title: Schreiben eines benutzerdefinierten .NET Core-Laufzeithosts
description: Erfahren Sie, wie Sie die.NET Core-Runtime vom nativen Code aus hosten können, um erweiterte Szenarien zu unterstützen, die eine Kontrolle der Funktionsweise der.NET Core-Runtime erfordern.
author: mjrousos
ms.topic: how-to
ms.date: 12/21/2018
ms.openlocfilehash: 3b24ade694e25040d77e411bead3f454e9d5cdef
ms.sourcegitcommit: c4a15c6c4ecbb8a46ad4e67d9b3ab9b8b031d849
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "88656175"
---
# <a name="write-a-custom-net-core-host-to-control-the-net-runtime-from-your-native-code"></a><span data-ttu-id="567f5-103">Schreiben Sie einen benutzerdefinierten .NET Core-Host, um die .NET-Runtime über den systemeigenen Code zu steuern.</span><span class="sxs-lookup"><span data-stu-id="567f5-103">Write a custom .NET Core host to control the .NET runtime from your native code</span></span>

<span data-ttu-id="567f5-104">Wie alle verwalteten Codes werden .NET Core-Anwendungen von einem Host ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="567f5-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="567f5-105">Der Host ist für das Starten der Runtime (einschließlich Komponenten wie die JIT und Garbage Collector) und das Aufrufen von verwalteten Einstiegspunkten verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="567f5-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector) and invoking managed entry points.</span></span>

<span data-ttu-id="567f5-106">Das Hosten der Laufzeit von .NET Core ist ein erweitertes Szenario, und in den meisten Fällen brauchen sich .NET Core-Entwickler nicht darum kümmern, da die Buildprozesse von .NET Core einen Standardhost bereitstellen, der die .NET Core-Anwendungen ausführt.</span><span class="sxs-lookup"><span data-stu-id="567f5-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="567f5-107">Unter speziellen Umständen kann es jedoch hilfreich sein, die .NET Core-Laufzeit explizit zu hosten, entweder als Mittel zum Aufrufen von verwalteten Codes in einem nativen Prozess oder um mehr Kontrolle über die Funktionsweise der Laufzeit zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="567f5-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="567f5-108">Dieser Artikel bietet einen Überblick über die erforderlichen Schritte zum Starten der .NET Core-Runtime aus nativem Code und für das Ausführen von darin enthaltenem verwalteten Code.</span><span class="sxs-lookup"><span data-stu-id="567f5-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="567f5-109">Voraussetzungen</span><span class="sxs-lookup"><span data-stu-id="567f5-109">Prerequisites</span></span>

<span data-ttu-id="567f5-110">Da Hosts native Anwendungen sind, wird in diesem Tutorial das Erstellen einer C++-Anwendung zum Hosten von .NET Core behandelt.</span><span class="sxs-lookup"><span data-stu-id="567f5-110">Because hosts are native applications, this tutorial covers constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="567f5-111">Sie benötigen eine C++-Entwicklungsumgebung (z.B. von [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span><span class="sxs-lookup"><span data-stu-id="567f5-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="567f5-112">Sie sollten außerdem über eine einfache .NET Core-Anwendung zum Testen des Hosts verfügen, daher sollten Sie die [.NET Core SDK](https://dotnet.microsoft.com/download) installieren und [eine kleine .NET Core-Testanwendung erstellen](with-visual-studio.md) (z.B. die Anwendung „Hello World“).</span><span class="sxs-lookup"><span data-stu-id="567f5-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://dotnet.microsoft.com/download) and [build a small .NET Core test app](with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="567f5-113">Die „Hello World“-Anwendung, die von der neuen Projektvorlage der .NET Core-Konsole erstellt wird, ist ausreichend.</span><span class="sxs-lookup"><span data-stu-id="567f5-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

## <a name="hosting-apis"></a><span data-ttu-id="567f5-114">Hosting-APIs</span><span class="sxs-lookup"><span data-stu-id="567f5-114">Hosting APIs</span></span>
<span data-ttu-id="567f5-115">Sie können drei APIs verwenden, um .NET Core zu hosten.</span><span class="sxs-lookup"><span data-stu-id="567f5-115">There are three different APIs that can be used to host .NET Core.</span></span> <span data-ttu-id="567f5-116">In diesem Artikel (und den zugehörigen [Beispielen](https://github.com/dotnet/samples/tree/master/core/hosting)) werden alle Optionen behandelt.</span><span class="sxs-lookup"><span data-stu-id="567f5-116">This article (and its associated [samples](https://github.com/dotnet/samples/tree/master/core/hosting)) covers all options.</span></span>

* <span data-ttu-id="567f5-117">Die bevorzugte Methode zum Hosten der .NET Core-Runtime ab .NET Core 3.0 ist mithilfe der APIs der Bibliotheken `nethost` und `hostfxr`.</span><span class="sxs-lookup"><span data-stu-id="567f5-117">The preferred method of hosting the .NET Core runtime in .NET Core 3.0 and above is with the `nethost` and `hostfxr` libraries' APIs.</span></span> <span data-ttu-id="567f5-118">Diese Einstiegspunkte bewältigen die Komplexität des Auffindens und Einrichtens der Runtime für die Initialisierung und ermöglichen sowohl das Starten einer verwalteten Anwendung als auch das Aufrufen einer statischen verwalteten Methode.</span><span class="sxs-lookup"><span data-stu-id="567f5-118">These entry points handle the complexity of finding and setting up the runtime for initialization and allow both launching a managed application and calling into a static managed method.</span></span>
* <span data-ttu-id="567f5-119">Die API [CoreClrHost.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/hosts/inc/coreclrhost.h) wird jedoch vor .NET Core 3.0 bevorzugt für das Hosten der .NET Core-Runtime verwendet.</span><span class="sxs-lookup"><span data-stu-id="567f5-119">The preferred method of hosting the .NET Core runtime prior to .NET Core 3.0 is with the [CoreClrHost.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/hosts/inc/coreclrhost.h) API.</span></span> <span data-ttu-id="567f5-120">Diese API enthält Funktionen, mit denen Sie die Runtime einfach starten und beenden können und verwalteten Code aufrufen können, indem Sie entweder eine entsprechende ausführbare Datei ausführen oder verwaltete statische Methoden aufrufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-120">This API exposes functions for easily starting and stopping the runtime and invoking managed code (either by launching a managed exe or by calling static managed methods).</span></span>
* <span data-ttu-id="567f5-121">.NET Core kann jedoch auch mit der `ICLRRuntimeHost4`-Schnittstelle in [mscoree.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/mscoree.h) gehostet werden.</span><span class="sxs-lookup"><span data-stu-id="567f5-121">.NET Core can also be hosted with the `ICLRRuntimeHost4` interface in [mscoree.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/mscoree.h).</span></span> <span data-ttu-id="567f5-122">Diese API ist älter als „CoreClrHost.h“, deshalb kann es vorkommen, dass ältere Hosts diese verwenden.</span><span class="sxs-lookup"><span data-stu-id="567f5-122">This API has been around longer than CoreClrHost.h, so you may have seen older hosts using it.</span></span> <span data-ttu-id="567f5-123">Die API funktioniert weiterhin und ermöglicht eine bessere Steuerung des Hostprozesses als „CoreClrHost“.</span><span class="sxs-lookup"><span data-stu-id="567f5-123">It still works and allows a bit more control over the hosting process than CoreClrHost.</span></span> <span data-ttu-id="567f5-124">In den meisten Fällen wird „CoreClrHost.h“ jedoch aufgrund der einfacheren APIs bevorzugt.</span><span class="sxs-lookup"><span data-stu-id="567f5-124">For most scenarios, though, CoreClrHost.h is preferred now because of its simpler APIs.</span></span>

## <a name="sample-hosts"></a><span data-ttu-id="567f5-125">Beispielhosts</span><span class="sxs-lookup"><span data-stu-id="567f5-125">Sample Hosts</span></span>

<span data-ttu-id="567f5-126">[Beispielhosts](https://github.com/dotnet/samples/tree/master/core/hosting) zur Veranschaulichung der Schritte in diesen Tutorials sind im GitHub-Repository „dotnet/samples“ auf verfügbar.</span><span class="sxs-lookup"><span data-stu-id="567f5-126">[Sample hosts](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in the tutorials below are available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="567f5-127">Durch die Kommentare in den Beispielen werden die nummerierten Schritte in diesem Tutorial ihrer Position im Beispiel eindeutig zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="567f5-127">Comments in the samples clearly associate the numbered steps from these tutorials with where they're performed in the sample.</span></span> <span data-ttu-id="567f5-128">Anweisungen zum Herunterladen finden Sie unter [Beispiele und Lernprogramme](../../samples-and-tutorials/index.md#view-and-download-samples).</span><span class="sxs-lookup"><span data-stu-id="567f5-128">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#view-and-download-samples).</span></span>

<span data-ttu-id="567f5-129">Bedenken Sie, dass die Beispielhosts zu Lernzwecken gedacht und somit bei der Fehlerüberprüfung nachsichtig sind. Die Lesbarkeit steht in diesem Fall über der Effizienz.</span><span class="sxs-lookup"><span data-stu-id="567f5-129">Keep in mind that the sample hosts are meant to be used for learning purposes, so they are light on error checking and are designed to emphasize readability over efficiency.</span></span>

## <a name="create-a-host-using-nethosth-and-hostfxrh"></a><span data-ttu-id="567f5-130">Erstellen eines Hosts mithilfe von NetHost.h und HostFxr.h</span><span class="sxs-lookup"><span data-stu-id="567f5-130">Create a host using NetHost.h and HostFxr.h</span></span>

<span data-ttu-id="567f5-131">In den folgenden Schritten wird detailliert beschrieben, wie Sie die Bibliotheken `nethost` und `hostfxr` verwenden können, um die .NET Core-Runtime in einer nativen Anwendung zu starten und eine verwaltete statische Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-131">The following steps detail how to use the `nethost` and `hostfxr` libraries to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="567f5-132">Im [Beispiel](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) werden der mit dem .NET SDK installierte Header `nethost` und die Bibliothek sowie Kopien der Dateien [`coreclr_delegates.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/coreclr_delegates.h) und [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) aus dem Repository [dotnet/core-setup](https://github.com/dotnet/core-setup) verwendet.</span><span class="sxs-lookup"><span data-stu-id="567f5-132">The [sample](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) uses the `nethost` header and library installed with the .NET SDK and copies of the [`coreclr_delegates.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/coreclr_delegates.h) and [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) files from the [dotnet/core-setup](https://github.com/dotnet/core-setup) repository.</span></span>

### <a name="step-1---load-hostfxr-and-get-exported-hosting-functions"></a><span data-ttu-id="567f5-133">Schritt 1: Laden von HostFxr und Erhalten der exportierten Hostingfunktionen</span><span class="sxs-lookup"><span data-stu-id="567f5-133">Step 1 - Load HostFxr and get exported hosting functions</span></span>

<span data-ttu-id="567f5-134">Die Bibliothek `nethost` bietet die Funktion `get_hostfxr_path` für das Auffinden der Bibliothek `hostfxr`.</span><span class="sxs-lookup"><span data-stu-id="567f5-134">The `nethost` library provides the `get_hostfxr_path` function for locating the `hostfxr` library.</span></span> <span data-ttu-id="567f5-135">Die Bibliothek `hostfxr` macht die Funktionen zum Hosten der .NET Core-Runtime verfügbar.</span><span class="sxs-lookup"><span data-stu-id="567f5-135">The `hostfxr` library exposes functions for hosting the .NET Core runtime.</span></span> <span data-ttu-id="567f5-136">Die vollständige Liste der Funktionen finden Sie in [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) und im [Entwurfsdokument zum nativen Hosting](https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/native-hosting.md).</span><span class="sxs-lookup"><span data-stu-id="567f5-136">The full list of functions can be found in [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) and the [native hosting design document](https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/native-hosting.md).</span></span> <span data-ttu-id="567f5-137">Im Beispiel und in diesem Tutorial wird Folgendes verwendet:</span><span class="sxs-lookup"><span data-stu-id="567f5-137">The sample and this tutorial use the following:</span></span>

* <span data-ttu-id="567f5-138">`hostfxr_initialize_for_runtime_config`: Initialisiert einen Hostkontext und bereitet die Initialisierung der .NET Core-Runtime mithilfe der angegebenen Runtimekonfiguration vor.</span><span class="sxs-lookup"><span data-stu-id="567f5-138">`hostfxr_initialize_for_runtime_config`: Initializes a host context and prepares for initialization of the .NET Core runtime using the specified runtime configuration.</span></span>
* <span data-ttu-id="567f5-139">`hostfxr_get_runtime_delegate`: Ruft einen Delegaten für Runtimefunktionalität ab.</span><span class="sxs-lookup"><span data-stu-id="567f5-139">`hostfxr_get_runtime_delegate`: Gets a delegate for runtime functionality.</span></span>
* <span data-ttu-id="567f5-140">`hostfxr_close`: Schließt einen Hostkontext.</span><span class="sxs-lookup"><span data-stu-id="567f5-140">`hostfxr_close`: Closes a host context.</span></span>

<span data-ttu-id="567f5-141">Die Bibliothek `hostfxr` wird mithilfe von `get_hostfxr_path` gefunden.</span><span class="sxs-lookup"><span data-stu-id="567f5-141">The `hostfxr` library is found using `get_hostfxr_path`.</span></span> <span data-ttu-id="567f5-142">Sie wird anschließend geladen, und ihre Exporte werden abgerufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-142">It is then loaded and its exports are retrieved.</span></span>

[!code-cpp[HostFxrHost#LoadHostFxr](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadHostFxr)]

### <a name="step-2---initialize-and-start-the-net-core-runtime"></a><span data-ttu-id="567f5-143">Schritt 2: Initialisieren und Starten der .NET Core-Runtime</span><span class="sxs-lookup"><span data-stu-id="567f5-143">Step 2 - Initialize and start the .NET Core runtime</span></span>

<span data-ttu-id="567f5-144">Die Funktionen `hostfxr_initialize_for_runtime_config` und `hostfxr_get_runtime_delegate` initialisieren und starten die .NET Core-Runtime unter Verwendung der Runtimekonfiguration für die verwaltete Komponente, die geladen wird.</span><span class="sxs-lookup"><span data-stu-id="567f5-144">The `hostfxr_initialize_for_runtime_config` and `hostfxr_get_runtime_delegate` functions initialize and start the .NET Core runtime using the runtime configuration for the managed component that will be loaded.</span></span> <span data-ttu-id="567f5-145">Die Funktion `hostfxr_get_runtime_delegate` wird verwendet, um einen Runtimedelegaten abzurufen, der das Laden einer verwalteten Assembly und das Abrufen eines Funktionszeigers auf eine statische Methode in dieser Assembly ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="567f5-145">The `hostfxr_get_runtime_delegate` function is used to get a runtime delegate that allows loading a managed assembly and getting a function pointer to a static method in that assembly.</span></span>

[!code-cpp[HostFxrHost#Initialize](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#Initialize)]

### <a name="step-3---load-managed-assembly-and-get-function-pointer-to-a-managed-method"></a><span data-ttu-id="567f5-146">Schritt 3: Laden der verwalteten Assembly und Abrufen des Funktionszeigers auf eine verwaltete Methode</span><span class="sxs-lookup"><span data-stu-id="567f5-146">Step 3 - Load managed assembly and get function pointer to a managed method</span></span>

<span data-ttu-id="567f5-147">Der Runtimedelegat wird aufgerufen, um die verwaltete Assembly zu laden und einen Funktionszeiger auf eine verwaltete Methode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-147">The runtime delegate is called to load the managed assembly and get a function pointer to a managed method.</span></span> <span data-ttu-id="567f5-148">Der Delegat benötigt den Assemblypfad, Typ- und Methodennamen als Eingaben und gibt einen Funktionszeiger zurück, mit dem die verwaltete Methode aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="567f5-148">The delegate requires the assembly path, type name, and method name as inputs and returns a function pointer that can be used to invoke the managed method.</span></span>

[!code-cpp[HostFxrHost#LoadAndGet](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadAndGet)]

<span data-ttu-id="567f5-149">Durch die Übergabe von `nullptr` als Delegatentypname beim Aufruf des Runtimedelegaten verwendet das Beispiel eine Standardsignatur für die verwaltete Methode:</span><span class="sxs-lookup"><span data-stu-id="567f5-149">By passing `nullptr` as the delegate type name when calling the runtime delegate, the sample uses a default signature for the managed method:</span></span>

```csharp
public delegate int ComponentEntryPoint(IntPtr args, int sizeBytes);
```

<span data-ttu-id="567f5-150">Eine andere Signatur kann verwendet werden, indem beim Aufruf des Runtimedelegaten der Name des Delegatentyps angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="567f5-150">A different signature can be used by specifying the delegate type name when calling the runtime delegate.</span></span>

### <a name="step-4---run-managed-code"></a><span data-ttu-id="567f5-151">Schritt 4: Ausführen von verwaltetem Code</span><span class="sxs-lookup"><span data-stu-id="567f5-151">Step 4 - Run managed code!</span></span>

<span data-ttu-id="567f5-152">Der native Host kann nun die verwaltete Methode aufrufen und die gewünschten Parameter an sie übergeben.</span><span class="sxs-lookup"><span data-stu-id="567f5-152">The native host can now call the managed method and pass it the desired parameters.</span></span>

[!code-cpp[HostFxrHost#CallManaged](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#CallManaged)]

## <a name="create-a-host-using-coreclrhosth"></a><span data-ttu-id="567f5-153">Erstellen eines Hosts mithilfe von „CoreClrHost.h“</span><span class="sxs-lookup"><span data-stu-id="567f5-153">Create a host using CoreClrHost.h</span></span>

<span data-ttu-id="567f5-154">In den folgenden Schritten wird detailliert beschrieben, wie Sie die API „CoreClrHost.h“ verwenden können, um die .NET Core-Runtime in einer nativen Anwendung zu starten und eine verwaltete statische Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-154">The following steps detail how to use the CoreClrHost.h API to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="567f5-155">Für die Codeausschnitte in diesem Artikel werden einige Windows-spezifische APIs verwendet. Im [vollständigen Beispielhost](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) sind jedoch Windows- und Linux-Codepfade enthalten.</span><span class="sxs-lookup"><span data-stu-id="567f5-155">The code snippets in this document use some Windows-specific APIs, but the [full sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) shows both Windows and Linux code paths.</span></span>

<span data-ttu-id="567f5-156">[Unix CoreRun Host](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/unixcorerun) zeigt ein komplexeres, realistisches Beispiel für das Hosting mit „coreclrhost.h“.</span><span class="sxs-lookup"><span data-stu-id="567f5-156">The [Unix CoreRun host](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/unixcorerun) shows a more complex, real-world example of hosting using coreclrhost.h.</span></span>

### <a name="step-1---find-and-load-coreclr"></a><span data-ttu-id="567f5-157">Schritt 1: Suchen und Laden von CoreCLR</span><span class="sxs-lookup"><span data-stu-id="567f5-157">Step 1 - Find and load CoreCLR</span></span>

<span data-ttu-id="567f5-158">Die APIs für die .NET Core-Runtime befinden sich in *coreclr.dll* (Windows), *libcoreclr.so* (Linux) und *libcoreclr.dylib* (macOS).</span><span class="sxs-lookup"><span data-stu-id="567f5-158">The .NET Core runtime APIs are in *coreclr.dll* (on Windows), in *libcoreclr.so* (on Linux), or in *libcoreclr.dylib* (on macOS).</span></span> <span data-ttu-id="567f5-159">Wenn Sie .NET Core hosten möchten, müssen Sie zunächst die CoreCLR-Bibliothek laden.</span><span class="sxs-lookup"><span data-stu-id="567f5-159">The first step to hosting .NET Core is to load the CoreCLR library.</span></span> <span data-ttu-id="567f5-160">Einige Hosts durchsuchen unterschiedliche Pfade oder verwenden Eingabeparameter, um die Bibliothek zu suchen, während anderen bekannt ist, dass diese aus einem bestimmten Pfad geladen werden muss (z. B. neben dem Host oder von einem computerweiten Speicherort).</span><span class="sxs-lookup"><span data-stu-id="567f5-160">Some hosts probe different paths or use input parameters to find the library while others know to load it from a certain path (next to the host, for example, or from a machine-wide location).</span></span>

<span data-ttu-id="567f5-161">Sobald die Bibliothek gefunden wurde, wird sie mit `LoadLibraryEx` (Windows) oder `dlopen` (Linux/macOS) geladen.</span><span class="sxs-lookup"><span data-stu-id="567f5-161">Once found, the library is loaded with `LoadLibraryEx` (on Windows) or `dlopen` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#1](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#1)]

### <a name="step-2---get-net-core-hosting-functions"></a><span data-ttu-id="567f5-162">Schritt 2: .NET Core-Hostingfunktionen</span><span class="sxs-lookup"><span data-stu-id="567f5-162">Step 2 - Get .NET Core hosting functions</span></span>

<span data-ttu-id="567f5-163">In CoreClrHost sind einige wichtige Methoden enthalten, die für das Hosten von .NET Core nützlich sind:</span><span class="sxs-lookup"><span data-stu-id="567f5-163">CoreClrHost has several important methods useful for hosting .NET Core:</span></span>

* <span data-ttu-id="567f5-164">`coreclr_initialize`: Startet die .NET Core-Runtime und richtet die (einzige) Standardanwendungsdomäne ein.</span><span class="sxs-lookup"><span data-stu-id="567f5-164">`coreclr_initialize`: Starts the .NET Core runtime and sets up the default (and only) AppDomain.</span></span>
* <span data-ttu-id="567f5-165">`coreclr_execute_assembly`: Führt eine verwaltete Assembly aus.</span><span class="sxs-lookup"><span data-stu-id="567f5-165">`coreclr_execute_assembly`: Executes a managed assembly.</span></span>
* <span data-ttu-id="567f5-166">`coreclr_create_delegate`: Erstellt einen Funktionszeiger zu einer verwalteten Methode.</span><span class="sxs-lookup"><span data-stu-id="567f5-166">`coreclr_create_delegate`: Creates a function pointer to a managed method.</span></span>
* <span data-ttu-id="567f5-167">`coreclr_shutdown`: Beendet die .NET Core-Runtime.</span><span class="sxs-lookup"><span data-stu-id="567f5-167">`coreclr_shutdown`: Shuts down the .NET Core runtime.</span></span>
* <span data-ttu-id="567f5-168">`coreclr_shutdown_2`: Funktioniert wie `coreclr_shutdown`, ruft jedoch zusätzlich den Exitcode des verwalteten Codes ab.</span><span class="sxs-lookup"><span data-stu-id="567f5-168">`coreclr_shutdown_2`: Like `coreclr_shutdown`, but also retrieves the managed code's exit code.</span></span>

<span data-ttu-id="567f5-169">Nachdem Sie die CoreCLR-Bibliothek geladen haben, müssen Sie mithilfe von `GetProcAddress` (Windows) oder `dlsym` (Linux/macOS) auf diese Funktion verweisen.</span><span class="sxs-lookup"><span data-stu-id="567f5-169">After loading the CoreCLR library, the next step is to get references to these functions using `GetProcAddress` (on Windows) or `dlsym` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#2](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#2)]

### <a name="step-3---prepare-runtime-properties"></a><span data-ttu-id="567f5-170">Schritt 3: Vorbereiten der Runtimeeigenschaften</span><span class="sxs-lookup"><span data-stu-id="567f5-170">Step 3 - Prepare runtime properties</span></span>

<span data-ttu-id="567f5-171">Bevor Sie die Runtime starten, müssen Sie einige Eigenschaften auf bestimmte Verhaltensweisen festlegen (insbesondere für das Assemblyladeprogramm).</span><span class="sxs-lookup"><span data-stu-id="567f5-171">Before starting the runtime, it is necessary to prepare some properties to specify behavior (especially concerning the assembly loader).</span></span>

<span data-ttu-id="567f5-172">Das gilt üblicherweise für folgende Eigenschaften:</span><span class="sxs-lookup"><span data-stu-id="567f5-172">Common properties include:</span></span>

* <span data-ttu-id="567f5-173">`TRUSTED_PLATFORM_ASSEMBLIES`: Diese Eigenschaft stellt eine Liste der Assemblypfade (unter Windows durch „;“ und unter Linux durch „:“ getrennt) dar, die die Runtime standardmäßig auflösen kann.</span><span class="sxs-lookup"><span data-stu-id="567f5-173">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Linux) which the runtime will be able to resolve by default.</span></span> <span data-ttu-id="567f5-174">Einige Hosts verfügen über hartcodierte Manifeste mit Assemblys, die geladen werden können.</span><span class="sxs-lookup"><span data-stu-id="567f5-174">Some hosts have hard-coded manifests listing assemblies they can load.</span></span> <span data-ttu-id="567f5-175">Andere platzieren Bibliotheken in dieser Liste an bestimmten Positionen (z. B. neben *coreclr.dll*).</span><span class="sxs-lookup"><span data-stu-id="567f5-175">Others will put any library in certain locations (next to *coreclr.dll*, for example) on this list.</span></span>
* <span data-ttu-id="567f5-176">`APP_PATHS` Dies ist eine Liste der Pfade, in denen nach einer Assembly gesucht werden soll, wenn sie in der Liste der vertrauenswürdigen Plattformassemblys (TPA) nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="567f5-176">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="567f5-177">Da der Host mehr Kontrolle darüber hat, welche Assemblys mithilfe der TPA-Liste geladen werden, wird empfohlen, für alle Hosts festzulegen, welche Assemblys diese erwarten und diese explizit aufzulisten.</span><span class="sxs-lookup"><span data-stu-id="567f5-177">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="567f5-178">Über diese Eigenschaft können Sie auch die Überprüfung von Runtimes aktivieren.</span><span class="sxs-lookup"><span data-stu-id="567f5-178">If probing at run time is needed, however, this property can enable that scenario.</span></span>
* <span data-ttu-id="567f5-179">`APP_NI_PATHS`: Diese Liste ähnelt APP_PATHS sehr ähnlich, gilt jedoch für Pfade, die nach nativen Images durchsucht werden sollen.</span><span class="sxs-lookup"><span data-stu-id="567f5-179">`APP_NI_PATHS` This list is similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
* <span data-ttu-id="567f5-180">`NATIVE_DLL_SEARCH_DIRECTORIES`: Diese Eigenschaft ist eine Liste der Pfade, die das Ladeprogramm durchsuchen soll, wenn es nach nativen Bibliotheken sucht, die über p/invoke aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="567f5-180">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native libraries called via p/invoke.</span></span>
* <span data-ttu-id="567f5-181">`PLATFORM_RESOURCE_ROOTS` Diese Liste enthält die Pfade, in denen nach Assemblys der Ressourcensatelliten (in kulturspezifischen Unterverzeichnissen) gesucht wird.</span><span class="sxs-lookup"><span data-stu-id="567f5-181">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific subdirectories).</span></span>

<span data-ttu-id="567f5-182">In diesem Beispielhost wird die TPA-Liste erstellt, indem alle Bibliotheken im aktuellen Verzeichnis aufgelistet werden:</span><span class="sxs-lookup"><span data-stu-id="567f5-182">In this sample host, the TPA list is constructed by simply listing all libraries in the current directory:</span></span>

[!code-cpp[CoreClrHost#7](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#7)]

<span data-ttu-id="567f5-183">Da es sich um ein einfaches Beispiel handelt, ist nur die Eigenschaft `TRUSTED_PLATFORM_ASSEMBLIES` erforderlich:</span><span class="sxs-lookup"><span data-stu-id="567f5-183">Because the sample is simple, it only needs the `TRUSTED_PLATFORM_ASSEMBLIES` property:</span></span>

[!code-cpp[CoreClrHost#3](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#3)]

### <a name="step-4---start-the-runtime"></a><span data-ttu-id="567f5-184">Schritt 4: Starten der Runtime</span><span class="sxs-lookup"><span data-stu-id="567f5-184">Step 4 - Start the runtime</span></span>

<span data-ttu-id="567f5-185">Anders als bei der Hosting-API „mscoree.h“ (siehe unten) starten die APIs von „CoreCLRHost.h“ die Runtime und erstellen die Standardanwendungsdomäne mit einem einzigen Aufruf.</span><span class="sxs-lookup"><span data-stu-id="567f5-185">Unlike the mscoree.h hosting API (described below), CoreCLRHost.h APIs start the runtime and create the default AppDomain all with a single call.</span></span> <span data-ttu-id="567f5-186">Die Funktion `coreclr_initialize` akzeptiert einen Basispfad, einen Namen und die zuvor beschriebenen Eigenschaften und gibt ein Handle zum Host über den Parameter `hostHandle` zurück.</span><span class="sxs-lookup"><span data-stu-id="567f5-186">The `coreclr_initialize` function takes a base path, name, and the properties described earlier and returns back a handle to the host via the `hostHandle` parameter.</span></span>

[!code-cpp[CoreClrHost#4](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#4)]

### <a name="step-5---run-managed-code"></a><span data-ttu-id="567f5-187">Schritt 5: Ausführen von verwaltetem Code</span><span class="sxs-lookup"><span data-stu-id="567f5-187">Step 5 - Run managed code!</span></span>

<span data-ttu-id="567f5-188">Wenn die Runtime gestartet wurde, kann der Host verwalteten Code abrufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-188">With the runtime started, the host can call managed code.</span></span> <span data-ttu-id="567f5-189">Dafür stehen verschiedene Möglichkeiten zur Auswahl.</span><span class="sxs-lookup"><span data-stu-id="567f5-189">This can be done in a couple of different ways.</span></span> <span data-ttu-id="567f5-190">Im Beispielcode für dieses Tutorial wird die Funktion `coreclr_create_delegate` verwendet, um einen Delegaten für eine verwaltete statische Methode zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="567f5-190">The sample code linked to this tutorial uses the `coreclr_create_delegate` function to create a delegate to a static managed method.</span></span> <span data-ttu-id="567f5-191">Diese API akzeptiert den [Assemblynamen](../../standard/assembly/names.md), den namespacequalifizierten Typnamen und den Methodennamen als Eingabe und gibt einen Delegaten zurück, mit dem die Methode aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="567f5-191">This API takes the [assembly name](../../standard/assembly/names.md), namespace-qualified type name, and method name as inputs and returns a delegate that can be used to invoke the method.</span></span>

[!code-cpp[CoreClrHost#5](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#5)]

<span data-ttu-id="567f5-192">In diesem Beispiel kann der Host nun `managedDelegate` verwenden, um die Methode `ManagedWorker.DoWork` aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-192">In this sample, the host can now call `managedDelegate` to run the `ManagedWorker.DoWork` method.</span></span>

<span data-ttu-id="567f5-193">Alternativ kann die `coreclr_execute_assembly`-Funktion verwendet werden, um eine verwaltete ausführbare Datei zu starten.</span><span class="sxs-lookup"><span data-stu-id="567f5-193">Alternatively, the `coreclr_execute_assembly` function can be used to launch a managed executable.</span></span> <span data-ttu-id="567f5-194">Diese API akzeptiert einen Assemblypfad und ein Array aus Argumenten als Eingabeparameter.</span><span class="sxs-lookup"><span data-stu-id="567f5-194">This API takes an assembly path and array of arguments as input parameters.</span></span> <span data-ttu-id="567f5-195">Sie lädt die Assembly aus diesem Pfad und ruft deren main-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="567f5-195">It loads the assembly at that path and invokes its main method.</span></span>

```C++
int hr = executeAssembly(
        hostHandle,
        domainId,
        argumentCount,
        arguments,
        "HelloWorld.exe",
        (unsigned int*)&exitCode);
```

### <a name="step-6---shutdown-and-clean-up"></a><span data-ttu-id="567f5-196">Schritt 6: Beenden und Bereinigen</span><span class="sxs-lookup"><span data-stu-id="567f5-196">Step 6 - Shutdown and clean up</span></span>

<span data-ttu-id="567f5-197">Wenn der Host den verwalteten Code ausgeführt hat, wird die .NET Core-Runtime schließlich mithilfe von `coreclr_shutdown` oder `coreclr_shutdown_2` beendet.</span><span class="sxs-lookup"><span data-stu-id="567f5-197">Finally, when the host is done running managed code, the .NET Core runtime is shut down with `coreclr_shutdown` or `coreclr_shutdown_2`.</span></span>

[!code-cpp[CoreClrHost#6](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#6)]

<span data-ttu-id="567f5-198">CoreCLR unterstützt keine erneute Initialisierung oder das Entladen.</span><span class="sxs-lookup"><span data-stu-id="567f5-198">CoreCLR does not support reinitialization or unloading.</span></span> <span data-ttu-id="567f5-199">Rufen Sie `coreclr_initialize` nicht erneut auf oder entladen Sie die CoreCLR-Bibliothek.</span><span class="sxs-lookup"><span data-stu-id="567f5-199">Do not call `coreclr_initialize` again or unload the CoreCLR library.</span></span>

## <a name="create-a-host-using-mscoreeh"></a><span data-ttu-id="567f5-200">Erstellen eines Hosts mithilfe von „Mscoree.h“</span><span class="sxs-lookup"><span data-stu-id="567f5-200">Create a host using Mscoree.h</span></span>

<span data-ttu-id="567f5-201">Wie zuvor erwähnt wird „CoreClrHost.h“ mittlerweile für das Hosten der .NET Core-Runtime bevorzugt.</span><span class="sxs-lookup"><span data-stu-id="567f5-201">As mentioned previously, CoreClrHost.h is now the preferred method of hosting the .NET Core runtime.</span></span> <span data-ttu-id="567f5-202">Die Schnittstelle `ICLRRuntimeHost4` kann jedoch weiterhin verwendet werden, wenn die Schnittstellen von „CoreClrHost.h“ nicht ausreichen (z. B. wenn Startflags benötigt werden, die vom Standard abweichen, oder wenn AppDomainManager in der Standarddomäne benötigt wird).</span><span class="sxs-lookup"><span data-stu-id="567f5-202">The `ICLRRuntimeHost4` interface can still be used, though, if the CoreClrHost.h interfaces aren't sufficient (if non-standard startup flags are needed, for example, or if an AppDomainManager is needed on the default domain).</span></span> <span data-ttu-id="567f5-203">Mit diesen Anleitungen werden Sie durch den Hostingvorgang von .NET Core mithilfe von „mscoree.h“ geführt.</span><span class="sxs-lookup"><span data-stu-id="567f5-203">These instructions will guide you through hosting .NET Core using mscoree.h.</span></span>

<span data-ttu-id="567f5-204">[CoreRun Host](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/corerun) zeigt ein komplexeres, realistisches Beispiel für das Hosting mit „mscoree.h“.</span><span class="sxs-lookup"><span data-stu-id="567f5-204">The [CoreRun host](https://github.com/dotnet/runtime/tree/master/src/coreclr/src/hosts/corerun) shows a more complex, real-world example of hosting using mscoree.h.</span></span>

### <a name="a-note-about-mscoreeh"></a><span data-ttu-id="567f5-205">Ein Hinweis zur mscoree.h</span><span class="sxs-lookup"><span data-stu-id="567f5-205">A note about mscoree.h</span></span>
<span data-ttu-id="567f5-206">Die .NET Core-Hostingschnittstelle (`ICLRRuntimeHost4`) wird in [MSCOREE. IDL](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/inc/MSCOREE.IDL) definiert.</span><span class="sxs-lookup"><span data-stu-id="567f5-206">The `ICLRRuntimeHost4` .NET Core hosting interface is defined in [MSCOREE.IDL](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/inc/MSCOREE.IDL).</span></span> <span data-ttu-id="567f5-207">MIDL erzeugt eine Headerversion dieser Datei (mscoree.h), auf die Ihr Host verweisen muss, wenn die [.NET Core-Laufzeit](https://github.com/dotnet/runtime/) erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="567f5-207">A header version of this file (mscoree.h), which your host will need to reference, is produced via MIDL when the [.NET Core runtime](https://github.com/dotnet/runtime/) is built.</span></span> <span data-ttu-id="567f5-208">Wenn Sie die .NET Core-Laufzeit nicht erstellen möchten, steht mscoree.h auch als [vorgefertigter Header](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/) im Repository dotnet/runtime zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="567f5-208">If you do not want to build the .NET Core runtime, mscoree.h is also available as a [pre-built header](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/) in the dotnet/runtime repository.</span></span>

### <a name="step-1---identify-the-managed-entry-point"></a><span data-ttu-id="567f5-209">Schritt 1: Ermitteln des verwalteten Einstiegspunkts</span><span class="sxs-lookup"><span data-stu-id="567f5-209">Step 1 - Identify the managed entry point</span></span>
<span data-ttu-id="567f5-210">Nach Verweisen auf die erforderlichen Header (z.B. [mscoree.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/mscoree.h) und stdio.h), muss ein .NET Core-Host als eine der ersten Aktionen den verwalteten Einstiegspunkt suchen, den er verwenden wird.</span><span class="sxs-lookup"><span data-stu-id="567f5-210">After referencing necessary headers ([mscoree.h](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/pal/prebuilt/inc/mscoree.h) and stdio.h, for example), one of the first things a .NET Core host must do is locate the managed entry point it will be using.</span></span> <span data-ttu-id="567f5-211">In unserem Beispielhost wird nur das erste Befehlszeilenargument als Pfad zu einer verwalteten Binärdatei verwendet, deren `main`-Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="567f5-211">In our sample host, this is done by just taking the first command-line argument to our host as the path to a managed binary whose `main` method will be executed.</span></span>

[!code-cpp[NetCoreHost#1](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#1)]

### <a name="step-2---find-and-load-coreclr"></a><span data-ttu-id="567f5-212">Schritt 2: Suchen und Laden von CoreCLR</span><span class="sxs-lookup"><span data-stu-id="567f5-212">Step 2 - Find and load CoreCLR</span></span>
<span data-ttu-id="567f5-213">Die .NET Core Runtime-APIs befinden sich in *CoreCLR.dll* (unter Windows).</span><span class="sxs-lookup"><span data-stu-id="567f5-213">The .NET Core runtime APIs are in *CoreCLR.dll* (on Windows).</span></span> <span data-ttu-id="567f5-214">Um unsere Hostingschnittstelle (`ICLRRuntimeHost4`) abzurufen, ist es erforderlich, *CoreCLR.dll* zu suchen und zu laden.</span><span class="sxs-lookup"><span data-stu-id="567f5-214">To get our hosting interface (`ICLRRuntimeHost4`), it's necessary to find and load *CoreCLR.dll*.</span></span> <span data-ttu-id="567f5-215">Es obliegt dem Host, eine Konvention für das Auffinden von *CoreCLR.dll* zu definieren.</span><span class="sxs-lookup"><span data-stu-id="567f5-215">It is up to the host to define a convention for how it will locate *CoreCLR.dll*.</span></span> <span data-ttu-id="567f5-216">Einige Hosts erwarten, dass die Datei an einem bekannten, computerweiten Speicherort (z. B. *%programfiles%\dotnet\shared\Microsoft.NETCore.App\2.1.6*) vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="567f5-216">Some hosts expect the file to be present in a well-known machine-wide location (such as *%programfiles%\dotnet\shared\Microsoft.NETCore.App\2.1.6*).</span></span> <span data-ttu-id="567f5-217">Andere erwarten, dass *CoreCLR.dll* von einem anderen Speicherort neben dem Host selbst oder der zu hostenden Anwendung geladen wird.</span><span class="sxs-lookup"><span data-stu-id="567f5-217">Others expect that *CoreCLR.dll* will be loaded from a location next to either the host itself or the app to be hosted.</span></span> <span data-ttu-id="567f5-218">Noch andere konsultieren möglicherweise eine Umgebungsvariable, um die Bibliothek zu finden.</span><span class="sxs-lookup"><span data-stu-id="567f5-218">Still others might consult an environment variable to find the library.</span></span>

<span data-ttu-id="567f5-219">Unter Linux oder macOS ist die Core Runtime Library jeweils *libcoreclr.so* oder *libcoreclr.dylib*.</span><span class="sxs-lookup"><span data-stu-id="567f5-219">On Linux or macOS, the core runtime library is *libcoreclr.so* or *libcoreclr.dylib*, respectively.</span></span>

<span data-ttu-id="567f5-220">Unser Beispielhost prüft einige gängige Speicherorte für *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="567f5-220">Our sample host probes a few common locations for *CoreCLR.dll*.</span></span> <span data-ttu-id="567f5-221">Wenn sie gefunden wurde, muss sie über `LoadLibrary` (oder `dlopen` unter Linux/macOS) geladen werden.</span><span class="sxs-lookup"><span data-stu-id="567f5-221">Once found, it must be loaded via `LoadLibrary` (or `dlopen` on Linux/macOS).</span></span>

[!code-cpp[NetCoreHost#2](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#2)]

### <a name="step-3---get-an-iclrruntimehost4-instance"></a><span data-ttu-id="567f5-222">Schritt 3: Abrufen einer ICLRRuntimeHost4-Instanz</span><span class="sxs-lookup"><span data-stu-id="567f5-222">Step 3 - Get an ICLRRuntimeHost4 Instance</span></span>
<span data-ttu-id="567f5-223">Die `ICLRRuntimeHost4`-Hostingschnittstelle wird durch den Aufruf von `GetProcAddress` (oder `dlsym` unter Linux/macOS) für `GetCLRRuntimeHost` abgerufen, und dann wird diese Funktion aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-223">The `ICLRRuntimeHost4` hosting interface is retrieved by calling `GetProcAddress` (or `dlsym` on Linux/macOS) on `GetCLRRuntimeHost`, and then invoking that function.</span></span>

[!code-cpp[NetCoreHost#3](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#3)]

### <a name="step-4---set-startup-flags-and-start-the-runtime"></a><span data-ttu-id="567f5-224">Schritt 4: Festlegen von Startflags und Starten der Runtime</span><span class="sxs-lookup"><span data-stu-id="567f5-224">Step 4 - Set startup flags and start the runtime</span></span>
<span data-ttu-id="567f5-225">Mit `ICLRRuntimeHost4` können wir jetzt die laufzeitweiten Startflags angeben und die Laufzeit starten.</span><span class="sxs-lookup"><span data-stu-id="567f5-225">With an `ICLRRuntimeHost4` in-hand, we can now specify runtime-wide startup flags and start the runtime.</span></span> <span data-ttu-id="567f5-226">Startflags bestimmen, welchen Garbage Collector (GC) Sie verwenden (gleichzeitig oder Server), ob eine einzelne oder mehrere Anwendungsdomänen verwendet werden und welche Ladeoptimierungsrichtlinie (für domänenneutrales Laden von Assemblys) verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="567f5-226">Startup flags determine which garbage collector (GC) to use (concurrent or server), whether we will use a single AppDomain or multiple AppDomains, and what loader optimization policy to use (for domain-neutral loading of assemblies).</span></span>

[!code-cpp[NetCoreHost#4](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#4)]

<span data-ttu-id="567f5-227">Die Laufzeit wird durch einen Aufruf der `Start`-Funktion gestartet.</span><span class="sxs-lookup"><span data-stu-id="567f5-227">The runtime is started with a call to the `Start` function.</span></span>

```C++
hr = runtimeHost->Start();
```

### <a name="step-5---preparing-appdomain-settings"></a><span data-ttu-id="567f5-228">Schritt 5: Vorbereiten der Einstellungen der AppDomain</span><span class="sxs-lookup"><span data-stu-id="567f5-228">Step 5 - Preparing AppDomain settings</span></span>
<span data-ttu-id="567f5-229">Nachdem die Laufzeit gestartet wurde, möchten wir eine AppDomain einrichten.</span><span class="sxs-lookup"><span data-stu-id="567f5-229">Once the runtime is started, we will want to set up an AppDomain.</span></span> <span data-ttu-id="567f5-230">Es gibt jedoch eine Reihe von Optionen, die beim Erstellen einer .NET AppDomain angegeben werden müssen, daher ist es erforderlich, diese zuerst vorzubereiten.</span><span class="sxs-lookup"><span data-stu-id="567f5-230">There are a number of options that must be specified when creating a .NET AppDomain, however, so it's necessary to prepare those first.</span></span>

<span data-ttu-id="567f5-231">AppDomain-Flags geben das Verhalten der AppDomain im Zusammenhang mit der Sicherheit und Interoperabilität an.</span><span class="sxs-lookup"><span data-stu-id="567f5-231">AppDomain flags specify AppDomain behaviors related to security and interop.</span></span> <span data-ttu-id="567f5-232">Ältere Silverlight-Hosts verwendeten diese Einstellungen für Sandbox-Benutzercodes, aber die meisten modernen .NET Core-Hosts führen den Benutzercode als voll vertrauenswürdig und interoperabel aus.</span><span class="sxs-lookup"><span data-stu-id="567f5-232">Older Silverlight hosts used these settings to sandbox user code, but most modern .NET Core hosts run user code as full trust and enable interop.</span></span>

[!code-cpp[NetCoreHost#5](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#5)]

<span data-ttu-id="567f5-233">Nach der Entscheidung, welche der AppDomain-Flags verwendet werden, müssen die AppDomain-Eigenschaften definiert werden.</span><span class="sxs-lookup"><span data-stu-id="567f5-233">After deciding which AppDomain flags to use, AppDomain properties must be defined.</span></span> <span data-ttu-id="567f5-234">Die Eigenschaften sind Schlüssel-/Wertpaare von Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="567f5-234">The properties are key/value pairs of strings.</span></span> <span data-ttu-id="567f5-235">Viele der Eigenschaften beziehen sich auf die Art, mit der die AppDomain Assemblys laden wird.</span><span class="sxs-lookup"><span data-stu-id="567f5-235">Many of the properties relate to how the AppDomain will load assemblies.</span></span>

<span data-ttu-id="567f5-236">Allgemeine AppDomain-Eigenschaften beinhalten:</span><span class="sxs-lookup"><span data-stu-id="567f5-236">Common AppDomain properties include:</span></span>

* <span data-ttu-id="567f5-237">`TRUSTED_PLATFORM_ASSEMBLIES` Dies ist eine Liste der Assemblypfade (unter Windows durch `;` und unter Linux/macOS durch `:` getrennt), die von Anwendungsdomänen bevorzugt geladen und als voll vertrauenswürdig eingestuft werden sollen (auch in teilweise vertrauenswürdigen Domänen).</span><span class="sxs-lookup"><span data-stu-id="567f5-237">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by `;` on Windows and `:` on Linux/macOS) which the AppDomain should prioritize loading and give full trust to (even in partially trusted domains).</span></span> <span data-ttu-id="567f5-238">Diese Liste soll „Framework“-Assemblys und andere vertrauenswürdige Module, ähnlich dem GAC in .NET Framework-Szenarios, enthalten.</span><span class="sxs-lookup"><span data-stu-id="567f5-238">This list is meant to contain 'Framework' assemblies and other trusted modules, similar to the GAC in .NET Framework scenarios.</span></span> <span data-ttu-id="567f5-239">Einige Hosts platzieren eine Bibliothek neben *coreclr.dll* in dieser Liste, andere haben andere hartcodierte Manifeste, die vertrauenswürdige Assemblys für ihre Zwecke listen.</span><span class="sxs-lookup"><span data-stu-id="567f5-239">Some hosts will put any library next to *coreclr.dll* on this list, others have hard-coded manifests listing trusted assemblies for their purposes.</span></span>
* <span data-ttu-id="567f5-240">`APP_PATHS` Dies ist eine Liste der Pfade, in denen nach einer Assembly gesucht werden soll, wenn sie in der Liste der vertrauenswürdigen Plattformassemblys (TPA) nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="567f5-240">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="567f5-241">Da der Host mehr Kontrolle darüber hat, welche Assemblys mithilfe der TPA-Liste geladen werden, wird empfohlen, für alle Hosts festzulegen, welche Assemblys diese erwarten und diese explizit aufzulisten.</span><span class="sxs-lookup"><span data-stu-id="567f5-241">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="567f5-242">Über diese Eigenschaft können Sie auch die Überprüfung von Runtimes aktivieren.</span><span class="sxs-lookup"><span data-stu-id="567f5-242">If probing at run time is needed, however, this property can enable that scenario.</span></span>
* <span data-ttu-id="567f5-243">`APP_NI_PATHS` Diese Liste ist APP_PATHS sehr ähnlich, außer dass es Pfade sein sollten, in denen nach nativen Images gesucht werden sollen.</span><span class="sxs-lookup"><span data-stu-id="567f5-243">`APP_NI_PATHS` This list is very similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
* <span data-ttu-id="567f5-244">`NATIVE_DLL_SEARCH_DIRECTORIES` Diese Eigenschaft ist eine Liste der Pfade, die das Ladeprogramm durchsuchen sollte, wenn es nach nativen DLLs sucht, die über p/invoke aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="567f5-244">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native DLLs called via p/invoke.</span></span>
* <span data-ttu-id="567f5-245">`PLATFORM_RESOURCE_ROOTS` Diese Liste enthält die Pfade, in denen nach Assemblys der Ressourcensatelliten (in kulturspezifischen Unterverzeichnissen) gesucht wird.</span><span class="sxs-lookup"><span data-stu-id="567f5-245">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific subdirectories).</span></span>

<span data-ttu-id="567f5-246">In unserem [einfache Beispielhost](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithMscoree) sind diese Eigenschaften wie folgt eingerichtet:</span><span class="sxs-lookup"><span data-stu-id="567f5-246">In our [simple sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithMscoree), these properties are set up as follows:</span></span>

[!code-cpp[NetCoreHost#6](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#6)]

### <a name="step-6---create-the-appdomain"></a><span data-ttu-id="567f5-247">Schritt 6: Erstellen der AppDomain</span><span class="sxs-lookup"><span data-stu-id="567f5-247">Step 6 - Create the AppDomain</span></span>
<span data-ttu-id="567f5-248">Sobald alle Flags und Eigenschaften der AppDomain vorbereitet sind, kann `ICLRRuntimeHost4::CreateAppDomainWithManager` zum Einrichten der AppDomain verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="567f5-248">Once all AppDomain flags and properties are prepared, `ICLRRuntimeHost4::CreateAppDomainWithManager` can be used to set up the AppDomain.</span></span> <span data-ttu-id="567f5-249">Diese Funktion hat optional einen vollqualifizierten Assemblynamen und Typnamen, die als AppDomain-Manager der Domäne verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="567f5-249">This function optionally takes a fully qualified assembly name and type name to use as the domain's AppDomain manager.</span></span> <span data-ttu-id="567f5-250">Ein AppDomain-Manager kann einem Host ermöglichen, einige Aspekte des AppDomain-Verhaltens steuern und möglicherweise Einstiegspunkte für den Start von verwaltetem Code bereitzustellen, wenn der Host den Benutzercode nicht direkt aufrufen möchte.</span><span class="sxs-lookup"><span data-stu-id="567f5-250">An AppDomain manager can allow a host to control some aspects of AppDomain behavior and may provide entry points for launching managed code if the host doesn't intend to invoke user code directly.</span></span>

[!code-cpp[NetCoreHost#7](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#7)]

### <a name="step-7---run-managed-code"></a><span data-ttu-id="567f5-251">Schritt 7: Ausführen von verwaltetem Code!</span><span class="sxs-lookup"><span data-stu-id="567f5-251">Step 7 - Run managed code!</span></span>
<span data-ttu-id="567f5-252">Mit einer laufenden AppDomain kann der Host jetzt verwalteten Code ausführen.</span><span class="sxs-lookup"><span data-stu-id="567f5-252">With an AppDomain up and running, the host can now start executing managed code.</span></span> <span data-ttu-id="567f5-253">Die einfachste Möglichkeit hierzu ist die Verwendung von `ICLRRuntimeHost4::ExecuteAssembly`, um die Einstiegspunktmethode für eine verwaltete Assembly aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-253">The easiest way to do this is to use `ICLRRuntimeHost4::ExecuteAssembly` to invoke a managed assembly's entry point method.</span></span> <span data-ttu-id="567f5-254">Beachten Sie, dass diese Funktion nur in Szenarios mit einzelnen Domänen funktioniert.</span><span class="sxs-lookup"><span data-stu-id="567f5-254">Note that this function only works in single-domain scenarios.</span></span>

[!code-cpp[NetCoreHost#8](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#8)]

<span data-ttu-id="567f5-255">Wenn `ExecuteAssembly` nicht den Anforderungen Ihres Hosts entspricht, gibt es eine andere Option, bei der Sie `CreateDelegate` verwenden, um einen Funktionszeiger zu einer statisch verwalteten Methode zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="567f5-255">Another option, if `ExecuteAssembly` doesn't meet your host's needs, is to use `CreateDelegate` to create a function pointer to a static managed method.</span></span> <span data-ttu-id="567f5-256">Dafür muss der Host die Signatur der Methode kennen, die er aufruft (um den Funktionszeigertyp zu erstellen), aber es gibt dem Host die Flexibilität, einen anderen Code als den Assemblyeingangspunkt aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="567f5-256">This requires the host to know the signature of the method it is calling into (in order to create the function pointer type) but allows hosts the flexibility to invoke code other than an assembly's entry point.</span></span> <span data-ttu-id="567f5-257">Der im zweiten Parameter angegebene Assemblyname ist der [vollständige verwaltete Assemblyname](../../standard/assembly/names.md) der zu ladenden Bibliothek.</span><span class="sxs-lookup"><span data-stu-id="567f5-257">The assembly name provided in the second parameter is the [full managed assembly name](../../standard/assembly/names.md) of the library to load.</span></span>

```C++
void *pfnDelegate = NULL;
hr = runtimeHost->CreateDelegate(
    domainId,
    L"HW, Version=1.0.0.0, Culture=neutral", // Target managed assembly
    L"ConsoleApplication.Program",           // Target managed type
    L"Main",                                 // Target entry point (static method)
    (INT_PTR*)&pfnDelegate);

((MainMethodFp*)pfnDelegate)(NULL);
```

### <a name="step-8---clean-up"></a><span data-ttu-id="567f5-258">Step 8: Bereinigen</span><span class="sxs-lookup"><span data-stu-id="567f5-258">Step 8 - Clean up</span></span>
<span data-ttu-id="567f5-259">Schließlich sollte der Host die Umgebung hinter sich bereinigen, indem er AppDomains entlädt, die Laufzeit beendet und den `ICLRRuntimeHost4`-Verweis freigibt.</span><span class="sxs-lookup"><span data-stu-id="567f5-259">Finally, the host should clean up after itself by unloading AppDomains, stopping the runtime, and releasing the `ICLRRuntimeHost4` reference.</span></span>

[!code-cpp[NetCoreHost#9](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithMscoree/host.cpp#9)]

<span data-ttu-id="567f5-260">CoreCLR unterstützt das Entladen nicht.</span><span class="sxs-lookup"><span data-stu-id="567f5-260">CoreCLR does not support unloading.</span></span> <span data-ttu-id="567f5-261">Die CoreCLR-Bibliothek darf nicht entladen werden.</span><span class="sxs-lookup"><span data-stu-id="567f5-261">Do not unload the CoreCLR library.</span></span>

## <a name="conclusion"></a><span data-ttu-id="567f5-262">Schlussbemerkung</span><span class="sxs-lookup"><span data-stu-id="567f5-262">Conclusion</span></span>
<span data-ttu-id="567f5-263">Nachdem Ihr Host erstellt wurde, kann er getestet werden, indem er über die Befehlszeile ausgeführt wird und Argumente übergeben werden, die der Host erwartet (z. B. die verwaltete App, die für den mscoree-Beispielhost ausgeführt werden soll).</span><span class="sxs-lookup"><span data-stu-id="567f5-263">Once your host is built, it can be tested by running it from the command line and passing any arguments the host expects (like the managed app to run for the mscoree example host).</span></span> <span data-ttu-id="567f5-264">Beim Angeben der .NET Core-Anwendung, die den Host ausführt, müssen Sie die DLL-Datei verwenden, die von `dotnet build` erzeugt wurde.</span><span class="sxs-lookup"><span data-stu-id="567f5-264">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="567f5-265">Ausführbare Dateien (EXE-Dateien), die für eigenständige Anwendungen von `dotnet publish` erstellt wurden, stellen die Standardeinstellung des .NET Core-Hosts dar, sodass die Anwendung in Hauptszenarios direkt über die Befehlszeile gestartet werden kann. Der Benutzercode wird in eine DLL-Datei mit dem gleichen Namen kompiliert.</span><span class="sxs-lookup"><span data-stu-id="567f5-265">Executables (.exe files) produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span>

<span data-ttu-id="567f5-266">Wenn anfangs Funktionsstörungen auftreten, überprüfen Sie, ob *coreclr.dll* an dem Speicherort zur Verfügung steht, den der Host erwartet, ob sich alle erforderlichen Frameworkbibliotheken in der TPA-Liste befinden und ob die CoreCLR-Bitanzahl (32-Bit oder 64-Bit) der Erstellungsart des Host entspricht.</span><span class="sxs-lookup"><span data-stu-id="567f5-266">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32-bit or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="567f5-267">Das Hosten der Laufzeit von .NET Core ist ein erweitertes Szenario, das für viele Entwickler nicht erforderlich ist, aber für diejenigen, die verwalteten Code von einem nativen Prozess starten müssen, oder die mehr Kontrolle über das Verhalten der .NET Core-Laufzeit benötigen, kann es sehr nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="567f5-267">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span>
