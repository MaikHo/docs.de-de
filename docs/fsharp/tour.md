---
title: Einführung in F#
description: 'Untersuchen Sie einige der wichtigsten Features der Programmiersprache F # in dieser Tour mit Codebeispielen.'
ms.date: 08/14/2020
ms.openlocfilehash: b115317e1f47ef7e18333cae4145b99e11645579
ms.sourcegitcommit: 8bfeb5930ca48b2ee6053f16082dcaf24d46d221
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/18/2020
ms.locfileid: "88558594"
---
# <a name="tour-of-f"></a><span data-ttu-id="e5a2c-103">Tour durch F\#</span><span class="sxs-lookup"><span data-stu-id="e5a2c-103">Tour of F\#</span></span>

<span data-ttu-id="e5a2c-104">Die beste Möglichkeit, um mehr über f # zu erfahren, ist das Lesen und Schreiben von f #-Code.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-104">The best way to learn about F# is to read and write F# code.</span></span> <span data-ttu-id="e5a2c-105">In diesem Artikel werden einige der wichtigsten Features der Programmiersprache F # vorgestellt, und Sie erhalten einige Code Ausschnitte, die Sie auf Ihrem Computer ausführen können.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-105">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span> <span data-ttu-id="e5a2c-106">Weitere Informationen zum Einrichten einer Entwicklungsumgebung finden Sie unter [Getting Started](get-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="e5a2c-106">To learn about setting up a development environment, check out [Getting Started](get-started/index.md).</span></span>

<span data-ttu-id="e5a2c-107">Es gibt zwei grundlegende Konzepte in F #: Functions und Types.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-107">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="e5a2c-108">In dieser Tour werden die Funktionen der Sprache hervorgehoben, die in diese beiden Konzepte einfließen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-108">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="executing-the-code-online"></a><span data-ttu-id="e5a2c-109">Online Ausführung des Codes</span><span class="sxs-lookup"><span data-stu-id="e5a2c-109">Executing the code online</span></span>

<span data-ttu-id="e5a2c-110">Wenn Sie f # nicht auf Ihrem Computer installiert haben, können Sie alle Beispiele in Ihrem Browser mit " [try F #" in Webassembly](https://tryfsharp.fsbolero.io/)ausführen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-110">If you don't have F# installed on your machine, you can execute all of the samples in your browser with [Try F# on WebAssembly](https://tryfsharp.fsbolero.io/).</span></span> <span data-ttu-id="e5a2c-111">Der Name ist ein Dialekt von F #, der direkt in Ihrem Browser ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-111">Fable is a dialect of F# that executes directly in your browser.</span></span> <span data-ttu-id="e5a2c-112">Um die Beispiele anzuzeigen, die in der repl befolgt werden, sehen Sie sich die **Beispiele > > Tour von F #** in der linken Menüleiste der ausführbaren repl an.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-112">To view the samples that follow in the REPL, check out **Samples > Learn > Tour of F#** in the left-hand menu bar of the Fable REPL.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="e5a2c-113">Funktionen und Module</span><span class="sxs-lookup"><span data-stu-id="e5a2c-113">Functions and Modules</span></span>

<span data-ttu-id="e5a2c-114">Die wichtigsten Bestandteile von F #-Programmen sind ***Funktionen*** , die in ***Modulen***organisiert sind.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-114">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="e5a2c-115">- [Funktionen](./language-reference/functions/index.md) führen Eingaben aus, um Ausgaben zu liefern, und Sie sind unter [Modulen](./language-reference/modules.md)organisiert. Dies ist die primäre Art und Weise, wie Sie Dinge in F # gruppieren.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-115">[Functions](./language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](./language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="e5a2c-116">Sie werden mit der- [ `let` Bindung](./language-reference/functions/let-bindings.md)definiert, die der Funktion einen Namen gibt und deren Argumente definieren.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-116">They are defined using the [`let` binding](./language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](~/samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="e5a2c-117">`let` Bindungen sind auch, wie Sie einen Wert an einen Namen binden, ähnlich wie eine Variable in anderen Sprachen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-117">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="e5a2c-118">`let` Bindungen sind standardmäßig ***unveränderlich*** , d. h., sobald ein Wert oder eine Funktion an einen Namen gebunden ist, kann er nicht direkt geändert werden.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-118">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="e5a2c-119">Dies steht im Gegensatz zu Variablen in anderen Sprachen, die ***änderbar***sind, was bedeutet, dass ihre Werte jederzeit geändert werden können.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-119">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="e5a2c-120">Wenn Sie eine änderbare Bindung benötigen, können Sie die- `let mutable ...` Syntax verwenden.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-120">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](~/samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="e5a2c-121">Zahlen, boolesche Werte und Zeichen folgen</span><span class="sxs-lookup"><span data-stu-id="e5a2c-121">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="e5a2c-122">Als .NET-Sprache unterstützt F # dieselben zugrunde liegenden [primitiven Typen](language-reference/basic-types.md) , die in .net vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-122">As a .NET language, F# supports the same underlying [primitive types](language-reference/basic-types.md) that exist in .NET.</span></span>

<span data-ttu-id="e5a2c-123">Im folgenden wird erläutert, wie verschiedene numerische Typen in F # dargestellt werden:</span><span class="sxs-lookup"><span data-stu-id="e5a2c-123">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](~/samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="e5a2c-124">Folgende boolesche Werte und die Durchführung der grundlegenden bedingten Logik werden wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="e5a2c-124">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](~/samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="e5a2c-125">Und hier sehen Sie, wie die grundlegende [Zeichen](./language-reference/strings.md) folgen Manipulation aussieht:</span><span class="sxs-lookup"><span data-stu-id="e5a2c-125">And here's what basic [string](./language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](~/samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="e5a2c-126">Tupel</span><span class="sxs-lookup"><span data-stu-id="e5a2c-126">Tuples</span></span>

<span data-ttu-id="e5a2c-127">[Tupel](./language-reference/tuples.md) sind eine große Menge in F #.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-127">[Tuples](./language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="e5a2c-128">Dabei handelt es sich um eine Gruppierung unbenannter, aber geordneter Werte, die als Werte selbst behandelt werden können.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-128">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="e5a2c-129">Betrachten Sie Sie als Werte, die von anderen Werten aggregiert werden.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-129">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="e5a2c-130">Sie haben viele Verwendungsmöglichkeiten, wie z. b. die bequeme Rückgabe von mehreren Werten aus einer Funktion oder das Gruppieren von Werten für einige Ad-hoc-Funktionen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-130">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="e5a2c-131">Sie können auch `struct` Tupel erstellen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-131">You can also create `struct` tuples.</span></span>  <span data-ttu-id="e5a2c-132">Diese arbeiten auch vollständig mit c# 7/Visual Basic 15 Tupeln zusammen, bei denen es sich auch um `struct` Tupel handelt:</span><span class="sxs-lookup"><span data-stu-id="e5a2c-132">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="e5a2c-133">Es ist wichtig zu beachten, dass `struct` Tupel Werttypen sind, dass Sie nicht implizit in verweistupel konvertiert werden können oder umgekehrt.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-133">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="e5a2c-134">Sie müssen explizit zwischen einem Verweis-und strukturtupel konvertieren.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-134">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="e5a2c-135">Pipelines und Komposition</span><span class="sxs-lookup"><span data-stu-id="e5a2c-135">Pipelines and Composition</span></span>

<span data-ttu-id="e5a2c-136">Pipe-Operatoren wie `|>` werden bei der Verarbeitung von Daten in F # ausgiebig verwendet.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-136">Pipe operators such as `|>` are used extensively when processing data in F#.</span></span> <span data-ttu-id="e5a2c-137">Diese Operatoren sind Funktionen, mit denen Sie auf flexible Weise "Pipelines" von Funktionen erstellen können.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-137">These operators are functions that allow you to establish "pipelines" of functions in a flexible manner.</span></span> <span data-ttu-id="e5a2c-138">Im folgenden Beispiel wird erläutert, wie Sie diese Operatoren nutzen können, um eine einfache Funktions Pipeline zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="e5a2c-138">The following example walks through how you can take advantage of these operators to build a simple functional pipeline:</span></span>

[!code-fsharp[Pipelines](~/samples/snippets/fsharp/tour.fs#L227-L282)]

<span data-ttu-id="e5a2c-139">Im vorherigen Beispiel wurden viele Funktionen von F # verwendet, einschließlich Listen Verarbeitungsfunktionen, erstklassige Funktionen und [partielle Anwendung](./language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="e5a2c-139">The previous sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](./language-reference/functions/index.md#partial-application-of-arguments).</span></span> <span data-ttu-id="e5a2c-140">Obwohl ein tiefgreifendes Verständnis der einzelnen Konzepte in gewisser Weise erweitert werden kann, sollte klar sein, wie einfach Funktionen zum Verarbeiten von Daten bei der Erstellung von Pipelines verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-140">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="e5a2c-141">Listen, Arrays und Sequenzen</span><span class="sxs-lookup"><span data-stu-id="e5a2c-141">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="e5a2c-142">Listen, Arrays und Sequenzen sind drei primäre Sammlungs Typen in der F #-Kernbibliothek.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-142">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="e5a2c-143">Listen sind geordnete, unveränderliche [Auflistungen](./language-reference/lists.md) von Elementen desselben Typs.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-143">[Lists](./language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="e5a2c-144">Dabei handelt es sich um einzeln verknüpfte Listen, was bedeutet, dass Sie für die Enumeration gedacht sind, aber eine schlechte Wahl für den zufälligen Zugriff und die Verkettung, wenn Sie groß sind.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-144">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="e5a2c-145">Dies steht im Gegensatz zu Listen in anderen gängigen Sprachen, die in der Regel keine einzeln verknüpfte Liste zur Darstellung von Listen verwenden.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-145">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](~/samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="e5a2c-146">[Arrays](./language-reference/arrays.md) sind *änderbare* Auflistungen von Elementen desselben Typs mit fester Größe.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-146">[Arrays](./language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="e5a2c-147">Sie unterstützen schnellen zufälligen Zugriff auf-Elemente und sind schneller als F #-Listen, da Sie nur zusammenhängende Speicherblöcke sind.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-147">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](~/samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="e5a2c-148">[Sequenzen](./language-reference/sequences.md) sind eine logische Reihe von Elementen, die alle denselben Typ haben.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-148">[Sequences](./language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="e5a2c-149">Dabei handelt es sich um einen allgemeineren Typ als Listen und Arrays, der in einer beliebigen logischen Reihenfolge von Elementen angezeigt werden kann.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-149">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="e5a2c-150">Sie stellen auch heraus, dass Sie ***träge***sein können, was bedeutet, dass Elemente nur dann berechnet werden können, wenn Sie benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-150">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](~/samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="e5a2c-151">Rekursive Funktionen</span><span class="sxs-lookup"><span data-stu-id="e5a2c-151">Recursive Functions</span></span>

<span data-ttu-id="e5a2c-152">Das Verarbeiten von Auflistungen oder Sequenzen von Elementen erfolgt in der Regel mit [Rekursion](./language-reference/functions/index.md#recursive-functions) in F #.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-152">Processing collections or sequences of elements is typically done with [recursion](./language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="e5a2c-153">Obwohl F # Unterstützung für Schleifen und imperative Programmierung bietet, wird die Rekursion bevorzugt, da es einfacher ist, Richtigkeit sicherzustellen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-153">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

> [!NOTE]
> <span data-ttu-id="e5a2c-154">Im folgenden Beispiel wird der Musterabgleich über den- `match` Ausdruck verwendet.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-154">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="e5a2c-155">Dieses grundlegende Konstrukt wird weiter unten in diesem Artikel behandelt.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-155">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](~/samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="e5a2c-156">F # bietet auch vollständige Unterstützung für die Optimierung des Endaufrufs. Dies ist eine Möglichkeit, rekursive Aufrufe so zu optimieren, dass Sie so schnell wie ein Schleifen Konstrukt sind.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-156">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="e5a2c-157">Datensatz und Unterscheidungs-Union-Typen</span><span class="sxs-lookup"><span data-stu-id="e5a2c-157">Record and Discriminated Union Types</span></span>

<span data-ttu-id="e5a2c-158">Datensatz-und Union-Typen sind zwei grundlegende Datentypen, die in f #-Code verwendet werden, und sind im Allgemeinen die beste Möglichkeit, um Daten in einem f #-Programm darzustellen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-158">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="e5a2c-159">Obwohl dies den Klassen in anderen Sprachen ähnelt, besteht einer der Hauptunterschiede darin, dass Sie über strukturelle Gleichheits Semantik verfügen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-159">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="e5a2c-160">Dies bedeutet, dass Sie "nativ" vergleichbar sind und die Gleichheit unkompliziert ist. Überprüfen Sie, ob eine solche gleich der anderen ist.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-160">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="e5a2c-161">[Datensätze](./language-reference/records.md) sind ein Aggregat benannter Werte mit optionalen Membern (z. b. Methoden).</span><span class="sxs-lookup"><span data-stu-id="e5a2c-161">[Records](./language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="e5a2c-162">Wenn Sie mit c# oder Java vertraut sind, sollten diese ähnlich wie POCOS oder POJOs aussehen, und zwar nur mit Struktur Gleichheit und weniger Zeremonien.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-162">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="e5a2c-163">Sie können auch Datensätze als Strukturen darstellen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-163">You can also represent Records as structs.</span></span> <span data-ttu-id="e5a2c-164">Dies erfolgt mit dem- `[<Struct>]` Attribut:</span><span class="sxs-lookup"><span data-stu-id="e5a2c-164">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="e5a2c-165">Unterscheidungs- [Unions (DUs)](./language-reference/discriminated-unions.md) sind Werte, die eine Anzahl benannter Formulare oder Fälle sein könnten.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-165">[Discriminated Unions (DUs)](./language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="e5a2c-166">Daten, die im-Typ gespeichert werden, können einen von mehreren unterschiedlichen Werten aufweisen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-166">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="e5a2c-167">Sie können auch die Unterscheidung nach *Groß-/Kleinschreibung*als Unterscheidungs-Unions verwenden, um die Domänen Modellierung über primitive Typen zu erleichtern</span><span class="sxs-lookup"><span data-stu-id="e5a2c-167">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="e5a2c-168">Häufig werden Zeichen folgen und andere primitive Typen verwendet, um etwas darzustellen, und erhalten daher eine bestimmte Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-168">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="e5a2c-169">Wenn Sie jedoch nur die primitive Darstellung der Daten verwenden, kann dies dazu führen, dass fälschlicherweise ein falscher Wert zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-169">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="e5a2c-170">Das darstellen der einzelnen Informationstypen als einzelne Union mit einem einzelnen Fall kann die Richtigkeit in diesem Szenario erzwingen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-170">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="e5a2c-171">Wie im obigen Beispiel gezeigt, müssen Sie, um den zugrunde liegenden Wert in einer Unterscheidungs-Union mit einem einzelnen Fall zu erhalten, den Wert explizit entpacken.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-171">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="e5a2c-172">Außerdem unterstützen Sie auch rekursive Definitionen, sodass Sie problemlos Strukturen und grundsätzlich rekursive Daten darstellen können.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-172">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="e5a2c-173">So können Sie z. b. eine binäre Such Struktur mit `exists` -und- `insert` Funktionen darstellen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-173">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="e5a2c-174">Da es Ihnen ermöglicht, die rekursive Struktur der Struktur im-Datentyp darzustellen, ist das Arbeiten mit dieser rekursiven Struktur unkompliziert und gewährleistet die Richtigkeit.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-174">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="e5a2c-175">Dies wird auch bei Musterabgleich unterstützt, wie unten dargestellt.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-175">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="e5a2c-176">Darüber hinaus können Sie mit dem-Attribut "DUs" als `struct` s darstellen `[<Struct>]` :</span><span class="sxs-lookup"><span data-stu-id="e5a2c-176">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="e5a2c-177">Dabei sind jedoch zwei wichtige Punkte zu beachten:</span><span class="sxs-lookup"><span data-stu-id="e5a2c-177">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="e5a2c-178">Eine Struktur-du kann nicht rekursiv definiert werden.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-178">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="e5a2c-179">Eine Struktur-du muss für jeden der Fälle eindeutige Namen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-179">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="e5a2c-180">Wenn Sie die obigen Schritte nicht ausführen, führt dies zu einem Kompilierungsfehler.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-180">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="e5a2c-181">Musterabgleich</span><span class="sxs-lookup"><span data-stu-id="e5a2c-181">Pattern Matching</span></span>

<span data-ttu-id="e5a2c-182">[Muster](./language-reference/pattern-matching.md) Abgleich ist das F #-sprach Feature, das die Richtigkeit für die Ausführung von f #-Typen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-182">[Pattern Matching](./language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="e5a2c-183">In den obigen Beispielen haben Sie wahrscheinlich eine gewisse `match x with ...` Syntax bemerkt.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-183">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="e5a2c-184">Dieses Konstrukt ermöglicht dem Compiler das Verständnis der Form von Datentypen, damit Sie alle möglichen Fälle bei der Verwendung eines Datentyps über den sogenannten vollständigen Musterabgleich berücksichtigen können.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-184">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="e5a2c-185">Dies ist äußerst leistungsstark für die Richtigkeit und kann geschickt verwendet werden, um zu überprüfen, was normalerweise für die Kompilierzeit von Bedeutung wäre.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-185">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](~/samples/snippets/fsharp/tour.fs#L705-L742)]

<span data-ttu-id="e5a2c-186">Vielleicht haben Sie bemerkt, dass das Muster verwendet wird `_` .</span><span class="sxs-lookup"><span data-stu-id="e5a2c-186">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="e5a2c-187">Dies wird als Platzhalter [Muster](./language-reference/pattern-matching.md#wildcard-pattern)bezeichnet. Dies ist eine Methode, die besagt, dass es sich nicht darum geht, was etwas ist.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-187">This is known as the [Wildcard Pattern](./language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="e5a2c-188">Obwohl es praktisch ist, können Sie versehentlich einen vollständigen Musterabgleich umgehen und nicht mehr von der Kompilierung der Kompilierung profitieren, wenn Sie nicht vorsichtig mit `_` der Verwendung von</span><span class="sxs-lookup"><span data-stu-id="e5a2c-188">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="e5a2c-189">Dies wird am besten verwendet, wenn Sie bei einem Musterabgleich bestimmte Teile eines aufgesetzten Typs nicht interessieren oder wenn Sie alle sinnvollen Fälle in einem Muster Vergleichs Ausdruck aufgezählt haben.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-189">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="e5a2c-190">Im folgenden Beispiel wird der- `_` Fall verwendet, wenn bei einem Analyse Vorgang ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-190">In the following example, the `_` case is used when a parse operation fails.</span></span>

[!code-fsharp[PatternMatching](~/samples/snippets/fsharp/tour.fs#L744-L762)]

<span data-ttu-id="e5a2c-191">[Aktive Muster](./language-reference/active-patterns.md) sind ein weiteres leistungsfähiges Konstrukt, das mit dem Muster Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-191">[Active Patterns](./language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="e5a2c-192">Sie ermöglichen es Ihnen, Eingabedaten in benutzerdefinierte Formulare zu partitionieren</span><span class="sxs-lookup"><span data-stu-id="e5a2c-192">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="e5a2c-193">Sie können auch parametrisiert werden, sodass die Partition als Funktion definiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-193">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="e5a2c-194">Die Erweiterung des vorherigen Beispiels zur Unterstützung von aktiven Mustern sieht in etwa wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="e5a2c-194">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](~/samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a><span data-ttu-id="e5a2c-195">Optionale Typen</span><span class="sxs-lookup"><span data-stu-id="e5a2c-195">Optional Types</span></span>

<span data-ttu-id="e5a2c-196">Ein Sonderfall von Unterscheidungs-Union-Typen ist der Optionstyp, der so nützlich ist, dass er Teil der F #-Kernbibliothek ist.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-196">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="e5a2c-197">[Der Optionstyp](./language-reference/options.md) ist ein Typ, der einen von zwei Fällen darstellt: einen Wert oder überhaupt nichts.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-197">[The Option Type](./language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="e5a2c-198">Sie wird in jedem Szenario verwendet, in dem ein Wert von einem bestimmten Vorgang abgeleitet werden kann oder nicht.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-198">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="e5a2c-199">Dadurch werden Sie gezwungen, beide Fälle zu berücksichtigen, sodass es zu einem Kompilierzeit-und nicht zur Laufzeit-Problem wird.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-199">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="e5a2c-200">Diese werden häufig in APIs verwendet, bei denen `null` anstelle von "Nothing" verwendet wird. auf diese Weise entfällt die Notwendigkeit, sich `NullReferenceException` in vielen Fällen Gedanken zu machen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-200">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](~/samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a><span data-ttu-id="e5a2c-201">Maßeinheiten</span><span class="sxs-lookup"><span data-stu-id="e5a2c-201">Units of Measure</span></span>

<span data-ttu-id="e5a2c-202">Eine einzigartige Funktion des Typsystems von F # ist die Möglichkeit, mit Maßeinheiten Kontext für numerische Literale bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-202">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="e5a2c-203">[Maßeinheiten](./language-reference/units-of-measure.md) ermöglichen das Zuordnen eines numerischen Typs zu einer Einheit, z. b. "Meter" und die Ausführung von Funktionen für Einheiten statt für numerische Literale.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-203">[Units of Measure](./language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="e5a2c-204">Dadurch kann der Compiler überprüfen, ob die Typen von numerischen Literalen, die in einem bestimmten Kontext verwendet werden, sinnvoll sind. Dadurch werden Laufzeitfehler, die dieser Art von Arbeit zugeordnet sind, beseitigt.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-204">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](~/samples/snippets/fsharp/tour.fs#L817-L842)]

<span data-ttu-id="e5a2c-205">Die F #-Kernbibliothek definiert viele SI-Einheiten Typen und Einheiten Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-205">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="e5a2c-206">Weitere Informationen finden Sie unter [FSharp. Data. unitsystems. si. unitsymbols-Namespace](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-data-unitsystems-si-unitsymbols.html).</span><span class="sxs-lookup"><span data-stu-id="e5a2c-206">To learn more, check out the [FSharp.Data.UnitSystems.SI.UnitSymbols Namespace](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-data-unitsystems-si-unitsymbols.html).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="e5a2c-207">Klassen und Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="e5a2c-207">Classes and Interfaces</span></span>

<span data-ttu-id="e5a2c-208">F # bietet auch vollständige Unterstützung für .NET-Klassen,- [Schnittstellen](./language-reference/interfaces.md), [abstrakte Klassen](./language-reference/abstract-classes.md), [Vererbung](./language-reference/inheritance.md)usw.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-208">F# also has full support for .NET classes, [Interfaces](./language-reference/interfaces.md), [Abstract Classes](./language-reference/abstract-classes.md), [Inheritance](./language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="e5a2c-209">[Klassen](./language-reference/classes.md) sind Typen, die .NET-Objekte darstellen, die Eigenschaften, Methoden und Ereignisse als Member aufweisen [können.](./language-reference/members/index.md)</span><span class="sxs-lookup"><span data-stu-id="e5a2c-209">[Classes](./language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](./language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L845-L880)]

<span data-ttu-id="e5a2c-210">Das Definieren von generischen Klassen ist ebenfalls sehr unkompliziert.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-210">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L883-L908)]

<span data-ttu-id="e5a2c-211">Um eine Schnittstelle zu implementieren, können Sie entweder `interface ... with` Syntax oder einen [Objekt Ausdruck](./language-reference/object-expressions.md)verwenden.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-211">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](./language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a><span data-ttu-id="e5a2c-212">Zu verwendende Typen</span><span class="sxs-lookup"><span data-stu-id="e5a2c-212">Which Types to Use</span></span>

<span data-ttu-id="e5a2c-213">Das vorhanden sein von Klassen, Datensätzen, Unterscheidungs-Unions und Tupeln führt zu einer wichtigen Frage: welche sollten Sie verwenden?</span><span class="sxs-lookup"><span data-stu-id="e5a2c-213">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="e5a2c-214">Wie die meisten Elemente in der Lebensdauer hängt die Antwort von Ihren Umständen ab.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-214">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="e5a2c-215">Tupel eignen sich hervorragend für die Rückgabe mehrerer Werte aus einer Funktion und die Verwendung eines Ad-hoc-Aggregats von Werten als Wert selbst.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-215">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="e5a2c-216">Datensätze sind ein "schrittweise" aus Tupeln mit benannten Bezeichnungen und Unterstützung Optionaler Member.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-216">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="e5a2c-217">Sie eignen sich hervorragend für eine Low-Ceremony-Darstellung der Daten während der Übertragung durch das Programm.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-217">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="e5a2c-218">Da Sie Struktur Gleichheit aufweisen, können Sie mit dem Vergleich leicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-218">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="e5a2c-219">Unterscheidungs-Unions haben viele Verwendungsmöglichkeiten, aber der Hauptvorteil besteht darin, Sie in Verbindung mit dem Musterabgleich zu verwenden, um alle möglichen "Formen" zu berücksichtigen, die eine Daten aufweisen kann.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-219">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="e5a2c-220">Klassen sind aus vielen Gründen sehr nützlich, z. b. Wenn Sie Informationen darstellen und diese Informationen auch an die Funktionalität binden müssen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-220">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="e5a2c-221">Als Faustregel gilt: Wenn Sie über Funktionen verfügen, die konzeptionell an einige Daten gebunden sind, ist die Verwendung von Klassen und den Prinzipien der objektorientierten Programmierung ein großer Vorteil.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-221">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="e5a2c-222">Klassen sind auch der bevorzugte Datentyp bei der Interaktion mit c# und Visual Basic, da diese Sprachen Klassen für fast alles verwenden.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-222">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="e5a2c-223">Nächste Schritte</span><span class="sxs-lookup"><span data-stu-id="e5a2c-223">Next Steps</span></span>

<span data-ttu-id="e5a2c-224">Nachdem Sie nun einige der primären Features der Sprache kennen gelernt haben, sollten Sie Ihre ersten F #-Programme schreiben!</span><span class="sxs-lookup"><span data-stu-id="e5a2c-224">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="e5a2c-225">Weitere Informationen zum Einrichten der Entwicklungsumgebung und zum Schreiben von Code finden Sie unter [Getting Started](get-started/index.md) .</span><span class="sxs-lookup"><span data-stu-id="e5a2c-225">Check out [Getting Started](get-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="e5a2c-226">Wenn Sie mehr erfahren möchten, können Sie die nächsten Schritte ausführen, aber wir empfehlen Ihnen die Einführung in die [funktionale Programmierung in F #](./introduction-to-functional-programming/index.md) , um sich mit den grundlegenden Konzepten der funktionalen Programmierung vertraut zu machen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-226">The next steps for learning more can be whatever you like, but we recommend [Introduction to Functional Programming in F#](./introduction-to-functional-programming/index.md) to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="e5a2c-227">Diese sind für die Aufbau robuster Programme in F # von entscheidender Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-227">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="e5a2c-228">Sehen Sie sich auch die [f #-Sprachreferenz](./language-reference/index.md) an, um eine umfassende Sammlung von konzeptionellen Inhalten zu f # anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="e5a2c-228">Also, check out the [F# Language Reference](./language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
