---
title: Asynchrone Workflows
description: 'Erfahren Sie mehr über die Unterstützung in der Programmiersprache F # zum asynchronen Ausführen von Berechnungen, die ohne Blockierung der Ausführung anderer Aufgaben ausgeführt werden.'
ms.date: 08/15/2020
ms.openlocfilehash: 14146cc8a643f31831475075212cc06da5f8d6ff
ms.sourcegitcommit: fe8877e564deb68d77fa4b79f55584ac8d7e8997
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/17/2020
ms.locfileid: "90720269"
---
# <a name="asynchronous-workflows"></a><span data-ttu-id="0ee71-103">Asynchrone Workflows</span><span class="sxs-lookup"><span data-stu-id="0ee71-103">Asynchronous workflows</span></span>

<span data-ttu-id="0ee71-104">In diesem Artikel wird die Unterstützung von F # zum asynchronen Ausführen von Berechnungen beschrieben, d. h. ohne die Ausführung anderer Aufgaben zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="0ee71-104">This article describes support in F# for performing computations asynchronously, that is, without blocking execution of other work.</span></span> <span data-ttu-id="0ee71-105">So können z. b. asynchrone Berechnungen verwendet werden, um Anwendungen zu schreiben, die über Benutzeroberflächen verfügen, die für Benutzer reaktionsfähig bleiben, während die Anwendung andere Aufgaben ausführt.</span><span class="sxs-lookup"><span data-stu-id="0ee71-105">For example, asynchronous computations can be used to write applications that have UIs that remain responsive to users as the application performs other work.</span></span>

## <a name="syntax"></a><span data-ttu-id="0ee71-106">Syntax</span><span class="sxs-lookup"><span data-stu-id="0ee71-106">Syntax</span></span>

```fsharp
async { expression }
```

## <a name="remarks"></a><span data-ttu-id="0ee71-107">Bemerkungen</span><span class="sxs-lookup"><span data-stu-id="0ee71-107">Remarks</span></span>

<span data-ttu-id="0ee71-108">In der vorherigen Syntax wird die durch dargestellte Berechnung `expression` so eingerichtet, dass Sie asynchron ausgeführt wird, d. h., ohne den aktuellen Berechnungs Thread zu blockieren, wenn asynchrone standbyvorgänge, e/a-Vorgänge und andere asynchrone Vorgänge ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="0ee71-108">In the previous syntax, the computation represented by `expression` is set up to run asynchronously, that is, without blocking the current computation thread when asynchronous sleep operations, I/O, and other asynchronous operations are performed.</span></span> <span data-ttu-id="0ee71-109">Asynchrone Berechnungen werden häufig in einem Hintergrund Thread gestartet, während die Ausführung im aktuellen Thread fortgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="0ee71-109">Asynchronous computations are often started on a background thread while execution continues on the current thread.</span></span> <span data-ttu-id="0ee71-110">Der Typ des Ausdrucks ist `Async<'T>` , wobei `'T` der Typ ist, der von dem Ausdruck zurückgegeben wird, wenn das `return` Schlüsselwort verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="0ee71-110">The type of the expression is `Async<'T>`, where `'T` is the type returned by the expression when the `return` keyword is used.</span></span> <span data-ttu-id="0ee71-111">Der Code in einem solchen Ausdruck wird als *asynchroner Block*oder *Async-Block*bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="0ee71-111">The code in such an expression is referred to as an *asynchronous block*, or *async block*.</span></span>

<span data-ttu-id="0ee71-112">Es gibt eine Vielzahl von Methoden zur asynchronen Programmierung, und die- [`Async`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html) Klasse stellt Methoden bereit, die verschiedene Szenarien unterstützen.</span><span class="sxs-lookup"><span data-stu-id="0ee71-112">There are a variety of ways of programming asynchronously, and the [`Async`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html) class provides methods that support several scenarios.</span></span> <span data-ttu-id="0ee71-113">Die allgemeine Vorgehensweise besteht darin, Objekte zu erstellen `Async` , die die Berechnung oder Berechnungen darstellen, die Sie asynchron ausführen möchten, und dann diese Berechnungen mithilfe einer der auslösenden Funktionen zu starten.</span><span class="sxs-lookup"><span data-stu-id="0ee71-113">The general approach is to create `Async` objects that represent the computation or computations that you want to run asynchronously, and then start these computations by using one of the triggering functions.</span></span> <span data-ttu-id="0ee71-114">Die verschiedenen auslösenden Funktionen bieten verschiedene Möglichkeiten, asynchrone Berechnungen auszuführen, und welche Sie verwenden, hängt davon ab, ob Sie den aktuellen Thread, einen Hintergrund Thread oder ein .NET Framework Aufgaben Objekt verwenden möchten und ob Fortsetzungs Funktionen vorhanden sind, die nach Abschluss der Berechnung ausgeführt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="0ee71-114">The various triggering functions provide different ways of running asynchronous computations, and which one you use depends on whether you want to use the current thread, a background thread, or a .NET Framework task object, and whether there are continuation functions that should run when the computation finishes.</span></span> <span data-ttu-id="0ee71-115">Um z. b. eine asynchrone Berechnung für den aktuellen Thread zu starten, können Sie verwenden [`Async.StartImmediate`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html#StartImmediate) .</span><span class="sxs-lookup"><span data-stu-id="0ee71-115">For example, to start an asynchronous computation on the current thread, you can use [`Async.StartImmediate`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html#StartImmediate).</span></span> <span data-ttu-id="0ee71-116">Wenn Sie eine asynchrone Berechnung aus dem UI-Thread starten, blockieren Sie die Hauptereignis Schleife nicht, die Benutzeraktionen verarbeitet, wie z. b. Tastatureingaben und Maus Aktivitäten, sodass Ihre Anwendung reaktionsfähig bleibt.</span><span class="sxs-lookup"><span data-stu-id="0ee71-116">When you start an asynchronous computation from the UI thread, you do not block the main event loop that processes user actions such as keystrokes and mouse activity, so your application remains responsive.</span></span>

## <a name="asynchronous-binding-by-using-let"></a><span data-ttu-id="0ee71-117">Asynchrone Bindung mithilfe von Let!</span><span class="sxs-lookup"><span data-stu-id="0ee71-117">Asynchronous Binding by Using let!</span></span>

<span data-ttu-id="0ee71-118">In einem asynchronen Workflow sind einige Ausdrücke und Vorgänge synchron, und einige sind längere Berechnungen, die so entworfen wurden, dass ein Ergebnis asynchron zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0ee71-118">In an asynchronous workflow, some expressions and operations are synchronous, and some are longer computations that are designed to return a result asynchronously.</span></span> <span data-ttu-id="0ee71-119">Wenn Sie eine Methode asynchron anstelle einer normalen Bindung aufzurufen `let` , verwenden Sie `let!` .</span><span class="sxs-lookup"><span data-stu-id="0ee71-119">When you call a method asynchronously, instead of an ordinary `let` binding, you use `let!`.</span></span> <span data-ttu-id="0ee71-120">Der Effekt von `let!` besteht darin, die Ausführung zu aktivieren, damit andere Berechnungen oder Threads fortgesetzt werden, während die Berechnung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="0ee71-120">The effect of `let!` is to enable execution to continue on other computations or threads as the computation is being performed.</span></span> <span data-ttu-id="0ee71-121">Nachdem die Rechte Seite der `let!` Bindung zurückgegeben wurde, wird der Rest des asynchronen Workflows die Ausführung fortsetzen.</span><span class="sxs-lookup"><span data-stu-id="0ee71-121">After the right side of the `let!` binding returns, the rest of the asynchronous workflow resumes execution.</span></span>

<span data-ttu-id="0ee71-122">Der folgende Code zeigt den Unterschied zwischen `let` und `let!` .</span><span class="sxs-lookup"><span data-stu-id="0ee71-122">The following code shows the difference between `let` and `let!`.</span></span> <span data-ttu-id="0ee71-123">Die Codezeile, in der nur verwendet wird, `let` erstellt eine asynchrone Berechnung als Objekt, das Sie später mithilfe von ausführen können, `Async.StartImmediate` z [`Async.RunSynchronously`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html#RunSynchronously) . b. oder.</span><span class="sxs-lookup"><span data-stu-id="0ee71-123">The line of code that uses `let` just creates an asynchronous computation as an object that you can run later by using, for example, `Async.StartImmediate` or [`Async.RunSynchronously`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html#RunSynchronously).</span></span> <span data-ttu-id="0ee71-124">Die Codezeile, in der verwendet wird `let!` , startet die Berechnung, und der Thread wird angehalten, bis das Ergebnis verfügbar ist, bei dem die Ausführung fortgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="0ee71-124">The line of code that uses `let!` starts the computation, and then the thread is suspended until the result is available, at which point execution continues.</span></span>

```fsharp
// let just stores the result as an asynchronous operation.
let (result1 : Async<byte[]>) = stream.AsyncRead(bufferSize)
// let! completes the asynchronous operation and returns the data.
let! (result2 : byte[])  = stream.AsyncRead(bufferSize)
```

<span data-ttu-id="0ee71-125">Zusätzlich zu `let!` können Sie verwenden, `use!` um asynchrone Bindungen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="0ee71-125">In addition to `let!`, you can use `use!` to perform asynchronous bindings.</span></span> <span data-ttu-id="0ee71-126">Der Unterschied zwischen `let!` und `use!` ist mit dem Unterschied zwischen `let` und identisch `use` .</span><span class="sxs-lookup"><span data-stu-id="0ee71-126">The difference between `let!` and `use!` is the same as the difference between `let` and `use`.</span></span> <span data-ttu-id="0ee71-127">Für `use!` wird das-Objekt am Ende des aktuellen Gültigkeits Bereichs verworfen.</span><span class="sxs-lookup"><span data-stu-id="0ee71-127">For `use!`, the object is disposed of at the close of the current scope.</span></span> <span data-ttu-id="0ee71-128">Beachten Sie, dass in der aktuellen Version der Sprache F # `use!` es nicht zulässt, dass ein Wert mit NULL initialisiert wird, auch wenn `use` dies nicht möglich ist.</span><span class="sxs-lookup"><span data-stu-id="0ee71-128">Note that in the current release of the F# language, `use!` does not allow a value to be initialized to null, even though `use` does.</span></span>

## <a name="asynchronous-primitives"></a><span data-ttu-id="0ee71-129">Asynchrone primitive</span><span class="sxs-lookup"><span data-stu-id="0ee71-129">Asynchronous Primitives</span></span>

<span data-ttu-id="0ee71-130">Eine Methode, die eine einzelne asynchrone Aufgabe ausführt und das Ergebnis zurückgibt, wird als *asynchroner primitiv*bezeichnet und ist speziell für die Verwendung mit konzipiert `let!` .</span><span class="sxs-lookup"><span data-stu-id="0ee71-130">A method that performs a single asynchronous task and returns the result is called an *asynchronous primitive*, and these are designed specifically for use with `let!`.</span></span> <span data-ttu-id="0ee71-131">Mehrere asynchrone primitive sind in der F #-Kernbibliothek definiert.</span><span class="sxs-lookup"><span data-stu-id="0ee71-131">Several asynchronous primitives are defined in the F# core library.</span></span> <span data-ttu-id="0ee71-132">Zwei dieser Methoden für Webanwendungen werden im-Modul definiert [`FSharp.Control.WebExtensions`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-webextensions.html) : [`WebRequest.AsyncGetResponse`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-webextensions.html#AsyncGetResponse) und [`WebClient.AsyncDownloadString`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-webextensions.html#AsyncDownloadString) .</span><span class="sxs-lookup"><span data-stu-id="0ee71-132">Two such methods for Web applications are defined in the module [`FSharp.Control.WebExtensions`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-webextensions.html): [`WebRequest.AsyncGetResponse`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-webextensions.html#AsyncGetResponse) and [`WebClient.AsyncDownloadString`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-webextensions.html#AsyncDownloadString).</span></span> <span data-ttu-id="0ee71-133">Beide primitiven laden Daten von einer Webseite herunter, wenn eine URL angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="0ee71-133">Both primitives download data from a Web page, given a URL.</span></span> <span data-ttu-id="0ee71-134">`AsyncGetResponse` erzeugt ein `System.Net.WebResponse` -Objekt und `AsyncDownloadString` erstellt eine Zeichenfolge, die den HTML-Code für eine Webseite darstellt.</span><span class="sxs-lookup"><span data-stu-id="0ee71-134">`AsyncGetResponse` produces a `System.Net.WebResponse` object, and `AsyncDownloadString` produces a string that represents the HTML for a Web page.</span></span>

<span data-ttu-id="0ee71-135">Im Modul sind mehrere primitive für asynchrone e/a-Vorgänge enthalten [`FSharp.Control.CommonExtensions`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-commonextensions.html) .</span><span class="sxs-lookup"><span data-stu-id="0ee71-135">Several primitives for asynchronous I/O operations are included in the [`FSharp.Control.CommonExtensions`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-commonextensions.html) module.</span></span> <span data-ttu-id="0ee71-136">Diese Erweiterungs Methoden der `System.IO.Stream` -Klasse sind [`Stream.AsyncRead`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-commonextensions.html#AsyncRead) und [`Stream.AsyncWrite`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-commonextensions.html#AsyncWrite) .</span><span class="sxs-lookup"><span data-stu-id="0ee71-136">These extension methods of the `System.IO.Stream` class are [`Stream.AsyncRead`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-commonextensions.html#AsyncRead) and [`Stream.AsyncWrite`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-commonextensions.html#AsyncWrite).</span></span>

<span data-ttu-id="0ee71-137">Sie können auch eigene asynchrone primitive schreiben, indem Sie eine Funktion definieren, deren kompletter Text in einen Async-Block eingeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="0ee71-137">You can also write your own asynchronous primitives by defining a function whose complete body is enclosed in an async block.</span></span>

<span data-ttu-id="0ee71-138">Um asynchrone Methoden in den .NET Framework zu verwenden, die für andere asynchrone Modelle mit dem asynchronen F #-Programmiermodell entwickelt wurden, erstellen Sie eine Funktion, die ein f #-Objekt zurückgibt `Async` .</span><span class="sxs-lookup"><span data-stu-id="0ee71-138">To use asynchronous methods in the .NET Framework that are designed for other asynchronous models with the F# asynchronous programming model, you create a function that returns an F# `Async` object.</span></span> <span data-ttu-id="0ee71-139">Die F #-Bibliothek verfügt über Funktionen, die dies erleichtern.</span><span class="sxs-lookup"><span data-stu-id="0ee71-139">The F# library has functions that make this easy to do.</span></span>

<span data-ttu-id="0ee71-140">Ein Beispiel für die Verwendung von asynchronen Workflows finden Sie hier: in der Dokumentation finden Sie viele weitere Informationen zu den Methoden der [Async-Klasse](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html).</span><span class="sxs-lookup"><span data-stu-id="0ee71-140">One example of using asynchronous workflows is included here; there are many others in the documentation for the methods of the [Async class](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html).</span></span>

<span data-ttu-id="0ee71-141">In diesem Beispiel wird gezeigt, wie asynchrone Workflows verwendet werden, um Berechnungen parallel auszuführen.</span><span class="sxs-lookup"><span data-stu-id="0ee71-141">This example shows how to use asynchronous workflows to perform computations in parallel.</span></span>

<span data-ttu-id="0ee71-142">Im folgenden Codebeispiel ruft eine Funktion `fetchAsync` den HTML-Text ab, der von einer Webanforderung zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="0ee71-142">In the following code example, a function `fetchAsync` gets the HTML text returned from a Web request.</span></span> <span data-ttu-id="0ee71-143">Die- `fetchAsync` Funktion enthält einen asynchronen Codeblock.</span><span class="sxs-lookup"><span data-stu-id="0ee71-143">The `fetchAsync` function contains an asynchronous block of code.</span></span> <span data-ttu-id="0ee71-144">Wenn eine Bindung an das Ergebnis eines asynchronen primitiven erfolgt, wird in diesem Fall [`AsyncDownloadString`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-webextensions.html#AsyncDownloadString) `let!` anstelle von verwendet `let` .</span><span class="sxs-lookup"><span data-stu-id="0ee71-144">When a binding is made to the result of an asynchronous primitive, in this case [`AsyncDownloadString`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-webextensions.html#AsyncDownloadString), `let!` is used instead of `let`.</span></span>

<span data-ttu-id="0ee71-145">Sie verwenden die [`Async.RunSynchronously`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html#RunSynchronously) -Funktion, um einen asynchronen Vorgang auszuführen und auf das Ergebnis zu warten.</span><span class="sxs-lookup"><span data-stu-id="0ee71-145">You use the function [`Async.RunSynchronously`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html#RunSynchronously) to execute an asynchronous operation and wait for its result.</span></span> <span data-ttu-id="0ee71-146">Beispielsweise können Sie mehrere asynchrone Vorgänge parallel ausführen, indem Sie die- [`Async.Parallel`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html#Parallel) Funktion zusammen mit der- `Async.RunSynchronously` Funktion verwenden.</span><span class="sxs-lookup"><span data-stu-id="0ee71-146">As an example, you can execute multiple asynchronous operations in parallel by using the [`Async.Parallel`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html#Parallel) function together with the `Async.RunSynchronously` function.</span></span> <span data-ttu-id="0ee71-147">Die- `Async.Parallel` Funktion nimmt eine Liste der- `Async` Objekte an, richtet den Code für jedes `Async` Aufgaben Objekt so ein, dass Sie parallel ausgeführt wird, und gibt ein Objekt zurück, `Async` das die parallele Berechnung darstellt.</span><span class="sxs-lookup"><span data-stu-id="0ee71-147">The `Async.Parallel` function takes a list of the `Async` objects, sets up the code for each `Async` task object to run in parallel, and returns an `Async` object that represents the parallel computation.</span></span> <span data-ttu-id="0ee71-148">Ebenso wie bei einem einzelnen Vorgang wird aufgerufen, `Async.RunSynchronously` um die Ausführung zu starten.</span><span class="sxs-lookup"><span data-stu-id="0ee71-148">Just as for a single operation, you call `Async.RunSynchronously` to start the execution.</span></span>

<span data-ttu-id="0ee71-149">Die `runAll` -Funktion gestartet parallel drei asynchrone Workflows und wartet, bis alle abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="0ee71-149">The `runAll` function launches three asynchronous workflows in parallel and waits until they have all completed.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet8003.fs)]

## <a name="see-also"></a><span data-ttu-id="0ee71-150">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="0ee71-150">See also</span></span>

- [<span data-ttu-id="0ee71-151">F#-Sprachreferenz</span><span class="sxs-lookup"><span data-stu-id="0ee71-151">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="0ee71-152">Berechnungsausdrücke</span><span class="sxs-lookup"><span data-stu-id="0ee71-152">Computation Expressions</span></span>](computation-expressions.md)
- [<span data-ttu-id="0ee71-153">Control. Async-Klasse</span><span class="sxs-lookup"><span data-stu-id="0ee71-153">Control.Async Class</span></span>](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-control-fsharpasync.html)
