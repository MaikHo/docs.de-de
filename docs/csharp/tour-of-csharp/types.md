---
title: 'Einführung in C#: Definieren von Typen und ihren Membern'
description: Die Bausteine für Programme sind Typen. Hier erfahren Sie, wie Sie Klassen, Strukturen, Schnittstellen und mehr in C# erstellen.
ms.date: 08/06/2020
ms.openlocfilehash: 69d6f0fe1e11f287fb5e385761fc210a61929d10
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 08/11/2020
ms.locfileid: "88068465"
---
# <a name="types-and-members"></a><span data-ttu-id="5d1c6-104">Typen und Member</span><span class="sxs-lookup"><span data-stu-id="5d1c6-104">Types and members</span></span>

## <a name="classes-and-objects"></a><span data-ttu-id="5d1c6-105">Klassen und Objekte</span><span class="sxs-lookup"><span data-stu-id="5d1c6-105">Classes and objects</span></span>

<span data-ttu-id="5d1c6-106">*Klassen* sind die grundlegendsten der C#-Typen.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="5d1c6-107">Eine Klasse ist eine Datenstruktur, die einen Zustand (Felder) und Aktionen (Methoden und andere Funktionsmember) in einer einzigen Einheit kombiniert.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="5d1c6-108">Eine Klasse stellt eine Definition für *Instanzen* der Klasse bereit, die auch *Objekte* genannt werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-108">A class provides a definition for *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="5d1c6-109">Klassen unterstützen *Vererbung* und *Polymorphie*. Dies sind Mechanismen, durch die *abgeleitete Klassen* erweitert und *Basisklassen* spezialisiert werden können.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="5d1c6-110">Neue Klassen werden mithilfe von Klassendeklarationen erstellt.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-110">New classes are created using class declarations.</span></span> <span data-ttu-id="5d1c6-111">Eine Klassendeklaration beginnt mit einem Header.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-111">A class declaration starts with a header.</span></span> <span data-ttu-id="5d1c6-112">Der Header legt Folgendes fest:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-112">The header specifies:</span></span>

- <span data-ttu-id="5d1c6-113">Die Attribute und Modifizierer der Klasse</span><span class="sxs-lookup"><span data-stu-id="5d1c6-113">The attributes and modifiers of the class</span></span>
- <span data-ttu-id="5d1c6-114">Den Namen der Klasse</span><span class="sxs-lookup"><span data-stu-id="5d1c6-114">The name of the class</span></span>
- <span data-ttu-id="5d1c6-115">Die Basisklasse (wenn von einer [Basisklasse](#base-classes) geerbt wird)</span><span class="sxs-lookup"><span data-stu-id="5d1c6-115">The base class (when inheriting from a [base class](#base-classes))</span></span>
- <span data-ttu-id="5d1c6-116">Die von der Klasse implementierten Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="5d1c6-116">The interfaces implemented by the class.</span></span>

<span data-ttu-id="5d1c6-117">Auf den Header folgt der Klassenkörper. Dieser besteht aus einer Liste der Memberdeklarationen, die zwischen den Trennzeichen `{` und `}` eingefügt werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-117">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="5d1c6-118">Im folgenden Code wird die Deklaration einer einfachen Klasse namens `Point` veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-118">The following code shows a declaration of a simple class named `Point`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

<span data-ttu-id="5d1c6-119">Instanzen von Klassen werden mit dem `new`-Operator erstellt. Dieser reserviert Speicher für eine neue Instanz, ruft einen Konstruktor zum Initialisieren der Instanz auf und gibt einen Verweis auf die Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-119">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="5d1c6-120">Mit den folgenden Anweisungen werden zwei `Point`-Objekte erstellt und Verweise auf diese Objekte in zwei Variablen gespeichert:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-120">The following statements create two `Point` objects and store references to those objects in two variables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

<span data-ttu-id="5d1c6-121">Der von einem Objekt belegte Speicher wird automatisch wieder freigegeben, wenn das Objekt nicht mehr erreichbar ist.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-121">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="5d1c6-122">Es ist weder erforderlich noch möglich, die Zuweisung von Objekten in C# explizit aufzuheben.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-122">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

### <a name="type-parameters"></a><span data-ttu-id="5d1c6-123">Typparameter</span><span class="sxs-lookup"><span data-stu-id="5d1c6-123">Type parameters</span></span>

<span data-ttu-id="5d1c6-124">Generische Typparameter definieren [***Typparameter***](../programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="5d1c6-124">Generic classes define [***type parameters***](../programming-guide/generics/index.md).</span></span> <span data-ttu-id="5d1c6-125">Typparameter sind eine Liste von Typparameternamen, die in spitzen Klammern enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-125">Type parameters are a list of type parameter names enclosed in angle brackets.</span></span> <span data-ttu-id="5d1c6-126">Typparameter folgen auf den Klassennamen.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-126">Type parameters follow the class name.</span></span> <span data-ttu-id="5d1c6-127">Die Typparameter können dann im Körper der Klassendeklarationen zum Definieren der Klassenmember verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-127">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="5d1c6-128">Im folgenden Beispiel lauten die Typparameter von `Pair``TFirst` und `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-128">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

<span data-ttu-id="5d1c6-129">Ein Klassentyp, der zum Akzeptieren von Typparametern deklariert wird, wird als *generischer Klassentyp* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-129">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="5d1c6-130">Struktur-, Schnittstellen- und Delegattypen können auch generisch sein.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-130">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="5d1c6-131">Wenn die generische Klasse verwendet wird, müssen für jeden der Typparameter Typargumente angegeben werden:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-131">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

<span data-ttu-id="5d1c6-132">Ein generischer Typ, für den Typargumente angegeben wurden (siehe `Pair<int,string>` oben), wird als *konstruierter Typ* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-132">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

### <a name="base-classes"></a><span data-ttu-id="5d1c6-133">Basisklassen</span><span class="sxs-lookup"><span data-stu-id="5d1c6-133">Base classes</span></span>

<span data-ttu-id="5d1c6-134">Mit einer Klassendeklaration kann eine Basisklasse angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-134">A class declaration may specify a base class.</span></span> <span data-ttu-id="5d1c6-135">Fügen Sie nach dem Klassennamen und den Typparametern einen Doppelpunkt und den Namen der Basisklasse ein.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-135">Follow the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="5d1c6-136">Das Auslassen einer Basisklassenspezifikation ist dasselbe wie eine Ableitung vom Typ `object`.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-136">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="5d1c6-137">Im folgenden Beispiel ist `Point` die Basisklasse von `Point3D`.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-137">In the following example, the base class of `Point3D` is `Point`.</span></span> <span data-ttu-id="5d1c6-138">Im folgenden ersten Beispiel ist `object` die Basisklasse von `Point`:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-138">From the first example, the base class of `Point` is `object`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

<span data-ttu-id="5d1c6-139">Eine Klasse erbt die Member der zugehörigen Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-139">A class inherits the members of its base class.</span></span> <span data-ttu-id="5d1c6-140">Vererbung bedeutet, dass eine Klasse implizit nahezu alle Member der Basisklasse enthält.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-140">Inheritance means that a class implicitly contains almost all members of its base class.</span></span> <span data-ttu-id="5d1c6-141">Eine Klasse erbt die Instanz- und statischen Konstruktoren sowie den Finalizer nicht.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-141">A class doesn't inherit the instance and static constructors, and the finalizer.</span></span> <span data-ttu-id="5d1c6-142">Eine abgeleitete Klasse kann den geerbten Membern neue Member hinzufügen, aber die Definition eines geerbten Members kann nicht entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-142">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="5d1c6-143">Im vorherigen Beispiel erbt `Point3D` die Member `X` und `Y` von `Point`, und alle `Point3D`-Instanzen enthalten die drei Eigenschaften `X`, `Y` und `Z`.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-143">In the previous example, `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.</span></span>

<span data-ttu-id="5d1c6-144">Ein Klassentyp kann implizit in einen beliebigen zugehörigen Basisklassentyp konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-144">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="5d1c6-145">Eine Variable eines Klassentyps kann auf eine Instanz der Klasse oder eine Instanz einer beliebigen abgeleiteten Klasse verweisen.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-145">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="5d1c6-146">Beispielsweise kann in den vorherigen Klassendeklarationen eine Variable vom Typ `Point` entweder auf `Point` oder auf `Point3D` verweisen:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-146">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a><span data-ttu-id="5d1c6-147">Strukturen</span><span class="sxs-lookup"><span data-stu-id="5d1c6-147">Structs</span></span>

<span data-ttu-id="5d1c6-148">Klassen definieren Typen, die die Vererbung und die Polymorphie unterstützen.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-148">Classes define types that support inheritance and polymorphism.</span></span> <span data-ttu-id="5d1c6-149">Sie ermöglichen es Ihnen, komplexe Verhaltensweise anhand von Hierarchien abgeleiteter Klassen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-149">They enable you to create sophisticated behaviors based on hierarchies of derived classes.</span></span> <span data-ttu-id="5d1c6-150">Im Gegensatz dazu sind [***Strukturtypen***](../language-reference/builtin-types/struct.md) (struct) einfachere Typen, deren Hauptaufgabe darin besteht, Datenwerte zu speichern.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-150">By contrast, [***struct***](../language-reference/builtin-types/struct.md) types are simpler types whose primary purpose is to store data values.</span></span> <span data-ttu-id="5d1c6-151">Strukturen können keinen Basistyp deklarieren, sie leiten implizit von <xref:System.ValueType?displayProperty=nameWithType> ab.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-151">Structs can't declare a base type; they implicitly derive from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5d1c6-152">Sie können keine anderen `struct`-Typen von einem `struct`-Typ ableiten.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-152">You can't derive other `struct` types from a `struct` type.</span></span> <span data-ttu-id="5d1c6-153">Sie werden implizit versiegelt.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-153">They're implicitly sealed.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a><span data-ttu-id="5d1c6-154">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="5d1c6-154">Interfaces</span></span>

<span data-ttu-id="5d1c6-155">Eine [***Schnittstelle***](../programming-guide/interfaces/index.md) (interface) definiert einen Vertrag, der von Klassen und Strukturen implementiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-155">An [***interface***](../programming-guide/interfaces/index.md) defines a contract that can be implemented by classes and structs.</span></span> <span data-ttu-id="5d1c6-156">Eine Schnittstelle kann Methoden, Eigenschaften, Ereignisse und Indexer enthalten.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-156">An interface can contain methods, properties, events, and indexers.</span></span> <span data-ttu-id="5d1c6-157">Eine Schnittstelle stellt in der Regel keine Implementierungen der von ihr definierten Member bereit. Sie gibt lediglich die Member an, die von Klassen oder Strukturen bereitgestellt werden müssen, die die Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-157">An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.</span></span>

<span data-ttu-id="5d1c6-158">Schnittstellen können ***Mehrfachvererbung*** einsetzen.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-158">Interfaces may employ ***multiple inheritance***.</span></span> <span data-ttu-id="5d1c6-159">Im folgenden Beispiel erbt die Schnittstelle `IComboBox` sowohl von `ITextBox` als auch `IListBox`.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-159">In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

<span data-ttu-id="5d1c6-160">Klassen und Strukturen können mehrere Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-160">Classes and structs can implement multiple interfaces.</span></span> <span data-ttu-id="5d1c6-161">Im folgenden Beispiel implementiert die Klasse `EditBox` sowohl `IControl` als auch `IDataBound`.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-161">In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

<span data-ttu-id="5d1c6-162">Wenn eine Klasse oder Struktur eine bestimmte Schnittstelle implementiert, können Instanzen dieser Klasse oder Struktur implizit in diesen Schnittstellentyp konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-162">When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type.</span></span> <span data-ttu-id="5d1c6-163">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-163">For example</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a><span data-ttu-id="5d1c6-164">Enumerationen</span><span class="sxs-lookup"><span data-stu-id="5d1c6-164">Enums</span></span>

<span data-ttu-id="5d1c6-165">[***Enumerationstypen***](../language-reference/builtin-types/enum.md) (Enum) definieren eine Gruppe konstanter Werte.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-165">An [***Enum***](../language-reference/builtin-types/enum.md) type defines a set of constant values.</span></span> <span data-ttu-id="5d1c6-166">Mit dem folgenden `enum`-Typ werden Konstanten deklariert, die verschiedene Wurzelgemüsesorten definieren:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-166">The following `enum` declares constants that define different root vegetables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

<span data-ttu-id="5d1c6-167">Sie können einen `enum`-Typ definieren, der in Kombination als Flags verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-167">You can also define an `enum` to be used in combination as flags.</span></span> <span data-ttu-id="5d1c6-168">In der folgenden Deklaration werden Flags für die vier Jahreszeiten deklariert.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-168">The following declaration declares a set of flags for the four seasons.</span></span> <span data-ttu-id="5d1c6-169">Jede Kombination der Jahreszeiten kann angewendet werden, einschließlich eines `All`-Werts, der alle Jahreszeiten umfasst:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-169">Any combination of the seasons may be applied, including an `All` value that includes all seasons:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

<span data-ttu-id="5d1c6-170">Im folgenden Beispiel werden Deklaration der beiden Enumerationen veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-170">The following example shows declarations of both the preceding enums:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a><span data-ttu-id="5d1c6-171">Nullable-Typen</span><span class="sxs-lookup"><span data-stu-id="5d1c6-171">Nullable types</span></span>

<span data-ttu-id="5d1c6-172">Jede Art von Variable kann als ***Non-Nullable*** oder ***Nullable*** deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-172">Variables of any type may be declared as ***non-nullable*** or ***nullable***.</span></span> <span data-ttu-id="5d1c6-173">Eine Nullable-Variable kann einen zusätzlichen `null`-Wert enthalten, der angibt, dass kein Wert vorliegt.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-173">A nullable variable can hold an additional `null` value, indicating no value.</span></span> <span data-ttu-id="5d1c6-174">Nullable-Werttypen (Strukturen oder Enumerationen) werden mit <xref:System.Nullable%601?displayProperty=nameWithType> dargestellt.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-174">Nullable Value types (structs or enums) are represented by <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5d1c6-175">Non-Nullable- und Nullable-Verweistypen werden beide vom zugrunde liegenden Verweistyp repräsentiert.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-175">Non-nullable and Nullable Reference types are both represented by the underlying reference type.</span></span> <span data-ttu-id="5d1c6-176">Der Unterschied wird von Metadaten dargestellt, die vom Compiler und einigen Bibliotheken gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-176">The distinction is represented by metadata read by the compiler and some libraries.</span></span> <span data-ttu-id="5d1c6-177">Der Compiler gibt Warnungen aus, wenn Nullable-Verweise dereferenziert werden, ohne dass ihr Wert zunächst auf `null` geprüft wird.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-177">The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`.</span></span> <span data-ttu-id="5d1c6-178">Der Compiler gibt auch Warnungen aus, wenn Non-Nullable-Verweise einem Wert zugewiesen werden, der `null` sein kann.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-178">The compiler also provides warnings when non-nullable references are assigned to a value that may be `null`.</span></span> <span data-ttu-id="5d1c6-179">Im folgenden Beispiel wird ein ***nullable int***-Wert deklariert und mit `null` initialisiert.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-179">The following example declares a ***nullable int***, initializing it to `null`.</span></span> <span data-ttu-id="5d1c6-180">Dann wird der Wert auf `5` festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-180">Then, it sets the value to `5`.</span></span> <span data-ttu-id="5d1c6-181">Dasselbe Konzept wird mit ***nullable string*** veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-181">It demonstrates the same concept with a ***nullable string***.</span></span> <span data-ttu-id="5d1c6-182">Weitere Informationen finden Sie unter [Nullable-Werttypen](../language-reference/builtin-types/nullable-value-types.md) und [Nullable-Verweistypen](../nullable-references.md).</span><span class="sxs-lookup"><span data-stu-id="5d1c6-182">For more information, see [nullable value types](../language-reference/builtin-types/nullable-value-types.md) and [nullable reference types](../nullable-references.md).</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a><span data-ttu-id="5d1c6-183">Tupel</span><span class="sxs-lookup"><span data-stu-id="5d1c6-183">Tuples</span></span>

<span data-ttu-id="5d1c6-184">C# unterstützt [***Tupel***](../language-reference/builtin-types/value-tuples.md), die eine kompakte Syntax zum Gruppieren mehrerer Datenelemente in einer einfachen Datenstruktur bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-184">C# supports [***tuples***](../language-reference/builtin-types/value-tuples.md), which provides concise syntax to group multiple data elements in a lightweight data structure.</span></span> <span data-ttu-id="5d1c6-185">Sie können ein Tupel instanziieren, indem Sie die Typen und Namen der Member zwischen `(` und `)` deklarieren. Dies wird im folgenden Beispiel veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="5d1c6-185">You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

<span data-ttu-id="5d1c6-186">Tupel bieten eine Alternative für Datenstrukturen mit mehreren Membern, ohne dass die Bausteine verwendet werden müssen, die im nächsten Artikel beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="5d1c6-186">Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="5d1c6-187">[Zurück](index.md)
>[Weiter](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="5d1c6-187">[Previous](index.md)
[Next](program-building-blocks.md)</span></span>
