---
title: Einführung in C# - Leitfaden für C#
description: Neu bei C#? Lernen Sie die Grundlagen der Sprache kennen.
ms.date: 08/06/2020
ms.openlocfilehash: 9fa292e8e85832d831f36cf0f21512aa0cf32580
ms.sourcegitcommit: c4a15c6c4ecbb8a46ad4e67d9b3ab9b8b031d849
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 08/20/2020
ms.locfileid: "88656227"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="77dfb-104">Überblick über C#</span><span class="sxs-lookup"><span data-stu-id="77dfb-104">A tour of the C# language</span></span>

<span data-ttu-id="77dfb-105">C# (Aussprache „C Sharp“) ist eine moderne, objektorientierte und typsichere Programmiersprache.</span><span class="sxs-lookup"><span data-stu-id="77dfb-105">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="77dfb-106">C# hat seine Wurzeln in der C-Sprachenfamilie und ist Programmierern, die mit C, C++, Java und JavaScript arbeiten, sofort vertraut.</span><span class="sxs-lookup"><span data-stu-id="77dfb-106">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="77dfb-107">Diese Einführung bietet einen Überblick über die wichtigsten Komponenten der Sprache in C# 8 und früheren Versionen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-107">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="77dfb-108">Wenn Sie die Sprache anhand von interaktiven Beispielen kennenlernen möchten, arbeiten Sie die Tutorials auf der Seite [Einführung in C#](../tutorials/intro-to-csharp/index.md) durch.</span><span class="sxs-lookup"><span data-stu-id="77dfb-108">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="77dfb-109">C# ist eine objektorientierte,  ***komponentenorientierte*** Programmiersprache.</span><span class="sxs-lookup"><span data-stu-id="77dfb-109">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="77dfb-110">C# bietet Sprachkonstrukte zur direkten Unterstützung dieser Konzepte, was C# zu einer natürlichen Sprache macht, in der Softwarekomponenten erstellt und verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="77dfb-110">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="77dfb-111">Seit Veröffentlichung wurden C# Features hinzugefügt, um neue Workloads und Methoden zur Gestaltung von Software zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-111">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="77dfb-112">Einige C#-Features helfen beim Entwickeln stabiler und dauerhafter Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-112">Several C# features aid in the construction of robust and durable applications.</span></span> <span data-ttu-id="77dfb-113">Die [***Garbage Collection***](../../standard/garbage-collection/index.md) gibt Arbeitsspeicher automatisch frei, der von unerreichbaren nicht verwendeten Objekten belegt wird.</span><span class="sxs-lookup"><span data-stu-id="77dfb-113">[***Garbage collection***](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="77dfb-114">Die [***Ausnahmebehandlung***](../programming-guide/exceptions/index.md) bietet einen strukturierten und erweiterbaren Ansatz zur Fehlererkennung und Wiederherstellung.</span><span class="sxs-lookup"><span data-stu-id="77dfb-114">[***Exception handling***](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="77dfb-115">[***Lambda-Ausdrücke***](../language-reference/operators/lambda-expressions.md) unterstützen funktionale Programmiertechniken.</span><span class="sxs-lookup"><span data-stu-id="77dfb-115">[***Lambda expressions***](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="77dfb-116">Die [***Abfragesyntax***](../linq/index.md) schafft ein einheitliches Muster für das Arbeiten mit Daten aus beliebigen Quellen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-116">[***Query syntax***](../linq/index.md) creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="77dfb-117">Dank Sprachunterstützung für [***asynchrone Vorgänge***](../programming-guide/concepts/async/index.md) wird eine Syntax für den Aufbau verteilter Systeme bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="77dfb-117">Language support for [***asynchronous operations***](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="77dfb-118">Der [***Musterabgleich***](..//pattern-matching.md) bietet eine Syntax, mit der sich Daten und Algorithmen in modernen verteilten Systemen leicht voneinander trennen lassen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-118">[***Pattern matching***](..//pattern-matching.md) provides syntax to easily separate data from algorithms in modern distributed systems.</span></span> <span data-ttu-id="77dfb-119">C# bietet ein [***einheitliches Typsystem***](../programming-guide/types/index.md).</span><span class="sxs-lookup"><span data-stu-id="77dfb-119">C# has a [***unified type system***](../programming-guide/types/index.md).</span></span> <span data-ttu-id="77dfb-120">Alle C#-Typen, einschließlich primitiver Typen wie `int` und `double`, erben von einem einzelnen `object`-Stammtyp.</span><span class="sxs-lookup"><span data-stu-id="77dfb-120">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="77dfb-121">Allen Typen teilen sich eine Reihe allgemeiner Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="77dfb-121">All types share a set of common operations.</span></span> <span data-ttu-id="77dfb-122">Werte jeglicher Art können einheitlich gespeichert, transportiert und bearbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="77dfb-122">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="77dfb-123">Darüber hinaus unterstützt C# benutzerdefinierte Verweis- und Werttypen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-123">Furthermore, C# supports both user-defined reference types and value types.</span></span> <span data-ttu-id="77dfb-124">C# ermöglicht die dynamische Zuteilung von Objekten und die Inlinespeicherung schlanker Strukturen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-124">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span>

<span data-ttu-id="77dfb-125">In C# dient die ***Versionsverwaltung*** zum Sicherstellen, dass sich Programme und Bibliotheken im Laufe der Zeit kompatibel weiterentwickeln können.</span><span class="sxs-lookup"><span data-stu-id="77dfb-125">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="77dfb-126">Zu den Aspekten der Entwicklung von C#, die direkt von Überlegungen bei der Versionskontrolle beeinflusst wurden, gehören die separaten `virtual`- und `override`-Modifizierer, die Regeln für die Überladungsauflösung und die Unterstützung für explizite Schnittstellenmember-Deklarationen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-126">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="hello-world"></a><span data-ttu-id="77dfb-127">Hello World</span><span class="sxs-lookup"><span data-stu-id="77dfb-127">Hello world</span></span>

<span data-ttu-id="77dfb-128">Das Programm „Hello, World“ wird für gewöhnlich zur Einführung einer Programmiersprache verwendet.</span><span class="sxs-lookup"><span data-stu-id="77dfb-128">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="77dfb-129">Hier ist es in C#:</span><span class="sxs-lookup"><span data-stu-id="77dfb-129">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="77dfb-130">Das Programm „Hello, World“ wird mit einer `using`-Richtlinie gestartet, die auf den `System`-Namespace verweist.</span><span class="sxs-lookup"><span data-stu-id="77dfb-130">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="77dfb-131">Namespaces bieten eine hierarchische Möglichkeit zum Organisieren von C#-Programmen und -Bibliotheken.</span><span class="sxs-lookup"><span data-stu-id="77dfb-131">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="77dfb-132">Namespaces enthalten Typen und andere Namespaces. Beispiel: Der `System`-Namespace enthält eine Reihe von Typen, wie etwa die `Console`-Klasse, auf die im Programm verwiesen wird, und eine Reihe anderer Namespaces, wie etwa `IO` und `Collections`.</span><span class="sxs-lookup"><span data-stu-id="77dfb-132">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="77dfb-133">Eine `using`-Richtlinie, die auf einen bestimmten Namespace verweist, ermöglicht die nicht qualifizierte Nutzung der Typen, die Member dieses Namespace sind.</span><span class="sxs-lookup"><span data-stu-id="77dfb-133">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="77dfb-134">Aufgrund der `using`-Direktive kann das Programm `Console.WriteLine` als Abkürzung für `System.Console.WriteLine` verwenden.</span><span class="sxs-lookup"><span data-stu-id="77dfb-134">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="77dfb-135">Die `Hello`-Klasse, die vom Programm „Hello, World“ deklariert wird, verfügt über einen einzelnen Member: die `Main`-Methode.</span><span class="sxs-lookup"><span data-stu-id="77dfb-135">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="77dfb-136">Die `Main`-Methode wird mit dem Modifizierer `static` deklariert.</span><span class="sxs-lookup"><span data-stu-id="77dfb-136">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="77dfb-137">Auch wenn Instanzmethoden mit dem Schlüsselwort `this` auf eine bestimmte einschließende Objektinstanz verweisen können, agieren statische Methoden ohne Verweis auf ein bestimmtes Objekt.</span><span class="sxs-lookup"><span data-stu-id="77dfb-137">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="77dfb-138">Gemäß Konvention fungiert eine statische Methode mit der Bezeichnung `Main` als Einstiegspunkt eines C#-Programms.</span><span class="sxs-lookup"><span data-stu-id="77dfb-138">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="77dfb-139">Die Ausgabe des Programms wird anhand der `WriteLine`-Methode der `Console`-Klasse im `System`-Namespace generiert.</span><span class="sxs-lookup"><span data-stu-id="77dfb-139">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="77dfb-140">Diese Klasse wird anhand der Standardklassenbibliotheken bereitgestellt, auf die standardmäßig automatisch vom Compiler verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="77dfb-140">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="77dfb-141">Typen und Variablen</span><span class="sxs-lookup"><span data-stu-id="77dfb-141">Types and variables</span></span>

<span data-ttu-id="77dfb-142">Es gibt zwei Arten von Typen in C#: *Werttypen* und *Verweistypen*.</span><span class="sxs-lookup"><span data-stu-id="77dfb-142">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="77dfb-143">Variablen von Werttypen enthalten ihre Daten direkt, Variablen von Verweistypen speichern hingegen Verweise auf ihre Daten – letztere werden als Objekte bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="77dfb-143">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="77dfb-144">Dank Verweistypen können zwei Variablen auf das gleiche Objekt verweisen. So können auf eine Variable angewendete Vorgänge das Objekt beeinflussen, auf das die andere Variable verweist.</span><span class="sxs-lookup"><span data-stu-id="77dfb-144">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="77dfb-145">Bei Werttypen besitzen die Variablen jeweils eigene Kopien der Daten. Auf eine Variable angewendete Vorgänge können sich nicht auf die andere Variable auswirken (außer im Fall der Parametervariablen `ref` und `out`).</span><span class="sxs-lookup"><span data-stu-id="77dfb-145">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="77dfb-146">Ein ***Bezeichner*** ist ein Variablenname.</span><span class="sxs-lookup"><span data-stu-id="77dfb-146">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="77dfb-147">Ein Bezeichner ist eine Sequenz von Unicode-Zeichen ohne Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-147">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="77dfb-148">Ein Bezeichner kann ein in C# reserviertes Wort sein, wenn ihm das Präfix `@` vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="77dfb-148">An identifier may be a C# reserved word, if it is prefixed by `@`.</span></span> <span data-ttu-id="77dfb-149">Das kann bei der Interaktion mit anderen Sprachen nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="77dfb-149">That can be useful when interacting with other languages.</span></span>

<span data-ttu-id="77dfb-150">C#-Werttypen sind weiter unterteilt in *einfache Typen*, *Enumerationstypen*, *Strukturtypen* und *Nullable-Werttypen*.</span><span class="sxs-lookup"><span data-stu-id="77dfb-150">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="77dfb-151">C#-Verweistypen sind weiter unterteilt in *Klassentypen*, *Schnittstellentypen*, *Arraytypen* und *Delegattypen*.</span><span class="sxs-lookup"><span data-stu-id="77dfb-151">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="77dfb-152">Im Folgenden finden Sie eine Übersicht des C#-Typsystems.</span><span class="sxs-lookup"><span data-stu-id="77dfb-152">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="77dfb-153">Werttypen</span><span class="sxs-lookup"><span data-stu-id="77dfb-153">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="77dfb-154">Einfache Typen</span><span class="sxs-lookup"><span data-stu-id="77dfb-154">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="77dfb-155">[Integral mit Vorzeichen](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span><span class="sxs-lookup"><span data-stu-id="77dfb-155">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="77dfb-156">[Integral ohne Vorzeichen](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span><span class="sxs-lookup"><span data-stu-id="77dfb-156">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="77dfb-157">[Unicode-Zeichen](../../standard/base-types/character-encoding-introduction.md): `char`, das ein Zeichen als UTF-16-Codeeinheit darstellt</span><span class="sxs-lookup"><span data-stu-id="77dfb-157">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="77dfb-158">[Binäres Gleitkomma (IEEE)](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="77dfb-158">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="77dfb-159">[Dezimale Gleitkommazahl mit hoher Genauigkeit](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span><span class="sxs-lookup"><span data-stu-id="77dfb-159">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="77dfb-160">Boolesch: `bool` dient zur Darstellung boolescher Werte, die entweder `true` oder `false` sind</span><span class="sxs-lookup"><span data-stu-id="77dfb-160">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="77dfb-161">Enumerationstypen</span><span class="sxs-lookup"><span data-stu-id="77dfb-161">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="77dfb-162">Benutzerdefinierte Typen der Form `enum E {...}`.</span><span class="sxs-lookup"><span data-stu-id="77dfb-162">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="77dfb-163">Ein `enum`-Typ ist ein eigenständiger Typ mit einer benannten Konstante.</span><span class="sxs-lookup"><span data-stu-id="77dfb-163">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="77dfb-164">Jeder `enum`-Typ verfügt über einen zugrunde liegenden Typ, der einer der acht ganzzahligen Typen sein muss.</span><span class="sxs-lookup"><span data-stu-id="77dfb-164">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="77dfb-165">Der Satz von Werten eines `enum`-Typs ist mit dem Satz von Werten des zugrunde liegenden Typs identisch.</span><span class="sxs-lookup"><span data-stu-id="77dfb-165">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="77dfb-166">Strukturtypen</span><span class="sxs-lookup"><span data-stu-id="77dfb-166">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="77dfb-167">Benutzerdefinierte Typen der Form `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="77dfb-167">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="77dfb-168">Auf NULL festlegbare Werttypen</span><span class="sxs-lookup"><span data-stu-id="77dfb-168">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="77dfb-169">Erweiterungen aller anderen Werttypen mit einem `null`-Wert</span><span class="sxs-lookup"><span data-stu-id="77dfb-169">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="77dfb-170">Tupelwerttypen</span><span class="sxs-lookup"><span data-stu-id="77dfb-170">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="77dfb-171">Benutzerdefinierte Typen der Form `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="77dfb-171">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="77dfb-172">Verweistypen</span><span class="sxs-lookup"><span data-stu-id="77dfb-172">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="77dfb-173">Klassentypen</span><span class="sxs-lookup"><span data-stu-id="77dfb-173">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="77dfb-174">Ultimative Basisklasse aller anderen Typen:`object`</span><span class="sxs-lookup"><span data-stu-id="77dfb-174">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="77dfb-175">[Unicode-Zeichenfolgen](../../standard/base-types/character-encoding-introduction.md): `string`, die eine Sequenz von UTF-16-Codeeinheiten darstellt</span><span class="sxs-lookup"><span data-stu-id="77dfb-175">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="77dfb-176">Benutzerdefinierte Typen der Form `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="77dfb-176">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="77dfb-177">Schnittstellentypen</span><span class="sxs-lookup"><span data-stu-id="77dfb-177">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="77dfb-178">Benutzerdefinierte Typen der Form `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="77dfb-178">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="77dfb-179">Array types (Arraytypen)</span><span class="sxs-lookup"><span data-stu-id="77dfb-179">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="77dfb-180">Ein- und mehrdimensional und verzweigt, z. B. `int[]`, `int[,]` und `int[][]`</span><span class="sxs-lookup"><span data-stu-id="77dfb-180">Single- and multi-dimensional and jagged, for example, `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="77dfb-181">Delegattypen</span><span class="sxs-lookup"><span data-stu-id="77dfb-181">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="77dfb-182">Benutzerdefinierte Typen der Form `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="77dfb-182">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="77dfb-183">C#-Programme verwenden *Typdeklarationen*, um neue Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-183">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="77dfb-184">Eine Typdeklaration gibt den Namen und die Member des neuen Typs an.</span><span class="sxs-lookup"><span data-stu-id="77dfb-184">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="77dfb-185">Fünf Typkategorien von C# sind benutzerdefinierbar: Klassentypen, Strukturtypen, Schnittstellentypen, Enumerationstypen und Delegattypen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-185">Five of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

- <span data-ttu-id="77dfb-186">Ein `class`-Typ definiert eine Datenstruktur, die Datenmember (Felder) und Funktionsmember (Methoden, Eigenschaften usw.) enthält.</span><span class="sxs-lookup"><span data-stu-id="77dfb-186">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="77dfb-187">Klassentypen unterstützen einzelne Vererbung und Polymorphie. Dies sind Mechanismen, durch die abgeleitete Klassen erweitert und Basisklassen spezialisiert werden können.</span><span class="sxs-lookup"><span data-stu-id="77dfb-187">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="77dfb-188">Ein `struct`-Typ ähnelt einem Klassentyp, da er eine Struktur mit Datenmembern und Funktionsmembern darstellt.</span><span class="sxs-lookup"><span data-stu-id="77dfb-188">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="77dfb-189">Im Gegensatz zu Klassen sind Strukturen Werttypen, die in der Regel keine Heapzuordnung erfordern.</span><span class="sxs-lookup"><span data-stu-id="77dfb-189">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="77dfb-190">Strukturtypen unterstützen keine benutzerdefinierte Vererbung, und alle Strukturtypen erben implizit vom Typ `object`.</span><span class="sxs-lookup"><span data-stu-id="77dfb-190">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="77dfb-191">Ein `interface`-Typ definiert einen Vertrag als benannte Gruppe öffentlicher Member.</span><span class="sxs-lookup"><span data-stu-id="77dfb-191">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="77dfb-192">Ein `class`- oder `struct`-Typ, der einen `interface`-Typ implementiert, muss Implementierungen der Member der Schnittstelle bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-192">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="77dfb-193">Eine `interface` kann von mehreren Basisschnittstellen erben, und eine `class` oder `struct` kann mehrere Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="77dfb-193">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="77dfb-194">Ein `delegate`-Typ stellt Verweise auf Methoden mit einer bestimmten Parameterliste und dem Rückgabetyp dar.</span><span class="sxs-lookup"><span data-stu-id="77dfb-194">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="77dfb-195">Delegate ermöglichen die Behandlung von Methoden als Entitäten, die Variablen zugewiesen und als Parameter übergeben werden können.</span><span class="sxs-lookup"><span data-stu-id="77dfb-195">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="77dfb-196">Delegate werden analog zu Funktionstypen von funktionalen Sprachen bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="77dfb-196">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="77dfb-197">Außerdem ähneln sie konzeptionell Funktionszeigern, die es in einigen anderen Sprachen gibt.</span><span class="sxs-lookup"><span data-stu-id="77dfb-197">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="77dfb-198">Im Gegensatz zu Funktionszeigern sind Delegaten objektorientiert und typsicher.</span><span class="sxs-lookup"><span data-stu-id="77dfb-198">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="77dfb-199">Die Typen, `class`, `struct`, `interface` und `delegate` unterstützen Generics, wodurch sie mit anderen Typen parametrisiert werden können.</span><span class="sxs-lookup"><span data-stu-id="77dfb-199">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="77dfb-200">C# unterstützt ein- und mehrdimensionale Arrays beliebigen Typs.</span><span class="sxs-lookup"><span data-stu-id="77dfb-200">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="77dfb-201">Im Gegensatz zu den oben aufgeführten Typen müssen Arraytypen nicht deklariert werden, bevor sie verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="77dfb-201">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="77dfb-202">Stattdessen werden Arraytypen erstellt, indem hinter einen Typnamen eckige Klammern gesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="77dfb-202">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="77dfb-203">Beispielsweise ist `int[]` ein eindimensionales Array von `int`, `int[,]` ein zweidimensionales Array von `int` und `int[][]` ein eindimensionales Array des eindimensionalen oder „verzweigten“ Arrays von `int`.</span><span class="sxs-lookup"><span data-stu-id="77dfb-203">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array or "jagged" array of `int`.</span></span>

<span data-ttu-id="77dfb-204">Nullable-Typen erfordern keine getrennte Definition.</span><span class="sxs-lookup"><span data-stu-id="77dfb-204">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="77dfb-205">Für jeden Non-Nullable-Typ `T` gibt es einen entsprechenden Nullable-Typ `T?`, der einen zusätzlichen Wert, `null`, enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="77dfb-205">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="77dfb-206">Beispielsweise ist `int?` ein Typ, der jeden 32-Bit-Ganzzahlwert oder den Wert `null` enthalten kann. `string?` ist ein Typ, der beliebige `string`-Typen oder den Wert `null` enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="77dfb-206">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="77dfb-207">Das C#-Typsystem ist dahingehend vereinheitlicht, dass ein Wert eines beliebigen Typs als `object` behandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="77dfb-207">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="77dfb-208">Jeder Typ in C# ist direkt oder indirekt vom `object`-Klassentyp abgeleitet, und `object` ist die ultimative Basisklasse aller Typen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-208">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="77dfb-209">Werte von Verweistypen werden als Objekte behandelt, indem die Werte einfach als Typ `object` angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="77dfb-209">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="77dfb-210">Werte von Werttypen werden durch Ausführen von *Boxing*- und *Unboxingvorgängen* als Objekte behandelt.</span><span class="sxs-lookup"><span data-stu-id="77dfb-210">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="77dfb-211">Im folgenden Beispiel wird ein `int`-Wert in ein `object` und wieder in einen `int`-Wert konvertiert.</span><span class="sxs-lookup"><span data-stu-id="77dfb-211">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="77dfb-212">Wenn ein Wert eines Werttyps einem `object`-Verweis zugewiesen wird, wird eine „Box“ zugeordnet, die den Wert enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="77dfb-212">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="77dfb-213">Bei dieser Box handelt es sich um eine Instanz eines Verweistyps, und der Wert wird in diese Box kopiert.</span><span class="sxs-lookup"><span data-stu-id="77dfb-213">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="77dfb-214">Wenn umgekehrt ein `object`-Verweis in einen Werttyp umgewandelt wird, wird überprüft, ob der `object`-Typ, auf den verwiesen wird, eine Box des korrekten Werttyps ist.</span><span class="sxs-lookup"><span data-stu-id="77dfb-214">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="77dfb-215">Nach erfolgreicher Überprüfung wird der Wert in der Box zum Werttyp kopiert.</span><span class="sxs-lookup"><span data-stu-id="77dfb-215">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="77dfb-216">Aus dem einheitlichen C#-Typensystem resultiert, dass Werttypen „bei Nachfrage“ als `object`-Verweise behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="77dfb-216">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="77dfb-217">Aufgrund der Vereinheitlichung können Bibliotheken für allgemeine Zwecke, die den Typ `object` verwenden, mit allen Typen verwendet werden können, die von `object` abgeleitet werden, wozu sowohl Verweis- als auch Werttypen zählen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-217">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="77dfb-218">Es gibt mehrere Arten von *Variablen* in C#, einschließlich Feldern, Arrayelementen, lokalen Variablen und Parametern.</span><span class="sxs-lookup"><span data-stu-id="77dfb-218">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="77dfb-219">Variablen stellen Speicherorte dar.</span><span class="sxs-lookup"><span data-stu-id="77dfb-219">Variables represent storage locations.</span></span> <span data-ttu-id="77dfb-220">Jede Variable hat, wie nachstehend gezeigt, einen Typ, der bestimmt, welche Werte in der Variablen gespeichert werden können.</span><span class="sxs-lookup"><span data-stu-id="77dfb-220">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="77dfb-221">Nicht auf NULL festlegbarer Werttyp</span><span class="sxs-lookup"><span data-stu-id="77dfb-221">Non-nullable value type</span></span>
  - <span data-ttu-id="77dfb-222">Ein Wert genau dieses Typs</span><span class="sxs-lookup"><span data-stu-id="77dfb-222">A value of that exact type</span></span>
- <span data-ttu-id="77dfb-223">Auf NULL festlegbarer Werttyp</span><span class="sxs-lookup"><span data-stu-id="77dfb-223">Nullable value type</span></span>
  - <span data-ttu-id="77dfb-224">Ein `null`-Wert oder ein Wert genau dieses Typs</span><span class="sxs-lookup"><span data-stu-id="77dfb-224">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="77dfb-225">object</span><span class="sxs-lookup"><span data-stu-id="77dfb-225">object</span></span>
  - <span data-ttu-id="77dfb-226">Ein `null`-Verweis, ein Verweis auf ein Objekt eines beliebigen Verweistyps oder ein Verweis auf einen geschachtelten Wert eines beliebigen Werttyps</span><span class="sxs-lookup"><span data-stu-id="77dfb-226">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="77dfb-227">Klassentyp</span><span class="sxs-lookup"><span data-stu-id="77dfb-227">Class type</span></span>
  - <span data-ttu-id="77dfb-228">Ein `null`-Verweis, ein Verweis auf eine Instanz dieses Klassentyps oder ein Verweis auf eine Instanz einer Klasse, die von diesem Klassentyp abgeleitet ist</span><span class="sxs-lookup"><span data-stu-id="77dfb-228">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="77dfb-229">Schnittstellentyp</span><span class="sxs-lookup"><span data-stu-id="77dfb-229">Interface type</span></span>
  - <span data-ttu-id="77dfb-230">Ein `null`-Verweis, ein Verweis auf eine Instanz eines Klassentyps, der diesen Schnittstellentyp implementiert, oder ein Verweis auf einen geschachtelten Wert eines Werttyps, der diesen Schnittstellentyp implementiert</span><span class="sxs-lookup"><span data-stu-id="77dfb-230">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="77dfb-231">Arraytyp</span><span class="sxs-lookup"><span data-stu-id="77dfb-231">Array type</span></span>
  - <span data-ttu-id="77dfb-232">Ein `null`-Verweis, ein Verweis auf eine Instanz dieses Arraytyps oder ein Verweis auf eine Instanz eines kompatiblen Arraytyps</span><span class="sxs-lookup"><span data-stu-id="77dfb-232">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="77dfb-233">Delegattyp</span><span class="sxs-lookup"><span data-stu-id="77dfb-233">Delegate type</span></span>
  - <span data-ttu-id="77dfb-234">Ein `null`-Verweis oder ein Verweis auf eine Instanz eines kompatiblen Delegattyp</span><span class="sxs-lookup"><span data-stu-id="77dfb-234">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="77dfb-235">Programmstruktur</span><span class="sxs-lookup"><span data-stu-id="77dfb-235">Program structure</span></span>

<span data-ttu-id="77dfb-236">Die wichtigsten Organisationskonzepte in C# sind [***Programme***](../programming-guide/inside-a-program/index.md), [***Namespaces***](../programming-guide/namespaces/index.md), [***Typen***](../programming-guide/types/index.md), [***Member***](../programming-guide/classes-and-structs/members.md) und [***Assemblys***](../../standard/assembly/index.md).</span><span class="sxs-lookup"><span data-stu-id="77dfb-236">The key organizational concepts in C# are [***programs***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***types***](../programming-guide/types/index.md), [***members***](../programming-guide/classes-and-structs/members.md), and [***assemblies***](../../standard/assembly/index.md).</span></span> <span data-ttu-id="77dfb-237">Programme deklarieren Typen, die Member enthalten, und können in Namespaces organisiert werden.</span><span class="sxs-lookup"><span data-stu-id="77dfb-237">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="77dfb-238">Klassen, Strukturen und Schnittstellen sind Beispiele von Typen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-238">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="77dfb-239">Felder, Methoden, Eigenschaften und Ereignisse sind Beispiele für Member.</span><span class="sxs-lookup"><span data-stu-id="77dfb-239">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="77dfb-240">Wenn C#-Programme kompiliert werden, werden sie physisch in Assemblys gepackt.</span><span class="sxs-lookup"><span data-stu-id="77dfb-240">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="77dfb-241">Assemblys haben in der Regel die Erweiterung `.exe` oder `.dll`, je nachdem, ob sie ***Anwendungen*** oder ***Bibliotheken*** implementieren.</span><span class="sxs-lookup"><span data-stu-id="77dfb-241">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively.</span></span>

<span data-ttu-id="77dfb-242">Nehmen Sie als einfaches Beispiel eine Assembly, die den folgenden Code enthält:</span><span class="sxs-lookup"><span data-stu-id="77dfb-242">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="77dfb-243">Der vollqualifizierte Name dieser Klasse ist `Acme.Collections.Stack`.</span><span class="sxs-lookup"><span data-stu-id="77dfb-243">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="77dfb-244">Die Klasse enthält mehrere Member: ein Feld mit dem Namen `top`, zwei Methoden mit dem Namen `Push` und `Pop` sowie eine geschachtelte Klasse mit dem Namen `Entry`.</span><span class="sxs-lookup"><span data-stu-id="77dfb-244">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="77dfb-245">Die `Entry`-Klasse enthält weitere drei Member: ein Feld mit dem Namen `next`, ein Feld mit dem Namen `data` und einen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="77dfb-245">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="77dfb-246">`Stack` ist eine *generische* Klasse.</span><span class="sxs-lookup"><span data-stu-id="77dfb-246">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="77dfb-247">Sie hat einen Typparameter, `T`, der bei seiner Verwendung durch einen konkreten Typ ersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="77dfb-247">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="77dfb-248">Ein *Stapel* ist eine FILO-Sammlung (First In, Last Out).</span><span class="sxs-lookup"><span data-stu-id="77dfb-248">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="77dfb-249">Neue Elemente werden am Anfang des Stapels hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="77dfb-249">New elements are added to the top of the stack.</span></span> <span data-ttu-id="77dfb-250">Das Entfernen eines Elements erfolgt von oben im Stapel.</span><span class="sxs-lookup"><span data-stu-id="77dfb-250">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="77dfb-251">Assemblys enthalten ausführbaren Code in Form von Zwischensprachenanweisungen (Intermediate Language, IL) und symbolischen Informationen in Form von Metadaten.</span><span class="sxs-lookup"><span data-stu-id="77dfb-251">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="77dfb-252">Vor der Ausführen konvertiert der JIT-Compiler (Just-In-Time) der .NET Common Language Runtime den IL-Code in einer Assembly in prozessorspezifischen Code.</span><span class="sxs-lookup"><span data-stu-id="77dfb-252">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="77dfb-253">Da eine Assembly eine selbstbeschreibende Funktionseinheit mit Code und Metadaten ist, besteht in C# keine Notwendigkeit für `#include`-Direktiven und Headerdateien.</span><span class="sxs-lookup"><span data-stu-id="77dfb-253">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="77dfb-254">Die öffentlichen Typen und Member, die in einer bestimmten Assembly enthalten sind, werden einfach durch Verweisen auf die Assembly beim Kompilieren des Programms in einem C#-Programm verfügbar gemacht.</span><span class="sxs-lookup"><span data-stu-id="77dfb-254">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="77dfb-255">Dieses Programm verwendet z.B. die `Acme.Collections.Stack`-Klasse aus der `acme.dll`-Assembly:</span><span class="sxs-lookup"><span data-stu-id="77dfb-255">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="77dfb-256">Um dieses Programm zu kompilieren, müssen Sie auf die Assembly *verweisen*, die die im vorherigen Beispiel definierte Stapelklasse enthält.</span><span class="sxs-lookup"><span data-stu-id="77dfb-256">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="77dfb-257">C#-Programme können in mehreren Quelldateien gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="77dfb-257">C# programs can be stored in several source files.</span></span> <span data-ttu-id="77dfb-258">Bei der Kompilierung eines C#-Programms werden alle Quelldateien zusammen verarbeitet. Die Quelldateien können frei aufeinander verweisen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-258">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="77dfb-259">Konzeptionell ist das Ganze so, als ob alle Quelldateien vor der Verarbeitung zu einer großen Datei verkettet worden wären.</span><span class="sxs-lookup"><span data-stu-id="77dfb-259">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="77dfb-260">Vorwärtsdeklarationen sind in C# nie erforderlich, da die Reihenfolge der Deklaration mit wenigen Ausnahmen unbedeutend ist.</span><span class="sxs-lookup"><span data-stu-id="77dfb-260">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="77dfb-261">C# beschränkt eine Quelldatei weder auf die Deklaration eines einzigen öffentlichen Typs, noch muss der Name der Quelldatei mit einem in der Quelldatei deklarierten Typ übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="77dfb-261">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="77dfb-262">In weiteren Artikeln in dieser Einführung werden diese Organisationsblöcke erläutert.</span><span class="sxs-lookup"><span data-stu-id="77dfb-262">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="77dfb-263">Nächste</span><span class="sxs-lookup"><span data-stu-id="77dfb-263">Next</span></span>](types.md)
