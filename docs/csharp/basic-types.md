---
title: Grundlegende Typen | C#-Handbuch
description: Erfahren Sie mehr über die grundlegenden Typen (numerische Werte, Zeichenfolgen und Objekte) in allen C#-Programmen
ms.date: 10/10/2016
ms.technology: csharp-fundamentals
ms.assetid: 95c686ba-ae4f-440e-8e94-0dbd6e04d11f
ms.openlocfilehash: 18a73e62bf45cdc4a4eaa0985c3fe036ac3b55a8
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/04/2020
ms.locfileid: "89465259"
---
# <a name="types-variables-and-values"></a><span data-ttu-id="6ecf7-103">Typen, Variablen und Werte</span><span class="sxs-lookup"><span data-stu-id="6ecf7-103">Types, variables, and values</span></span>

<span data-ttu-id="6ecf7-104">C# ist eine stark typisierte Sprache.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-104">C# is a strongly typed language.</span></span> <span data-ttu-id="6ecf7-105">Jede Variable und jede Konstante verfügt über einen Typ, genau wie jeder Ausdruck, der zu einem Wert ausgewertet wird.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-105">Every variable and constant has a type, as does every expression that evaluates to a value.</span></span> <span data-ttu-id="6ecf7-106">Jede Methodensignatur gibt für jeden Eingabeparameter und den Rückgabewert einen Typ an.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-106">Every method signature specifies a type for each input parameter and for the return value.</span></span> <span data-ttu-id="6ecf7-107">In der .NET-Klassenbibliothek werden integrierte numerische Typen und komplexe Typen definiert, die viele logische Konstrukte darstellen, z.B. das Dateisystem, Netzwerkverbindungen, Auflistungen und Arrays von Objekten sowie Datumsangaben.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-107">The .NET class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</span></span> <span data-ttu-id="6ecf7-108">In einem typischen C#-Programm werden Typen aus der Klassenbibliothek sowie benutzerdefinierte Typen verwendet, die die Konzepte für das Problemfeld des Programms modellieren.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-108">A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.</span></span>  
  
<span data-ttu-id="6ecf7-109">Folgende Informationen können in einem Typ gespeichert sein:</span><span class="sxs-lookup"><span data-stu-id="6ecf7-109">The information stored in a type can include the following:</span></span>  
  
- <span data-ttu-id="6ecf7-110">Der Speicherplatz, den eine Variable des Typs erfordert</span><span class="sxs-lookup"><span data-stu-id="6ecf7-110">The storage space that a variable of the type requires.</span></span>  
  
- <span data-ttu-id="6ecf7-111">Die maximalen und minimalen Werte, die diese darstellen kann</span><span class="sxs-lookup"><span data-stu-id="6ecf7-111">The maximum and minimum values that it can represent.</span></span>  
  
- <span data-ttu-id="6ecf7-112">Die enthaltenen Member (Methoden, Felder, Ereignisse usw.)</span><span class="sxs-lookup"><span data-stu-id="6ecf7-112">The members (methods, fields, events, and so on) that it contains.</span></span>  
  
- <span data-ttu-id="6ecf7-113">Der Basistyp, von dem geerbt wird</span><span class="sxs-lookup"><span data-stu-id="6ecf7-113">The base type it inherits from.</span></span>  
  
- <span data-ttu-id="6ecf7-114">Die Position, an der der Arbeitsspeicher für Variablen zur Laufzeit belegt wird</span><span class="sxs-lookup"><span data-stu-id="6ecf7-114">The location where the memory for variables will be allocated at run time.</span></span>  
  
- <span data-ttu-id="6ecf7-115">Die Arten von zulässigen Vorgängen</span><span class="sxs-lookup"><span data-stu-id="6ecf7-115">The kinds of operations that are permitted.</span></span>  
  
<span data-ttu-id="6ecf7-116">Der Compiler verwendet Typinformationen, um sicherzustellen, dass alle im Code ausgeführten Vorgänge *typsicher* sind.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-116">The compiler uses type information to make sure that all operations that are performed in your code are *type safe*.</span></span> <span data-ttu-id="6ecf7-117">Wenn Sie z.B. eine Variable vom Typ [int](language-reference/builtin-types/integral-numeric-types.md) deklarieren, können Sie mit dem Compiler die Variable für Additions- und Subtraktionsvorgänge verwenden.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-117">For example, if you declare a variable of type [int](language-reference/builtin-types/integral-numeric-types.md), the compiler allows you to use the variable in addition and subtraction operations.</span></span> <span data-ttu-id="6ecf7-118">Wenn Sie dieselben Vorgänge für eine Variable vom Typ [bool](language-reference/builtin-types/bool.md) ausführen möchten, generiert der Compiler einen Fehler, wie im folgenden Beispiel dargestellt:</span><span class="sxs-lookup"><span data-stu-id="6ecf7-118">If you try to perform those same operations on a variable of type [bool](language-reference/builtin-types/bool.md), the compiler generates an error, as shown in the following example:</span></span>  
  
[!code-csharp[Type Safety](../../samples/snippets/csharp/concepts/basic-types/type-safety.cs)]  
  
> [!NOTE]  
> <span data-ttu-id="6ecf7-119">C- und C++-Entwickler sollten beachten, dass in C# [bool](language-reference/builtin-types/bool.md) nicht in [int](language-reference/builtin-types/integral-numeric-types.md) konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-119">C and C++ developers, notice that in C#, [bool](language-reference/builtin-types/bool.md) is not convertible to [int](language-reference/builtin-types/integral-numeric-types.md).</span></span>  
  
<span data-ttu-id="6ecf7-120">Der Compiler bettet die Typinformationen als Metadaten in die ausführbare Datei ein.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-120">The compiler embeds the type information into the executable file as metadata.</span></span> <span data-ttu-id="6ecf7-121">Die Common Language Runtime (CLR) verwendet diese Metadaten zur Laufzeit, um die Typsicherheit zu gewährleisten, wenn Speicherplatz belegt und freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-121">The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</span></span>  

## <a name="specifying-types-in-variable-declarations"></a><span data-ttu-id="6ecf7-122">Angeben von Typen in Variablendeklarationen</span><span class="sxs-lookup"><span data-stu-id="6ecf7-122">Specifying types in variable declarations</span></span>

<span data-ttu-id="6ecf7-123">Wenn Sie eine Variable oder Konstante in einem Programm deklarieren, müssen Sie den Typ festlegen oder das [var](language-reference/keywords/var.md)-Schlüsselwort verwenden, damit der Typ vom Compiler abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-123">When you declare a variable or constant in a program, you must either specify its type or use the [var](language-reference/keywords/var.md) keyword to let the compiler infer the type.</span></span> <span data-ttu-id="6ecf7-124">Im folgenden Beispiel werden einige Variablendeklarationen dargestellt, die sowohl integrierte numerische Typen als auch komplexe benutzerdefinierte Typen verwenden:</span><span class="sxs-lookup"><span data-stu-id="6ecf7-124">The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</span></span>  
  
[!code-csharp[Variable Declaration](../../samples/snippets/csharp/concepts/basic-types/variable-declaration.cs)]  
  
<span data-ttu-id="6ecf7-125">Die Methodenparameter- und Rückgabewerttypen werden in der Methodensignatur angegeben.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-125">The types of method parameters and return values are specified in the method signature.</span></span> <span data-ttu-id="6ecf7-126">Die folgende Signatur zeigt eine Methode, für die ein [int](language-reference/builtin-types/integral-numeric-types.md) als Eingabeargument benötigt wird und die eine Zeichenfolge zurückgibt:</span><span class="sxs-lookup"><span data-stu-id="6ecf7-126">The following signature shows a method that requires an [int](language-reference/builtin-types/integral-numeric-types.md) as an input argument and returns a string:</span></span>  
  
[!code-csharp[Method Signature](../../samples/snippets/csharp/concepts/basic-types/method-signature.cs)]  
  
<span data-ttu-id="6ecf7-127">Nachdem eine Variable deklariert wurde, kann sie nicht erneut mit einem neuen Typ deklariert werden. Außerdem kann ihr kein Wert zugewiesen werden, der nicht mit dem deklarierten Typ kompatibel ist.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-127">After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.</span></span> <span data-ttu-id="6ecf7-128">Beispielsweise können Sie keinen Typ [int](language-reference/builtin-types/integral-numeric-types.md) deklarieren und diesem dann den booleschen Wert `true` zuweisen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-128">For example, you cannot declare an [int](language-reference/builtin-types/integral-numeric-types.md) and then assign it a Boolean value of `true`.</span></span> <span data-ttu-id="6ecf7-129">Werte können jedoch in andere Typen konvertiert werden, z. B., wenn diese neuen Variablen zugewiesen oder als Methodenargumente übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-129">However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.</span></span> <span data-ttu-id="6ecf7-130">Eine *Typkonvertierung*, die keinen Datenverlust verursacht, wird automatisch vom Compiler ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-130">A *type conversion* that does not cause data loss is performed automatically by the compiler.</span></span> <span data-ttu-id="6ecf7-131">Eine Konvertierung, die möglicherweise Datenverlust verursacht, erfordert eine *Umwandlung* in den Quellcode.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-131">A conversion that might cause data loss requires a *cast* in the source code.</span></span>

<span data-ttu-id="6ecf7-132">Weitere Informationen finden Sie unter [Umwandlung und Typkonvertierungen](programming-guide/types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-132">For more information, see [Casting and type conversions](programming-guide/types/casting-and-type-conversions.md).</span></span>

## <a name="built-in-types"></a><span data-ttu-id="6ecf7-133">Integrierte Typen</span><span class="sxs-lookup"><span data-stu-id="6ecf7-133">Built-in types</span></span>

<span data-ttu-id="6ecf7-134">C# liefert einen Standardsatz mit integrierten numerischen Typen zur Darstellung von ganzen Zahlen, Gleitkommawerten, booleschen Ausdrücken, Textzeichen, Dezimalwerten und anderen Datentypen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-134">C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</span></span> <span data-ttu-id="6ecf7-135">Es gibt auch integrierte **Zeichenfolgen**- und **Objekt**-Typen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-135">There are also built-in **string** and **object** types.</span></span> <span data-ttu-id="6ecf7-136">Diese können Sie in jedem C#-Programm verwenden.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-136">These are available for you to use in any C# program.</span></span> <span data-ttu-id="6ecf7-137">Eine vollständige Liste der integrierten Typen finden Sie unter [Integrierte Typen](language-reference/builtin-types/built-in-types.md).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-137">For the complete list of the built-in types, see [Built-in types](language-reference/builtin-types/built-in-types.md).</span></span>
  
## <a name="custom-types"></a><span data-ttu-id="6ecf7-138">Benutzerdefinierte Typen</span><span class="sxs-lookup"><span data-stu-id="6ecf7-138">Custom types</span></span>

<span data-ttu-id="6ecf7-139">Sie können die Konstrukte [struct](language-reference/builtin-types/struct.md), [class](language-reference/keywords/class.md), [interface](language-reference/keywords/interface.md) und [enum](language-reference/builtin-types/enum.md) verwenden, um eigene benutzerdefinierte Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-139">You use the [struct](language-reference/builtin-types/struct.md), [class](language-reference/keywords/class.md), [interface](language-reference/keywords/interface.md), and [enum](language-reference/builtin-types/enum.md) constructs to create your own custom types.</span></span> <span data-ttu-id="6ecf7-140">Die .NET-Klassenbibliothek ist eine Auflistung benutzerdefinierter, von Microsoft bereitgestellter Typen, die Sie in Ihren eigenen Anwendungen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-140">The .NET class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</span></span> <span data-ttu-id="6ecf7-141">Standardmäßig sind die am häufigsten verwendeten Typen in der Klassenbibliothek in jedem C#-Programm verfügbar.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-141">By default, the most frequently used types in the class library are available in any C# program.</span></span> <span data-ttu-id="6ecf7-142">Andere stehen nur zur Verfügung, wenn Sie ausdrücklich einen Projektverweis auf die Assembly hinzufügen, in der diese definiert sind.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-142">Others become available only when you explicitly add a project reference to the assembly in which they are defined.</span></span> <span data-ttu-id="6ecf7-143">Wenn der Compiler über einen Verweis auf die Assembly verfügt, können Sie Variablen (und Konstanten) des in dieser Assembly deklarierten Typs im Quellcode deklarieren.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-143">After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</span></span>
  
## <a name="generic-types"></a><span data-ttu-id="6ecf7-144">Generische Typen</span><span class="sxs-lookup"><span data-stu-id="6ecf7-144">Generic types</span></span>

<span data-ttu-id="6ecf7-145">Ein Typ kann mit einem oder mehreren *Typparametern* deklariert werden, die als Platzhalter für den eigentlichen Typ verwendet werden (den *konkreten Typ*), der vom Clientcode beim Erstellen einer Instanz des Typs bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-145">A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type.</span></span> <span data-ttu-id="6ecf7-146">Solche Typen werden als *generische Typen* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-146">Such types are called *generic types*.</span></span> <span data-ttu-id="6ecf7-147">Beispielsweise besitzt <xref:System.Collections.Generic.List%601> einen Typparameter, der üblicherweise *T* benannt wird. Beim Erstellen einer Instanz des Typs geben Sie die Objekte an, die die Liste enthalten soll, z. B. string:</span><span class="sxs-lookup"><span data-stu-id="6ecf7-147">For example, <xref:System.Collections.Generic.List%601> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</span></span>  
  
[!code-csharp[Generic types](../../samples/snippets/csharp/concepts/basic-types/generic-type.cs)]
  
<span data-ttu-id="6ecf7-148">Die Verwendung des Typparameters ermöglicht die Wiederverwendung der Klasse für beliebige Elementtypen, ohne die einzelnen Elemente in [object](language-reference/builtin-types/reference-types.md#the-object-type) konvertieren zu müssen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-148">The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](language-reference/builtin-types/reference-types.md#the-object-type).</span></span> <span data-ttu-id="6ecf7-149">Generische Sammlungsklassen werden als *stark typisierte Sammlungen* bezeichnet, weil der Compiler den jeweiligen Typ der Elemente in der Sammlung kennt und zur Kompilierzeit einen Fehler auslösen kann, wenn Sie beispielsweise versuchen, dem `strings`-Objekt im vorherigen Beispiel eine ganze Zahl hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-149">Generic collection classes are called *strongly typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `strings` object in the previous example.</span></span> <span data-ttu-id="6ecf7-150">Weitere Informationen finden Sie unter [Generics](programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-150">For more information, see [Generics](programming-guide/generics/index.md).</span></span>

## <a name="implicit-types-anonymous-types-and-tuple-types"></a><span data-ttu-id="6ecf7-151">Implizite Typen, anonyme Typen und Tupel-Typen</span><span class="sxs-lookup"><span data-stu-id="6ecf7-151">Implicit types, anonymous types, and tuple types</span></span>

<span data-ttu-id="6ecf7-152">Wie bereits zuvor erläutert, können Sie eine lokale Variable (jedoch keine Klassenmember) implizit eingeben, indem Sie das [var](language-reference/keywords/var.md)-Schlüsselwort verwenden.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-152">As stated previously, you can implicitly type a local variable (but not class members) by using the [var](language-reference/keywords/var.md) keyword.</span></span> <span data-ttu-id="6ecf7-153">Die Variable erhält weiterhin zur Kompilierzeit einen Typ, aber der Typ wird vom Compiler bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-153">The variable still receives a type at compile time, but the type is provided by the compiler.</span></span> <span data-ttu-id="6ecf7-154">Weitere Informationen finden Sie unter [Implizit typisierte lokale Variablen](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-154">For more information, see [Implicitly typed local variables](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
<span data-ttu-id="6ecf7-155">In einigen Fällen ist es unpraktisch, einen benannten Typ für einfache Sätze verwandter Werte zu erstellen, die nicht außerhalb von Methodengrenzen gespeichert oder übergeben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-155">In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.</span></span> <span data-ttu-id="6ecf7-156">Sie können für diesen Zweck *anonyme Typen* erstellen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-156">You can create *anonymous types* for this purpose.</span></span> <span data-ttu-id="6ecf7-157">Weitere Informationen finden Sie unter [Anonyme Klassentypen](programming-guide/classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-157">For more information, see [Anonymous types](programming-guide/classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="6ecf7-158">Es ist üblich, mehr als einen Wert aus einer Methode zurückgeben zu wollen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-158">It's common to want to return more than one value from a method.</span></span> <span data-ttu-id="6ecf7-159">Sie können *Tupeltypen* erstellen, die mehrere Werte in einem Methodenaufruf zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-159">You can create *tuple types* that return multiple values in a single method call.</span></span> <span data-ttu-id="6ecf7-160">Weitere Informationen finden Sie unter [Tupeltypen](language-reference/builtin-types/value-tuples.md).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-160">For more information, see [Tuple types](language-reference/builtin-types/value-tuples.md).</span></span>

## <a name="the-common-type-system"></a><span data-ttu-id="6ecf7-161">Das allgemeine Typsystem</span><span class="sxs-lookup"><span data-stu-id="6ecf7-161">The Common type system</span></span>

<span data-ttu-id="6ecf7-162">Mit zwei grundlegenden Punkten über das System der Typen in .NET sollten Sie vertraut sein:</span><span class="sxs-lookup"><span data-stu-id="6ecf7-162">It is important to understand two fundamental points about the type system in .NET:</span></span>  
  
- <span data-ttu-id="6ecf7-163">Es unterstützt das Prinzip der Vererbung.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-163">It supports the principle of inheritance.</span></span> <span data-ttu-id="6ecf7-164">Typen können von anderen Typen abgeleitet werden, die als *Basistypen* bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-164">Types can derive from other types, called *base types*.</span></span> <span data-ttu-id="6ecf7-165">Der abgeleitete Typ erbt (mit einigen Beschränkungen) die Methoden, Eigenschaften und anderen Member des Basistyps.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-165">The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</span></span> <span data-ttu-id="6ecf7-166">Der Basistyp kann wiederum von einem anderen Typ abgeleitet sein. In diesem Fall erbt der abgeleitete Typ die Member beider Basistypen in der Vererbungshierarchie.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-166">The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</span></span> <span data-ttu-id="6ecf7-167">Alle Typen, einschließlich integrierter numerischer Typen, z.B. <xref:System.Int32> (C#-Schlüsselwort: `int`), werden letztendlich von einem einzelnen Basistyp abgeleitet, nämlich <xref:System.Object> (C#-Schlüsselwort: `object`).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-167">All types, including built-in numeric types such as <xref:System.Int32> (C# keyword: `int`), derive ultimately from a single base type, which is <xref:System.Object> (C# keyword: `object`).</span></span> <span data-ttu-id="6ecf7-168">Diese einheitliche Typhierarchie wird als [Allgemeines Typsystem](../standard/common-type-system.md) (Common Type System – CTS) bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-168">This unified type hierarchy is called the [Common type system](../standard/common-type-system.md) (CTS).</span></span> <span data-ttu-id="6ecf7-169">Weitere Informationen zur Vererbung in C# finden Sie unter [Vererbung](programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-169">For more information about inheritance in C#, see [Inheritance](programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
- <span data-ttu-id="6ecf7-170">Jeder Typ im CTS ist als *Werttyp* oder *Referenztyp* definiert.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-170">Each type in the CTS is defined as either a *value type* or a *reference type*.</span></span> <span data-ttu-id="6ecf7-171">Dies betrifft auch alle benutzerdefinierten Typen in der .NET-Klassenbibliothek und Ihre eigenen benutzerdefinierten Typen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-171">This includes all custom types in the .NET class library and also your own user-defined types.</span></span> <span data-ttu-id="6ecf7-172">Typen, die Sie mit dem Schlüsselwort `struct` oder `enum` definieren, sind Werttypen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-172">Types that you define by using the `struct` or `enum` keyword are value types.</span></span> <span data-ttu-id="6ecf7-173">Weitere Informationen zu Werttypen finden Sie unter [Werttypen](language-reference/builtin-types/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-173">For more information about value types, see [Value types](language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="6ecf7-174">Typen, die Sie mithilfe des [class](language-reference/keywords/class.md)-Schlüsselworts definieren, sind Referenztypen.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-174">Types that you define by using the [class](language-reference/keywords/class.md) keyword are reference types.</span></span> <span data-ttu-id="6ecf7-175">Weitere Informationen über Referenztypen finden Sie unter [Classes](programming-guide/classes-and-structs/classes.md).</span><span class="sxs-lookup"><span data-stu-id="6ecf7-175">For more information about reference types, see [Classes](programming-guide/classes-and-structs/classes.md).</span></span> <span data-ttu-id="6ecf7-176">Für Referenztypen und Werttypen gelten unterschiedliche Kompilierzeitregeln und ein anderes Laufzeitverhalten.</span><span class="sxs-lookup"><span data-stu-id="6ecf7-176">Reference types and value types have different compile-time rules, and different run-time behavior.</span></span>

## <a name="see-also"></a><span data-ttu-id="6ecf7-177">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="6ecf7-177">See also</span></span>

- [<span data-ttu-id="6ecf7-178">Strukturtypen</span><span class="sxs-lookup"><span data-stu-id="6ecf7-178">Structure types</span></span>](language-reference/builtin-types/struct.md)
- [<span data-ttu-id="6ecf7-179">Enumerationstypen</span><span class="sxs-lookup"><span data-stu-id="6ecf7-179">Enumeration types</span></span>](language-reference/builtin-types/enum.md)
- [<span data-ttu-id="6ecf7-180">Klassen</span><span class="sxs-lookup"><span data-stu-id="6ecf7-180">Classes</span></span>](programming-guide/classes-and-structs/classes.md)
