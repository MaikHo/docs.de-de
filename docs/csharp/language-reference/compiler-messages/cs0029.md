---
description: Compilerfehler CS0029
title: Compilerfehler CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: 310a730733cb76b0afb29f5496ad22b77fb29243
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 08/30/2020
ms.locfileid: "89139930"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="8170c-103">Compilerfehler CS0029</span><span class="sxs-lookup"><span data-stu-id="8170c-103">Compiler Error CS0029</span></span>

<span data-ttu-id="8170c-104">Kann den Typ „type“ nicht implizit in „type“ konvertieren</span><span class="sxs-lookup"><span data-stu-id="8170c-104">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="8170c-105">Der Compiler erfordert eine explizite Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="8170c-105">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="8170c-106">Sie müssen z.B. einen r-Wert in den gleichen Typ wie einen l-Wert umwandeln.</span><span class="sxs-lookup"><span data-stu-id="8170c-106">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="8170c-107">Oder Sie müssen zur Unterstützung bestimmter Operatorüberladungen Konvertierungsroutinen angeben.</span><span class="sxs-lookup"><span data-stu-id="8170c-107">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="8170c-108">Sie müssen Konvertierungen durchführen, wenn Sie eine Variablen eines Typs einer Variablen eines andere Typs zuweisen.</span><span class="sxs-lookup"><span data-stu-id="8170c-108">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="8170c-109">Wenn Sie eine Zuweisung zwischen Variablen verschiedener Typen durchführen, muss der Compiler den Typ der rechten Seite des Zuweisungsoperator in den Typ der linken Seite des Zuweisungsoperators konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8170c-109">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="8170c-110">Nehmen Sie z.B. den folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="8170c-110">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="8170c-111">`i = lng;` führt eine Zuweisung durch, aber die Datentypen der Variablen auf der linken und der rechten Seite des Zuweisungsoperators stimmen nicht überein.</span><span class="sxs-lookup"><span data-stu-id="8170c-111">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="8170c-112">Vor der Zuweisung konvertiert der Compiler implizit die Variable `lng`, die vom Typ „long“ ist, in den Typ „int“. Dies geschieht implizit, da kein Code den Compiler explizit angewiesen hat, diese Konvertierung durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="8170c-112">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="8170c-113">Das Problematische an diesem Code ist, dass dies als einschränkende Konvertierung angesehen, und der Compiler lässt keine einschränkenden Konvertierungen zu, da diese zu Datenverlusten führen könnte.</span><span class="sxs-lookup"><span data-stu-id="8170c-113">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="8170c-114">Eine einschränkende Konvertierung besteht, wenn Sie in einen Datentyp konvertieren, der weniger Speicherplatz im Arbeitsspeicher in Anspruch nimmt als der Datentyp, der konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="8170c-114">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="8170c-115">Wenn Sie z.B. den Typ „long“ in den Typ „int“ konvertieren, wird dies als einschränkende Konvertierung angesehen.</span><span class="sxs-lookup"><span data-stu-id="8170c-115">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="8170c-116">Der Typ „long“ nimmt 8 Byte Arbeitsspeicher in Anspruch, während ein Typ „int“ nur 4 Byte in Anspruch nimmt.</span><span class="sxs-lookup"><span data-stu-id="8170c-116">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="8170c-117">Um zu sehen, wie es zu Datenverlust kommen kann, schauen Sie sich das folgende Beispiel an:</span><span class="sxs-lookup"><span data-stu-id="8170c-117">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="8170c-118">Die Variable `lng` enthält nun einen Wert, der nicht in der Variable `i` gespeichert werden kann, da er zu groß ist.</span><span class="sxs-lookup"><span data-stu-id="8170c-118">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="8170c-119">Wenn Sie nun diesen Wert in den Typ „int“ konvertieren würden, würden Sie einige Ihrer Daten verlieren, und der konvertierte Wert wäre nicht der gleiche wie vor der Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="8170c-119">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="8170c-120">Eine erweiternde Konvertierung ist das Gegenteil einer einschränkenden Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="8170c-120">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="8170c-121">Bei erweiternden Konvertierungen wird eine Konvertierung in einen Datentyp durchgeführt, der mehr Platz in Anspruch nimmt als der Typ, der konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="8170c-121">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="8170c-122">Dies ist ein Beispiel für eine erweiternde Konvertierung:</span><span class="sxs-lookup"><span data-stu-id="8170c-122">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="8170c-123">Beachten Sie den Unterschied zwischen diesem und dem ersten Codebeispiel.</span><span class="sxs-lookup"><span data-stu-id="8170c-123">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="8170c-124">Dieses Mal befindet sich die Variable `lng` auf der rechten Seite des Zuweisungsoperators, sodass Sie das Ziel der Zuweisung darstellt.</span><span class="sxs-lookup"><span data-stu-id="8170c-124">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="8170c-125">Vor der Zuweisung muss der Compiler die Variable `i` des Typ „int“ implizit in den Typ „long“ konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8170c-125">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="8170c-126">Dabei handelt es sich um eine erweiternde Konvertierung, da Sie einen Typ, der 4 Byte in Anspruch nimmt (int), in einen Typ, der 8 Byte in Anspruch nimmt (long), konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8170c-126">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="8170c-127">Implizite erweiternde Konvertierungen sind zulässig, da es dabei nicht zu Datenverlusten kommen kann.</span><span class="sxs-lookup"><span data-stu-id="8170c-127">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="8170c-128">Jeder Wert, der in einem int-Typ gespeichert werden kann, kann auch in einem long-Typ gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="8170c-128">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="8170c-129">Sie wissen, dass implizite einschränkende Konvertierungen nicht zulässig sind. Deshalb müssen Sie den Datentyp explizit konvertieren, um diesen Code kompilieren zu können.</span><span class="sxs-lookup"><span data-stu-id="8170c-129">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="8170c-130">Explizite Konvertierungen erfolgen durch eine Umwandlung.</span><span class="sxs-lookup"><span data-stu-id="8170c-130">Explicit conversions are done using casting.</span></span> <span data-ttu-id="8170c-131">Umwandlung ist der in C# verwendete Begriff für die Konvertierung eines Datentyps in einen anderen.</span><span class="sxs-lookup"><span data-stu-id="8170c-131">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="8170c-132">Damit der Code kompiliert, müssen Sie folgende Syntax verwenden.</span><span class="sxs-lookup"><span data-stu-id="8170c-132">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="8170c-133">Die dritte Codezeile weist den Compiler an, die Variable `lng` des Typs „long“ vor der Zuweisung explizit in den Typ „long“ zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8170c-133">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="8170c-134">Denken Sie daran, dass es bei einer einschränkenden Konvertierung zu Datenverlusten kommen kann.</span><span class="sxs-lookup"><span data-stu-id="8170c-134">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="8170c-135">Einschränkende Konvertierungen sollten mit Vorsicht eingesetzt werden, und auch wenn der Code kompiliert, erhalten Sie möglicherweise zur Laufzeit unerwartete Ergebnisse.</span><span class="sxs-lookup"><span data-stu-id="8170c-135">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="8170c-136">Dies bezieht sich nur auf Werttypen.</span><span class="sxs-lookup"><span data-stu-id="8170c-136">This discussion has only been for value types.</span></span> <span data-ttu-id="8170c-137">Wenn Sie mit Werttypen arbeiten, arbeiten Sie mit Daten, die direkt in der Variablen gespeichert sind.</span><span class="sxs-lookup"><span data-stu-id="8170c-137">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="8170c-138">.NET Framework hat aber auch Verweistypen.</span><span class="sxs-lookup"><span data-stu-id="8170c-138">However, the .NET Framework also has reference types.</span></span> <span data-ttu-id="8170c-139">Wenn Sie mit Verweistypen arbeiten, arbeiten Sie mit einem Verweis auf eine Variable und nicht mit den tatsächlichen Daten.</span><span class="sxs-lookup"><span data-stu-id="8170c-139">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="8170c-140">Beispiele für Verweistypen sind Klassen, Schnittstellen und Arrays.</span><span class="sxs-lookup"><span data-stu-id="8170c-140">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="8170c-141">Sie können einen Verweistyp weder explizit noch implizit in einen anderen konvertieren, es sei denn, der Compiler lässt die spezifische Konvertierung zu, oder die entsprechenden Konvertierungsoperatoren sind implementiert.</span><span class="sxs-lookup"><span data-stu-id="8170c-141">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="8170c-142">Im folgenden Beispiel wird CS0029 generiert:</span><span class="sxs-lookup"><span data-stu-id="8170c-142">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="8170c-143">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="8170c-143">See also</span></span>

- [<span data-ttu-id="8170c-144">Benutzerdefinierte Konvertierungsoperatoren</span><span class="sxs-lookup"><span data-stu-id="8170c-144">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
