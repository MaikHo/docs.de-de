---
title: Umwandlung und Typkonvertierungen – C#-Programmierhandbuch
description: Erfahren Sie mehr über Umwandlungen und Typkonvertierungen, z. B. implizite oder explizite Umwandlungen und benutzerdefinierte Konvertierungen.
ms.date: 07/06/2020
helpviewer_keywords:
- type conversion [C#]
- data type conversion [C#]
- numeric conversions [C#]
- conversions [C#], type
- casting [C#]
- converting types [C#]
ms.assetid: 568df58a-d292-4b55-93ba-601578722878
ms.openlocfilehash: cfe5376675808559f4bf9c9cd8b21180dcd0cc49
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/15/2020
ms.locfileid: "90555327"
---
# <a name="casting-and-type-conversions-c-programming-guide"></a><span data-ttu-id="5fe14-103">Umwandlung und Typkonvertierungen (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="5fe14-103">Casting and type conversions (C# Programming Guide)</span></span>

<span data-ttu-id="5fe14-104">Weil C# zur Kompilierzeit statisch typisiert ist, kann eine Variable, nachdem sie deklariert wurde, nicht erneut deklariert werden oder einen Wert von einem anderen Typ zugewiesen bekommen, es sei denn, dieser Typ ist implizit in den Typ der Variable konvertierbar.</span><span class="sxs-lookup"><span data-stu-id="5fe14-104">Because C# is statically-typed at compile time, after a variable is declared, it cannot be declared again or assigned a value of another type unless that type is implicitly convertible to the variable's type.</span></span> <span data-ttu-id="5fe14-105">`string` kann beispielsweise nicht implizit in `int` konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="5fe14-105">For example, the `string` cannot be implicitly converted to `int`.</span></span> <span data-ttu-id="5fe14-106">Deshalb können Sie, nachdem Sie `i` als `int` deklariert haben, nicht die Zeichenfolge „Hello“ zuweisen. Dies wird im folgenden Beispiel veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="5fe14-106">Therefore, after you declare `i` as an `int`, you cannot assign the string "Hello" to it, as the following code shows:</span></span>

```csharp
int i;

// error CS0029: Cannot implicitly convert type 'string' to 'int'
i = "Hello";
```

<span data-ttu-id="5fe14-107">Manchmal müssen Sie möglicherweise einen Wert in eine Variable oder einen Methodenparameter eines anderen Typen kopieren.</span><span class="sxs-lookup"><span data-stu-id="5fe14-107">However, you might sometimes need to copy a value into a variable or method parameter of another type.</span></span> <span data-ttu-id="5fe14-108">Sie haben z.B. möglicherweise eine Ganzzahlvariable, die Sie an eine Methode übergeben müssen, deren Parameter vom Type `double` ist.</span><span class="sxs-lookup"><span data-stu-id="5fe14-108">For example, you might have an integer variable that you need to pass to a method whose parameter is typed as `double`.</span></span> <span data-ttu-id="5fe14-109">Möglicherweise müssen Sie auch einer Variablen eines Schnittstellentyps eine Klassenvariable zuweisen.</span><span class="sxs-lookup"><span data-stu-id="5fe14-109">Or you might need to assign a class variable to a variable of an interface type.</span></span> <span data-ttu-id="5fe14-110">Derartige Vorgänge werden als *Typkonvertierungen* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="5fe14-110">These kinds of operations are called *type conversions*.</span></span> <span data-ttu-id="5fe14-111">In C# können Sie folgende Arten von Konvertierungen durchführen:</span><span class="sxs-lookup"><span data-stu-id="5fe14-111">In C#, you can perform the following kinds of conversions:</span></span>

- <span data-ttu-id="5fe14-112">**Implizite Konvertierungen**: Es ist keine besondere Syntax erforderlich, da die Konvertierung immer erfolgreich ist und keine Daten verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="5fe14-112">**Implicit conversions**: No special syntax is required because the conversion always succeeds and no data will be lost.</span></span> <span data-ttu-id="5fe14-113">Beispiele sind Konvertierungen von kleinere in größere Ganzzahltypen und Konvertierungen von abgeleiteten in Basisklassen.</span><span class="sxs-lookup"><span data-stu-id="5fe14-113">Examples include conversions from smaller to larger integral types, and conversions from derived classes to base classes.</span></span>

- <span data-ttu-id="5fe14-114">**Explizite Konvertierungen (Umwandlungen)** : Für explizite Konvertierungen ist ein [Cast-Ausdruck](../../language-reference/operators/type-testing-and-cast.md#cast-expression) erforderlich.</span><span class="sxs-lookup"><span data-stu-id="5fe14-114">**Explicit conversions (casts)**: Explicit conversions require a [cast expression](../../language-reference/operators/type-testing-and-cast.md#cast-expression).</span></span> <span data-ttu-id="5fe14-115">Eine Umwandlung ist erforderlich, wenn Informationen bei einer Konvertierung verloren gehen können oder wenn die Konvertierung aus anderen Gründen fehlschlagen könnte.</span><span class="sxs-lookup"><span data-stu-id="5fe14-115">Casting is required when information might be lost in the conversion, or when the conversion might not succeed for other reasons.</span></span> <span data-ttu-id="5fe14-116">Häufig auftretende Beispiele sind u.a. numerische Konvertierungen in einen Typen, der eine geringere Genauigkeit oder einen kleineren Bereich aufweist, oder Konvertierungen einer Instanz einer Basisklasse in eine abgeleitete Klasse.</span><span class="sxs-lookup"><span data-stu-id="5fe14-116">Typical examples include numeric conversion to a type that has less precision or a smaller range, and conversion of a base-class instance to a derived class.</span></span>

- <span data-ttu-id="5fe14-117">**Benutzerdefinierte Konvertierungen**: Benutzerdefinierte Konvertierungen werden anhand spezieller Methoden durchgeführt, die Sie definieren können, um explizite und implizite Konvertierungen zwischen benutzerdefinierten Typen zu ermöglichen, die nicht in einer Beziehung „Basisklasse – abgeleitete Klasse“ zueinander stehen.</span><span class="sxs-lookup"><span data-stu-id="5fe14-117">**User-defined conversions**: User-defined conversions are performed by special methods that you can define to enable explicit and implicit conversions between custom types that do not have a base class–derived class relationship.</span></span> <span data-ttu-id="5fe14-118">Weitere Informationen finden Sie unter [Benutzerdefinierte Konvertierungsoperatoren](../../language-reference/operators/user-defined-conversion-operators.md).</span><span class="sxs-lookup"><span data-stu-id="5fe14-118">For more information, see [User-defined conversion operators](../../language-reference/operators/user-defined-conversion-operators.md).</span></span>

- <span data-ttu-id="5fe14-119">**Konvertierungen mit Hilfsklassen**: Für eine Konvertierung von nicht kompatiblen Typen, z.B. von ganzen Zahlen und <xref:System.DateTime?displayProperty=nameWithType>-Objekten, oder von Hexadezimalzeichenfolgen und Bytearrays können Sie die <xref:System.BitConverter?displayProperty=nameWithType>-Klasse, die <xref:System.Convert?displayProperty=nameWithType>-Klasse und die `Parse`-Methoden der integrierten numerischen Typen (z.B. <xref:System.Int32.Parse%2A?displayProperty=nameWithType>) verwenden.</span><span class="sxs-lookup"><span data-stu-id="5fe14-119">**Conversions with helper classes**: To convert between non-compatible types, such as integers and <xref:System.DateTime?displayProperty=nameWithType> objects, or hexadecimal strings and byte arrays, you can use the <xref:System.BitConverter?displayProperty=nameWithType> class, the <xref:System.Convert?displayProperty=nameWithType> class, and the `Parse` methods of the built-in numeric types, such as <xref:System.Int32.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5fe14-120">Weitere Informationen finden Sie unter [Vorgehensweise: Konvertieren eines Bytearrays in einen ganzzahligen Typ](./how-to-convert-a-byte-array-to-an-int.md), [Vorgehensweise: Konvertieren einer Zeichenfolge in eine Zahl](./how-to-convert-a-string-to-a-number.md) und [Vorgehensweise: Konvertieren zwischen Hexadezimalzeichenfolgen und numerischen Typen](./how-to-convert-between-hexadecimal-strings-and-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="5fe14-120">For more information, see [How to convert a byte array to an int](./how-to-convert-a-byte-array-to-an-int.md), [How to convert a string to a number](./how-to-convert-a-string-to-a-number.md), and [How to convert between hexadecimal strings and numeric types](./how-to-convert-between-hexadecimal-strings-and-numeric-types.md).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="5fe14-121">Implizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="5fe14-121">Implicit conversions</span></span>

<span data-ttu-id="5fe14-122">Eine implizite Konvertierung kann für integrierte numerische Typen durchgeführt werden, wenn der zu speichernde Wert in die Variable passt, ohne abgeschnitten oder abgerundet zu werden.</span><span class="sxs-lookup"><span data-stu-id="5fe14-122">For built-in numeric types, an implicit conversion can be made when the value to be stored can fit into the variable without being truncated or rounded off.</span></span> <span data-ttu-id="5fe14-123">Für integrale Typen bedeutet dies, dass der Bereich des Quelltyps eine korrekte Teilmenge des Bereichs für den Zieltyp ist.</span><span class="sxs-lookup"><span data-stu-id="5fe14-123">For integral types, this means the range of the source type is a proper subset of the range for the target type.</span></span> <span data-ttu-id="5fe14-124">Zum Beispiel kann eine Variable vom Typ [long](../../language-reference/builtin-types/integral-numeric-types.md) (64-Bit-Integer) jeden Wert speichern, den eine Variable vom Typ [int](../../language-reference/builtin-types/integral-numeric-types.md) (32-Bit-Integer) speichern kann.</span><span class="sxs-lookup"><span data-stu-id="5fe14-124">For example, a variable of type [long](../../language-reference/builtin-types/integral-numeric-types.md) (64-bit integer) can store any value that an [int](../../language-reference/builtin-types/integral-numeric-types.md) (32-bit integer) can store.</span></span> <span data-ttu-id="5fe14-125">Im folgenden Beispiel konvertiert der Compiler den Wert von `num` auf der rechten Seite implizit in einen `long`-Typ, bevor er ihn `bigNum` zuweist.</span><span class="sxs-lookup"><span data-stu-id="5fe14-125">In the following example, the compiler implicitly converts the value of `num` on the right to a type `long` before assigning it to `bigNum`.</span></span>

[!code-csharp[csProgGuideTypes#34](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#34)]

<span data-ttu-id="5fe14-126">Eine vollständige Liste aller impliziten numerischen Konvertierungen finden Sie unter [Implizite numerische Konvertierungen](../../language-reference/builtin-types/numeric-conversions.md#implicit-numeric-conversions) im Artikel [Integrierte numerische Konvertierungen (C#-Referenz)](../../language-reference/builtin-types/numeric-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="5fe14-126">For a complete list of all implicit numeric conversions, see the [Implicit numeric conversions](../../language-reference/builtin-types/numeric-conversions.md#implicit-numeric-conversions) section of the [Built-in numeric conversions](../../language-reference/builtin-types/numeric-conversions.md) article.</span></span>

<span data-ttu-id="5fe14-127">Eine implizite Konvertierungen für Verweistypen von einer Klasse in jede ihrer direkten oder indirekten Basisklassen oder Schnittstellen ist immer möglich.</span><span class="sxs-lookup"><span data-stu-id="5fe14-127">For reference types, an implicit conversion always exists from a class to any one of its direct or indirect base classes or interfaces.</span></span> <span data-ttu-id="5fe14-128">Es ist keine spezielle Syntax erforderlich, da eine abgeleitete Klasse immer alle Member der Basisklasse enthält.</span><span class="sxs-lookup"><span data-stu-id="5fe14-128">No special syntax is necessary because a derived class always contains all the members of a base class.</span></span>

```csharp
Derived d = new Derived();

// Always OK.
Base b = d;
```

## <a name="explicit-conversions"></a><span data-ttu-id="5fe14-129">Explizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="5fe14-129">Explicit conversions</span></span>

<span data-ttu-id="5fe14-130">Wenn allerdings eine Konvertierung nicht ohne möglichen Informationsverlust durchgeführt werden kann, fordert der Compiler eine explizite Konvertierung; diese wird als *Umwandlung* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="5fe14-130">However, if a conversion cannot be made without a risk of losing information, the compiler requires that you perform an explicit conversion, which is called a *cast*.</span></span> <span data-ttu-id="5fe14-131">Eine Umwandlung bietet die Möglichkeit, den Compiler explizit zu verständigen, dass Sie eine Konvertierung vornehmen möchten, und dass es Ihnen bewusst ist, dass dies einen Datenverlust zur Folge haben kann. oder die Umwandlung schlägt zur Laufzeit fehl.</span><span class="sxs-lookup"><span data-stu-id="5fe14-131">A cast is a way of explicitly informing the compiler that you intend to make the conversion and that you are aware that data loss might occur, or the cast may fail at runtime.</span></span> <span data-ttu-id="5fe14-132">Wenn Sie eine Umwandlung durchführen möchten, geben Sie den Typ, in den umgewandelt werden soll, in Klammern am Anfang des zu konvertierenden Wertes oder der zu konvertierenden Variablen an.</span><span class="sxs-lookup"><span data-stu-id="5fe14-132">To perform a cast, specify the type that you are casting to in parentheses in front of the value or variable to be converted.</span></span> <span data-ttu-id="5fe14-133">Das folgende Programm wandelt ein [double](../../language-reference/builtin-types/floating-point-numeric-types.md) in ein [int](../../language-reference/builtin-types/integral-numeric-types.md) um. Das Programm führt ohne die Umwandlung keine Kompilierung durch.</span><span class="sxs-lookup"><span data-stu-id="5fe14-133">The following program casts a [double](../../language-reference/builtin-types/floating-point-numeric-types.md) to an [int](../../language-reference/builtin-types/integral-numeric-types.md). The program will not compile without the cast.</span></span>

[!code-csharp[csProgGuideTypes#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#2)]

<span data-ttu-id="5fe14-134">Eine vollständige Liste der expliziten numerischen Konvertierungen finden Sie unter [Explicit numeric conversions](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) (Explizite numerische Konvertierungen) im Artikel [Built-in numeric conversions](../../language-reference/builtin-types/numeric-conversions.md) (Integrierte numerische Konvertierungen).</span><span class="sxs-lookup"><span data-stu-id="5fe14-134">For a complete list of supported explicit numeric conversions, see the [Explicit numeric conversions](../../language-reference/builtin-types/numeric-conversions.md#explicit-numeric-conversions) section of the [Built-in numeric conversions](../../language-reference/builtin-types/numeric-conversions.md) article.</span></span>

<span data-ttu-id="5fe14-135">Eine explizite Umwandlung ist für Verweistypen erforderlich, wenn Sie von einer Basisklasse in eine abgeleitete Klasse konvertieren möchten:</span><span class="sxs-lookup"><span data-stu-id="5fe14-135">For reference types, an explicit cast is required if you need to convert from a base type to a derived type:</span></span>

```csharp
// Create a new derived type.
Giraffe g = new Giraffe();

// Implicit conversion to base type is safe.
Animal a = g;

// Explicit conversion is required to cast back
// to derived type. Note: This will compile but will
// throw an exception at run time if the right-side
// object is not in fact a Giraffe.
Giraffe g2 = (Giraffe)a;
```

<span data-ttu-id="5fe14-136">Ein Umwandlungsvorgang zwischen Verweistypen ändert nicht den Laufzeittypen des zugrunde liegenden Objekts; er ändert lediglich den Typ des Wertes, der als Verweis auf das Objekt verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="5fe14-136">A cast operation between reference types does not change the run-time type of the underlying object; it only changes the type of the value that is being used as a reference to that object.</span></span> <span data-ttu-id="5fe14-137">Weitere Informationen finden Sie unter [Polymorphie](../classes-and-structs/polymorphism.md).</span><span class="sxs-lookup"><span data-stu-id="5fe14-137">For more information, see [Polymorphism](../classes-and-structs/polymorphism.md).</span></span>

## <a name="type-conversion-exceptions-at-run-time"></a><span data-ttu-id="5fe14-138">Typkonvertierungsausnahmen zur Laufzeit</span><span class="sxs-lookup"><span data-stu-id="5fe14-138">Type conversion exceptions at run time</span></span>

<span data-ttu-id="5fe14-139">In manchen Verweistypkonvertierungen kann der Compiler nicht bestimmen, ob eine Umwandlung zulässig wäre.</span><span class="sxs-lookup"><span data-stu-id="5fe14-139">In some reference type conversions, the compiler cannot determine whether a cast will be valid.</span></span> <span data-ttu-id="5fe14-140">Es ist möglich, dass ein Umwandlungsvorgang, der ordnungsgemäß kompiliert, zur Laufzeit fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="5fe14-140">It is possible for a cast operation that compiles correctly to fail at run time.</span></span> <span data-ttu-id="5fe14-141">Eine fehlgeschlagene Typumwandlung zur Laufzeit löst wie in folgendem Beispiel dargestellt eine <xref:System.InvalidCastException> aus.</span><span class="sxs-lookup"><span data-stu-id="5fe14-141">As shown in the following example, a type cast that fails at run time will cause an <xref:System.InvalidCastException> to be thrown.</span></span>

[!code-csharp[csProgGuideTypes#41](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsProgGuideTypes/CS/Class1.cs#41)]

<span data-ttu-id="5fe14-142">Die Methode `Test` verfügt über einen Parameter `Animal`, sodass es eine gefährliche Annahme ist, das Argument `a` explizit in ein `Reptile`-Element umzuwandeln.</span><span class="sxs-lookup"><span data-stu-id="5fe14-142">The `Test` method has an `Animal` parameter, thus explicitly casting the argument `a` to a `Reptile` makes a dangerous assumption.</span></span> <span data-ttu-id="5fe14-143">Es ist sicherer, keine Annahmen zu verwenden, sondern stattdessen den Typ zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="5fe14-143">It is safer to not make assumptions, but rather check the type.</span></span> <span data-ttu-id="5fe14-144">C# stellt den [is](../../language-reference/operators/type-testing-and-cast.md#is-operator)-Operator bereit, sodass Sie die Kompatibilität prüfen können, bevor Sie die Umwandlung tatsächlich ausführen.</span><span class="sxs-lookup"><span data-stu-id="5fe14-144">C# provides the [is](../../language-reference/operators/type-testing-and-cast.md#is-operator) operator to enable you to test for compatibility before actually performing a cast.</span></span> <span data-ttu-id="5fe14-145">Weitere Informationen finden Sie unter [Vorgehensweise: Sicheres Umwandeln mit Musterabgleich und den Operatoren „as“ und „is“](../../how-to/safely-cast-using-pattern-matching-is-and-as-operators.md).</span><span class="sxs-lookup"><span data-stu-id="5fe14-145">For more information, see [How to safely cast using pattern matching and the as and is operators](../../how-to/safely-cast-using-pattern-matching-is-and-as-operators.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="5fe14-146">C#-Sprachspezifikation</span><span class="sxs-lookup"><span data-stu-id="5fe14-146">C# language specification</span></span>

<span data-ttu-id="5fe14-147">Weitere Informationen finden Sie im Abschnitt [Konvertierungen](~/_csharplang/spec/conversions.md) der [C#-Sprachspezifikation](~/_csharplang/spec/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="5fe14-147">For more information, see the [Conversions](~/_csharplang/spec/conversions.md) section of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="5fe14-148">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="5fe14-148">See also</span></span>

- [<span data-ttu-id="5fe14-149">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="5fe14-149">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="5fe14-150">Typen</span><span class="sxs-lookup"><span data-stu-id="5fe14-150">Types</span></span>](./index.md)
- [<span data-ttu-id="5fe14-151">Cast-Ausdruck</span><span class="sxs-lookup"><span data-stu-id="5fe14-151">Cast expression</span></span>](../../language-reference/operators/type-testing-and-cast.md#cast-expression)
- [<span data-ttu-id="5fe14-152">Benutzerdefinierte Konvertierungsoperatoren</span><span class="sxs-lookup"><span data-stu-id="5fe14-152">User-defined conversion operators</span></span>](../../language-reference/operators/user-defined-conversion-operators.md)
- <span data-ttu-id="5fe14-153">[Verallgemeinerte Typkonvertierung](/previous-versions/visualstudio/visual-studio-2013/yy580hbd(v=vs.120))</span><span class="sxs-lookup"><span data-stu-id="5fe14-153">[Generalized Type Conversion](/previous-versions/visualstudio/visual-studio-2013/yy580hbd(v=vs.120))</span></span>
- [<span data-ttu-id="5fe14-154">Konvertieren einer Zeichenfolge in eine Zahl</span><span class="sxs-lookup"><span data-stu-id="5fe14-154">How to convert a string to a number</span></span>](./how-to-convert-a-string-to-a-number.md)
