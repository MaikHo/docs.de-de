---
title: Konzepte und Terminologie (funktionale Transformation) (C#)
description: Funktionale Programmierfunktionen vereinfachen die Transformation von XML. Hier erfahren Sie mehr über die Konzepte und die Terminologie von reinen Funktionstransformationen in C#.
ms.date: 07/20/2015
ms.assetid: 03defb3a-7e17-4ab1-8efa-4dd66621e860
ms.openlocfilehash: ee972b376f0d0898b7681049b9641b43780ed353
ms.sourcegitcommit: 04022ca5d00b2074e1b1ffdbd76bec4950697c4c
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 07/23/2020
ms.locfileid: "87103980"
---
# <a name="concepts-and-terminology-functional-transformation-c"></a><span data-ttu-id="56893-104">Konzepte und Terminologie (funktionale Transformation) (C#)</span><span class="sxs-lookup"><span data-stu-id="56893-104">Concepts and Terminology (Functional Transformation) (C#)</span></span>

<span data-ttu-id="56893-105">Dieses Thema führt Sie in die Konzepte und Begriffe ein, die im Zusammenhang mit reinen funktionalen Transformationen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="56893-105">This topic introduces the concepts and terminology of pure functional transformations.</span></span> <span data-ttu-id="56893-106">Bei Verwendung der funktionalen Transformation zum Transformieren von Daten erhalten Sie Code, der häufig schneller programmiert werden kann, ausdrucksstärker ist und einfacher von Fehlern bereinigt und verwaltet werden kann als Code, der auf die herkömmliche imperative Methode zurückzuführen ist.</span><span class="sxs-lookup"><span data-stu-id="56893-106">The functional transformation approach to transforming data yields code that is often quicker to program, more expressive, and easier to debug and maintain than more traditional, imperative programming.</span></span>

<span data-ttu-id="56893-107">Beachten Sie, dass die Themen in diesem Abschnitt keine vollständige Erläuterung der funktionalen Programmierung darstellen.</span><span class="sxs-lookup"><span data-stu-id="56893-107">Note that the topics in this section are not intended to fully explain functional programming.</span></span> <span data-ttu-id="56893-108">In diesen Themen werden vielmehr einige der Funktionen zur funktionalen Programmierung beschrieben, die das Transformieren von XML von einer Form in eine andere erleichtern.</span><span class="sxs-lookup"><span data-stu-id="56893-108">Instead, these topics identify some of the functional programming capabilities that make it easier to transform XML from one shape to another.</span></span>

## <a name="what-is-pure-functional-transformation"></a><span data-ttu-id="56893-109">Was ist die reine funktionale Transformation?</span><span class="sxs-lookup"><span data-stu-id="56893-109">What Is Pure Functional Transformation?</span></span>

<span data-ttu-id="56893-110">Bei der *reinen funktionalen Transformation* definiert ein Satz von Funktionen, die sogenannten *reinen Funktionen*, wie ein Satz strukturierter Daten aus ihrer Originalform in eine andere Form transformiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="56893-110">In *pure functional transformation*, a set of functions, called *pure functions*, define how to transform a set of structured data from its original form into another form.</span></span> <span data-ttu-id="56893-111">Das Wort „rein“ bedeutet dabei, dass die Funktionen *zusammensetzbar* sind. Dazu müssen sie die folgenden Voraussetzungen erfüllen:</span><span class="sxs-lookup"><span data-stu-id="56893-111">The word "pure" indicates that the functions are *composable*, which requires that they are:</span></span>

- <span data-ttu-id="56893-112">Sie müssen *eigenständig* sein, damit sie frei und ohne jede Verflechtungen oder Abhängigkeiten vom Rest des Programms geordnet und umgeordnet werden können.</span><span class="sxs-lookup"><span data-stu-id="56893-112">*Self-contained*, so that they can be freely ordered and rearranged without entanglement or interdependencies with the rest of the program.</span></span> <span data-ttu-id="56893-113">Reine Transformationen existieren komplett unabhängig von ihrer Umgebung und beeinflussen diese auch nicht.</span><span class="sxs-lookup"><span data-stu-id="56893-113">Pure transformations have no knowledge of or effect upon their environment.</span></span> <span data-ttu-id="56893-114">Damit haben die in der Transformation verwendeten Funktionen keinerlei *Nebenwirkungen*.</span><span class="sxs-lookup"><span data-stu-id="56893-114">That is, the functions used in the transformation have no *side effects*.</span></span>

- <span data-ttu-id="56893-115">Sie müssen *zustandslos* sein, damit das Ausführen ein und derselben Funktion oder eines bestimmten Satzes von Funktionen bei ein und derselben Eingabe auch immer zur selben Ausgabe führt.</span><span class="sxs-lookup"><span data-stu-id="56893-115">*Stateless*, so that executing the same function or specific set of functions on the same input will always result in the same output.</span></span> <span data-ttu-id="56893-116">Reine Transformationen besitzen keine „Erinnerung“ an ihre vorherige Verwendung.</span><span class="sxs-lookup"><span data-stu-id="56893-116">Pure transformations have no memory of their prior use.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="56893-117">Im übrigen Teil dieses Lernprogramms wird der Begriff „reine Funktion“ allgemein als Bezeichnung für einen Programmieransatz und nicht als Bezeichnung für eine bestimmte Sprachfunktion verwendet.</span><span class="sxs-lookup"><span data-stu-id="56893-117">In the rest of this tutorial, the term "pure function" is used in a general sense to indicate a programming approach, and not a specific language feature.</span></span>
>
> <span data-ttu-id="56893-118">Beachten Sie, dass reine Funktionen in C# als Methoden implementiert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="56893-118">Note that pure functions must be implemented as methods in C#.</span></span>
>
> <span data-ttu-id="56893-119">Verwechseln Sie bitte auch nicht die reinen Funktionen mit den reinen virtuellen Methoden in C++.</span><span class="sxs-lookup"><span data-stu-id="56893-119">Also, you should not confuse pure functions with pure virtual methods in C++.</span></span> <span data-ttu-id="56893-120">Die reinen virtuellen Methoden in C++ geben an, dass die enthaltene Klasse abstrakt ist und dass kein Methodentext angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="56893-120">The latter indicates that the containing class is abstract and that no method body is supplied.</span></span>

### <a name="functional-programming"></a><span data-ttu-id="56893-121">Funktionale Programmierung</span><span class="sxs-lookup"><span data-stu-id="56893-121">Functional Programming</span></span>

<span data-ttu-id="56893-122">Die *funktionale Programmierung* (FP) ist ein Programmieransatz, der die reine funktionale Transformation direkt unterstützt.</span><span class="sxs-lookup"><span data-stu-id="56893-122">*Functional programming* is a programming approach that directly supports pure functional transformation.</span></span>

<span data-ttu-id="56893-123">In der Vergangenheit standen Allzwecksprachen zur funktionalen Programmierung, wie ML, Scheme, Haskell und F#, im Mittelpunkt des wissenschaftlichen Interesses.</span><span class="sxs-lookup"><span data-stu-id="56893-123">Historically, general-purpose functional programming languages, such as ML, Scheme, Haskell, and F#, have been primarily of interest to the academic community.</span></span> <span data-ttu-id="56893-124">Es war zwar immer möglich, in C# reine funktionale Transformationen zu schreiben, die damit verbundenen Schwierigkeiten ließen aber die meisten Programmierer davor zurückschrecken.</span><span class="sxs-lookup"><span data-stu-id="56893-124">Although it has always been possible to write pure functional transformations in C#, the difficulty of doing so has not made it an attractive option to most programmers.</span></span> <span data-ttu-id="56893-125">In neueren Versionen von C# stehen jedoch neue Sprachkonstrukte, z.B. Lambdaausdrücke und Typableitung, zur Verfügung, mit denen die funktionale Programmierung wesentlich einfacher und produktiver wurde.</span><span class="sxs-lookup"><span data-stu-id="56893-125">In recent versions of C#, however, new language constructs such as lambda expressions and type inference make it functional programming much easier and more productive.</span></span>

<span data-ttu-id="56893-126">Weitere Informationen zum funktionalen Programmieren finden Sie unter [Funktionale Programmierung und Imperative Programmierung (C#)](./functional-programming-vs-imperative-programming.md)</span><span class="sxs-lookup"><span data-stu-id="56893-126">For more information about functional programming, see [Functional Programming vs. Imperative Programming (C#)](./functional-programming-vs-imperative-programming.md).</span></span>

#### <a name="domain-specific-fp-languages"></a><span data-ttu-id="56893-127">Domänenspezifische FP-Sprachen</span><span class="sxs-lookup"><span data-stu-id="56893-127">Domain-Specific FP Languages</span></span>

<span data-ttu-id="56893-128">Während allgemeine FP-Sprachen keine große Verbreitung gefunden haben, konnten sich bestimmte domänenspezifische FP-Sprachen durchsetzen.</span><span class="sxs-lookup"><span data-stu-id="56893-128">Although general functional programming languages have not been widely adopted, specific domain-specific functional programming languages have had better success.</span></span> <span data-ttu-id="56893-129">So wird z. B. das Aussehen vieler Internetseiten durch Cascading Style Sheets (CSS) gesteuert, während für die Bearbeitung von XML-Daten häufig XSLT-Stylesheets (Extensible Stylesheet Language Transformations) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="56893-129">For example, Cascading Style Sheets (CSS) are used to determine the look and feel of many Web pages, and Extensible Stylesheet Language Transformations (XSLT) style sheets are used extensively in XML data manipulation.</span></span> <span data-ttu-id="56893-130">Weitere Informationen zu XSLT finden Sie unter [XSLT-Transformationen](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="56893-130">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>

## <a name="terminology"></a><span data-ttu-id="56893-131">Terminologie</span><span class="sxs-lookup"><span data-stu-id="56893-131">Terminology</span></span>

<span data-ttu-id="56893-132">Im Folgenden finden Sie Definitionen für eine Reihe von Begriffen, die im Zusammenhang mit der funktionalen Transformation verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="56893-132">The following table defines some terms related to functional transformations.</span></span>

<span data-ttu-id="56893-133">Funktion höherer Ordnung (Funktion erster Ordnung) </span><span class="sxs-lookup"><span data-stu-id="56893-133">higher-order (first-class) function </span></span>\
<span data-ttu-id="56893-134">Funktion, die als programmgesteuertes Objekt behandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="56893-134">A function that can be treated as a programmatic object.</span></span> <span data-ttu-id="56893-135">So kann eine Funktion höherer Ordnung z. B. an andere Funktionen übergeben oder von anderen Funktionen zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="56893-135">For example, a higher-order function can be passed to or returned from other functions.</span></span> <span data-ttu-id="56893-136">Zu den Sprachfunktionen in C#, die Funktionen höherer Ordnung unterstützen, gehören Delegate und Lambdaausdrücke.</span><span class="sxs-lookup"><span data-stu-id="56893-136">In C#c, delegates and lambda expressions are language features that support higher-order functions.</span></span> <span data-ttu-id="56893-137">Beim Schreiben einer Funktion höherer Ordnung deklarieren Sie für mindestens ein Argument, das diese Delegate akzeptiert, und beim Aufrufen einer solchen Funktion verwenden Sie häufig Lambdaausdrücke.</span><span class="sxs-lookup"><span data-stu-id="56893-137">To write a higher-order function, you declare one or more arguments to take delegates, and you often use lambda expressions when calling it.</span></span> <span data-ttu-id="56893-138">Viele der Standardabfrageoperatoren sind Funktionen höherer Ordnung.</span><span class="sxs-lookup"><span data-stu-id="56893-138">Many of the standard query operators are higher-order functions.</span></span>

<span data-ttu-id="56893-139">Weitere Informationen finden Sie unter [Übersicht über Standardabfrageoperatoren (C#)](./standard-query-operators-overview.md).</span><span class="sxs-lookup"><span data-stu-id="56893-139">For more information, see [Standard Query Operators Overview (C#)](./standard-query-operators-overview.md).</span></span>

<span data-ttu-id="56893-140">Lambdaausdruck </span><span class="sxs-lookup"><span data-stu-id="56893-140">lambda expression </span></span>\
<span data-ttu-id="56893-141">Im Wesentlichen eine anonyme Inlinefunktion, die überall dort verwendet werden kann, wo ein Delegattyp erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="56893-141">Essentially, an inline anonymous function that can be used wherever a delegate type is expected.</span></span> <span data-ttu-id="56893-142">Dies ist zwar eine vereinfachte Definition für Lambdaausdrücke, im Rahmen dieses Lernprogramms reicht sie aber aus.</span><span class="sxs-lookup"><span data-stu-id="56893-142">This is a simplified definition of lambda expressions, but it is adequate for the purposes of this tutorial.</span></span>

<span data-ttu-id="56893-143">Weitere Informationen dazu finden Sie unter [Lambdaausdrücke](../../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="56893-143">For more information about, see [Lambda Expressions](../../statements-expressions-operators/lambda-expressions.md).</span></span>

<span data-ttu-id="56893-144">Sammlung </span><span class="sxs-lookup"><span data-stu-id="56893-144">collection </span></span>\
<span data-ttu-id="56893-145">Strukturierter Satz von Daten, die in der Regel alle denselben Typ haben.</span><span class="sxs-lookup"><span data-stu-id="56893-145">A structured set of data, usually of a uniform type.</span></span> <span data-ttu-id="56893-146">Zur Gewährleistung der Kompatibilität mit LINQ muss eine Auflistung die <xref:System.Collections.IEnumerable>-Schnittstelle oder die <xref:System.Linq.IQueryable>-Schnittstelle (oder eines ihrer generischen Gegenstücke, <xref:System.Collections.Generic.IEnumerator%601> bzw. <xref:System.Linq.IQueryable%601>) implementieren.</span><span class="sxs-lookup"><span data-stu-id="56893-146">To be compatible with LINQ, a collection must implement the <xref:System.Collections.IEnumerable> interface or the <xref:System.Linq.IQueryable> interface (or one of their generic counterparts, <xref:System.Collections.Generic.IEnumerator%601> or <xref:System.Linq.IQueryable%601>).</span></span>

<span data-ttu-id="56893-147">Tupel (anonyme Typen) </span><span class="sxs-lookup"><span data-stu-id="56893-147">tuple (anonymous types) </span></span>\
<span data-ttu-id="56893-148">Begriff aus der Mathematik, der eine endliche Abfolge von Objekten bezeichnet, die jeweils einen bestimmten Typ haben.</span><span class="sxs-lookup"><span data-stu-id="56893-148">A mathematical concept, a tuple is a finite sequence of objects, each of a specific type.</span></span> <span data-ttu-id="56893-149">Ein Tupel wird auch als geordnete Zusammenstellung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="56893-149">A tuple is also known as an ordered list.</span></span> <span data-ttu-id="56893-150">Dieses Konzept ist in Programmiersprachen als anonymer Typ implementiert, der es ermöglicht, einen nicht benannten Klassentyp zu deklarieren und gleichzeitig ein Objekt desselben Typs zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="56893-150">Anonymous types are a language implementation of this concept, which enable an unnamed class type to be declared and an object of that type to be instantiated at the same time.</span></span>

<span data-ttu-id="56893-151">Weitere Informationen finden Sie unter [Anonyme Typen](../../classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="56893-151">For more information, see [Anonymous Types](../../classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="56893-152">Typrückschluss (implizite Typisierung) </span><span class="sxs-lookup"><span data-stu-id="56893-152">type inference (implicit typing) </span></span>\
<span data-ttu-id="56893-153">Fähigkeit eines Compilers, den Typ einer Variablen in Abwesenheit einer expliziten Typdeklaration zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="56893-153">The ability of a compiler to determine the type of a variable in the absence of an explicit type declaration.</span></span>

<span data-ttu-id="56893-154">Weitere Informationen zu finden Sie unter [Implizit typisierte lokale Variablen](../../classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="56893-154">For more information, see [Implicitly Typed Local Variables](../../classes-and-structs/implicitly-typed-local-variables.md).</span></span>

<span data-ttu-id="56893-155">Verzögerte Ausführung und verzögerte Auswertung </span><span class="sxs-lookup"><span data-stu-id="56893-155">deferred execution and lazy evaluation </span></span>\
<span data-ttu-id="56893-156">Bei der verzögerten Auswertung (Lazy Evaluation) eines Ausdrucks wird mit der Auswertung so lange gewartet, bis der aufgelöste Wert tatsächlich benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="56893-156">The delaying of evaluation of an expression until its resolved value is actually required.</span></span> <span data-ttu-id="56893-157">Die verzögerte Ausführung (Deferred Execution) wird in Auflistungen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="56893-157">Deferred execution is supported in collections.</span></span>

<span data-ttu-id="56893-158">Weitere Informationen finden Sie unter [Einführung in LINQ-Abfragen (C#)](./introduction-to-linq-queries.md) und [Deferred Execution and Lazy Evaluation in LINQ to XML (C#) (Verzögerte Ausführung und Auswertung in LINQ to XML (C#))](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).</span><span class="sxs-lookup"><span data-stu-id="56893-158">For more information, see [Introduction to LINQ Queries (C#)](./introduction-to-linq-queries.md) and [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).</span></span>

<span data-ttu-id="56893-159">Diese Sprachfunktionen werden in Codebeispielen im gesamten Abschnitt verwendet.</span><span class="sxs-lookup"><span data-stu-id="56893-159">These language features will be used in code samples throughout this section.</span></span>

## <a name="see-also"></a><span data-ttu-id="56893-160">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="56893-160">See also</span></span>

- [<span data-ttu-id="56893-161">Introduction to Pure Functional Transformations (C#) (Einführung in reine funktionale Transformationen (c#))</span><span class="sxs-lookup"><span data-stu-id="56893-161">Introduction to Pure Functional Transformations (C#)</span></span>](./introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="56893-162">Funktionale Programmierung und Imperative Programmierung (C#)</span><span class="sxs-lookup"><span data-stu-id="56893-162">Functional Programming vs. Imperative Programming (C#)</span></span>](./functional-programming-vs-imperative-programming.md)
