---
title: Funktionale Programmierung und Imperative Programmierung (C#)
description: In diesem Artikel wird die funktionale Programmierung in C# mit dem prozeduralen Ansatz verglichen. Die funktionale Programmierung erzwingt die Unveränderlichkeit durch reine Funktionen.
ms.date: 07/20/2015
ms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57
ms.openlocfilehash: bc421d654e532293b522dab9d43920d0fffd7b92
ms.sourcegitcommit: 04022ca5d00b2074e1b1ffdbd76bec4950697c4c
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 07/23/2020
ms.locfileid: "87103751"
---
# <a name="functional-programming-vs-imperative-programming-c"></a><span data-ttu-id="7246d-104">Funktionale Programmierung und Imperative Programmierung (C#)</span><span class="sxs-lookup"><span data-stu-id="7246d-104">Functional Programming vs. Imperative Programming (C#)</span></span>
<span data-ttu-id="7246d-105">In diesem Thema werden die Gemeinsamkeiten und die Unterschiede der funktionalen Programmierung und der herkömmlichen imperativen (prozeduralen) Programmierung erläutert.</span><span class="sxs-lookup"><span data-stu-id="7246d-105">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="7246d-106">Funktionale Programmierung und Imperative Programmierung</span><span class="sxs-lookup"><span data-stu-id="7246d-106">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="7246d-107">Explizite Aufgabe der *funktionalen Programmierung* ist die Unterstützung eines reinen funktionalen Ansatzes bei der Problemlösung.</span><span class="sxs-lookup"><span data-stu-id="7246d-107">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="7246d-108">Die funktionale Programmierung ist eine Form der *deklarativen Programmierung*.</span><span class="sxs-lookup"><span data-stu-id="7246d-108">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="7246d-109">Im Unterschied dazu unterstützen die meisten normalen Programmiersprachen, darunter auch OOP-Sprachen wie C#, Visual Basic, C++ und Java, in erster Linie die *imperative* (prozedurale) Programmierung.</span><span class="sxs-lookup"><span data-stu-id="7246d-109">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="7246d-110">Beim imperativen Ansatz schreibt ein Entwickler Code, der detailliert die Schritte beschreibt, die der Computer zur Erfüllung der Aufgabe ausführen muss.</span><span class="sxs-lookup"><span data-stu-id="7246d-110">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="7246d-111">Diese Form der Programmierung wird mitunter auch als *algorithmische* Programmierung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="7246d-111">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="7246d-112">Beim funktionalen Ansatz hingegen wird das Problem als Satz von auszuführenden Funktionen formuliert.</span><span class="sxs-lookup"><span data-stu-id="7246d-112">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="7246d-113">Sie definieren sorgfältig, was für jede Funktion eingegeben wird und was die jeweilige Funktion zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="7246d-113">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="7246d-114">In der folgenden Tabelle werden einige der allgemeinen Unterschiede zwischen diesen beiden Ansätzen beschrieben:</span><span class="sxs-lookup"><span data-stu-id="7246d-114">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="7246d-115">Merkmal</span><span class="sxs-lookup"><span data-stu-id="7246d-115">Characteristic</span></span>|<span data-ttu-id="7246d-116">Imperativer Ansatz</span><span class="sxs-lookup"><span data-stu-id="7246d-116">Imperative approach</span></span>|<span data-ttu-id="7246d-117">Funktionaler Ansatz</span><span class="sxs-lookup"><span data-stu-id="7246d-117">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="7246d-118">Schwerpunkt bei der Programmierung</span><span class="sxs-lookup"><span data-stu-id="7246d-118">Programmer focus</span></span>|<span data-ttu-id="7246d-119">Art und Weise der Ausführung von Aufgaben (Algorithmen) und der Überwachung von Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="7246d-119">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="7246d-120">Art der gewünschten Informationen und der erforderlichen Transformationen</span><span class="sxs-lookup"><span data-stu-id="7246d-120">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="7246d-121">Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="7246d-121">State changes</span></span>|<span data-ttu-id="7246d-122">wichtig</span><span class="sxs-lookup"><span data-stu-id="7246d-122">Important.</span></span>|<span data-ttu-id="7246d-123">nicht existent</span><span class="sxs-lookup"><span data-stu-id="7246d-123">Non-existent.</span></span>|  
|<span data-ttu-id="7246d-124">Reihenfolge der Ausführung</span><span class="sxs-lookup"><span data-stu-id="7246d-124">Order of execution</span></span>|<span data-ttu-id="7246d-125">wichtig</span><span class="sxs-lookup"><span data-stu-id="7246d-125">Important.</span></span>|<span data-ttu-id="7246d-126">weniger wichtig</span><span class="sxs-lookup"><span data-stu-id="7246d-126">Low importance.</span></span>|  
|<span data-ttu-id="7246d-127">Primäre Datenflusskontrolle</span><span class="sxs-lookup"><span data-stu-id="7246d-127">Primary flow control</span></span>|<span data-ttu-id="7246d-128">Schleifen, Bedingungen und Funktions- (Methoden-)Aufrufe</span><span class="sxs-lookup"><span data-stu-id="7246d-128">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="7246d-129">Funktionsaufrufe, einschließlich Rekursion</span><span class="sxs-lookup"><span data-stu-id="7246d-129">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="7246d-130">Primäre Manipulationseinheit</span><span class="sxs-lookup"><span data-stu-id="7246d-130">Primary manipulation unit</span></span>|<span data-ttu-id="7246d-131">Instanzen von Strukturen oder Klassen</span><span class="sxs-lookup"><span data-stu-id="7246d-131">Instances of structures or classes.</span></span>|<span data-ttu-id="7246d-132">Funktionen als erstklassige Objekte und Datensammlungen</span><span class="sxs-lookup"><span data-stu-id="7246d-132">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="7246d-133">Die meisten Sprachen unterstützen zwar ein bestimmtes Programmierparadigma, viele allgemeine Sprachen sind aber ausreichend flexibel, um mehrere Paradigmen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="7246d-133">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="7246d-134">So können z. B. die meisten Sprachen, die Funktionszeiger enthalten, zur glaubwürdigen Unterstützung der funktionalen Programmierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="7246d-134">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="7246d-135">Darüber hinaus enthält C# auch explizite Spracherweiterungen, darunter Lambda-Ausdrücke und Typableitung, die die funktionale Programmierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="7246d-135">Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="7246d-136">Eine Form der deklarativen, funktionalen Programmierung ist die LINQ-Technologie.</span><span class="sxs-lookup"><span data-stu-id="7246d-136">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="7246d-137">Funktionale Programmierung mit XSLT</span><span class="sxs-lookup"><span data-stu-id="7246d-137">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="7246d-138">Viele XSLT-Entwickler sind mit dem reinen funktionalen Ansatz vertraut.</span><span class="sxs-lookup"><span data-stu-id="7246d-138">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="7246d-139">Der effektivste Weg bei der Entwicklung eines XSLT-Stylesheets besteht darin, jede Vorlage als isolierte, zusammensetzbare Transformation zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="7246d-139">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="7246d-140">Die Reihenfolge der Ausführung ist dabei ohne jede Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="7246d-140">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="7246d-141">XSLT lässt keine Nebenwirkungen zu (lediglich die Escapemechanismen für die Ausführung von prozeduralem Code können Nebenwirkungen mit sich bringen, die zu funktionaler Unreinheit führen).</span><span class="sxs-lookup"><span data-stu-id="7246d-141">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="7246d-142">XSLT ist zwar ein wirksames Tool, dennoch sind einige seiner Eigenschaften nicht optimal.</span><span class="sxs-lookup"><span data-stu-id="7246d-142">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="7246d-143">So führt z. B. das Ausdrücken von Programmierkonstrukten in XML dazu, dass Code relativ weitschweifig und damit schwierig zu unterhalten ist.</span><span class="sxs-lookup"><span data-stu-id="7246d-143">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="7246d-144">Auch die schwere Abhängigkeit von der Rekursion zur Flusssteuerung kann dazu führen, dass Code schwer lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="7246d-144">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="7246d-145">Weitere Informationen zu XSLT finden Sie unter [XSLT-Transformationen](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="7246d-145">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="7246d-146">Dennoch hat XSLT bewiesen, dass die Verwendung eines reinen funktionalen Ansatzes bei der Transformierung von XML von einer Form in eine andere sinnvoll ist.</span><span class="sxs-lookup"><span data-stu-id="7246d-146">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="7246d-147">Die reine funktionale Programmierung mit LINQ to XML ähnelt in vielerlei Hinsicht XSLT.</span><span class="sxs-lookup"><span data-stu-id="7246d-147">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="7246d-148">Mit den Programmierkonstrukten von LINQ to XML und C# können Sie reine funktionale Transformationen schreiben, die besser lesbar und verwaltbar sind als XSLT.</span><span class="sxs-lookup"><span data-stu-id="7246d-148">However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="7246d-149">Vorteile von reinen Funktionen</span><span class="sxs-lookup"><span data-stu-id="7246d-149">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="7246d-150">Der Hauptgrund für die Implementierung von funktionalen Transformationen als reinen Funktionen (Pure-Funktionen) besteht darin, dass reine Funktionen zusammenstellbar sind, d. h., sie sind in sich abgeschlossen und zustandslos.</span><span class="sxs-lookup"><span data-stu-id="7246d-150">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="7246d-151">Diese Eigenschaften bieten u. a. die folgenden Vorteile:</span><span class="sxs-lookup"><span data-stu-id="7246d-151">These characteristics bring a number of benefits, including the following:</span></span>  
  
- <span data-ttu-id="7246d-152">Bessere Lesbarkeit und Verwaltbarkeit:</span><span class="sxs-lookup"><span data-stu-id="7246d-152">Increased readability and maintainability.</span></span> <span data-ttu-id="7246d-153">Jede Funktion ist für die Erledigung einer bestimmten Aufgabe anhand ihrer Argumente vorgesehen,</span><span class="sxs-lookup"><span data-stu-id="7246d-153">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="7246d-154">ohne sich dabei auf einen externen Zustand zu verlassen.</span><span class="sxs-lookup"><span data-stu-id="7246d-154">The function does not rely on any external state.</span></span>  
  
- <span data-ttu-id="7246d-155">Einfachere reiterative Entwicklung:</span><span class="sxs-lookup"><span data-stu-id="7246d-155">Easier reiterative development.</span></span> <span data-ttu-id="7246d-156">Da der Code einfacher umgestaltet werden kann, können Änderungen am Entwurf oft leichter implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="7246d-156">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="7246d-157">Nehmen wir z. B. an, Sie schreiben eine komplizierte Transformation und stellen dann fest, dass sich ein Teil des Codes in der Transformation mehrmals wiederholt.</span><span class="sxs-lookup"><span data-stu-id="7246d-157">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="7246d-158">Bei der Umgestaltung mit einer reinen Methode können Sie Ihre reine Methode ganz nach Belieben aufrufen, ohne auf irgendwelche Nebenwirkungen Rücksicht nehmen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="7246d-158">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
- <span data-ttu-id="7246d-159">Einfacheres Testen und Debuggen:</span><span class="sxs-lookup"><span data-stu-id="7246d-159">Easier testing and debugging.</span></span> <span data-ttu-id="7246d-160">Da reine Funktionen einfacher in Isolation getestet werden können, können Sie Testcode schreiben, der die reine Funktion mit typischen Werten, gültigen Randfällen und ungültigen Randfällen aufruft.</span><span class="sxs-lookup"><span data-stu-id="7246d-160">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="7246d-161">Was müssen OOP-Entwickler beachten?</span><span class="sxs-lookup"><span data-stu-id="7246d-161">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="7246d-162">Bei der traditionellen objektorientierten Programmierung (OOP) verwenden die meisten Entwickler beim Programmieren den imperativen/prozeduralen Stil.</span><span class="sxs-lookup"><span data-stu-id="7246d-162">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="7246d-163">Für den Umstieg auf die Entwicklung in einem reinen funktionalen Stil müssen die Entwickler umdenken und ihre Herangehensweise an die Entwicklung ändern.</span><span class="sxs-lookup"><span data-stu-id="7246d-163">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="7246d-164">Zur Lösung von Problemen entwerfen OOP-Entwickler Klassenhierarchien, konzentrieren sich auf die richtige Kapselung und denken in Klassenvertragskategorien.</span><span class="sxs-lookup"><span data-stu-id="7246d-164">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="7246d-165">Im Vordergrund stehen das Verhalten und der Status von Objekttypen, und zu diesem Zweck werden Sprachfunktionen wie Klassen, Schnittstellen, Vererbung und Polymorphie bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="7246d-165">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="7246d-166">Dagegen werden die Berechnungsprobleme bei der funktionalen Programmierung als Übung für die Auswertung reiner funktionaler Transformationen von Datensammlungen angesehen.</span><span class="sxs-lookup"><span data-stu-id="7246d-166">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="7246d-167">Bei der funktionalen Programmierung werden Zustands- und änderbare Daten vermieden, stattdessen steht die Anwendung von Funktionen im Mittelpunkt.</span><span class="sxs-lookup"><span data-stu-id="7246d-167">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="7246d-168">Glücklicherweise erfordert C# keinen kompletten Umstieg auf die funktionale Programmierung, da sowohl der imperative als auch der funktionale Programmierungsansatz unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="7246d-168">Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="7246d-169">Der Entwickler kann daher selbst entscheiden, welcher Ansatz für ein bestimmtes Szenario am geeignetsten ist.</span><span class="sxs-lookup"><span data-stu-id="7246d-169">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="7246d-170">Bei vielen Programme werden beide Ansätze häufig miteinander kombiniert.</span><span class="sxs-lookup"><span data-stu-id="7246d-170">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7246d-171">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="7246d-171">See also</span></span>

- [<span data-ttu-id="7246d-172">Introduction to Pure Functional Transformations (C#) (Einführung in reine funktionale Transformationen (c#))</span><span class="sxs-lookup"><span data-stu-id="7246d-172">Introduction to Pure Functional Transformations (C#)</span></span>](./introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="7246d-173">XSLT Transformations (XSLT-Transformationen)</span><span class="sxs-lookup"><span data-stu-id="7246d-173">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)
- [<span data-ttu-id="7246d-174">Refactoring in reine Funktionen (C#)</span><span class="sxs-lookup"><span data-stu-id="7246d-174">Refactoring Into Pure Functions (C#)</span></span>](./refactoring-into-pure-functions.md)
