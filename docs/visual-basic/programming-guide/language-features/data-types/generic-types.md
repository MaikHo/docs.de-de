---
title: Generische Typen
ms.date: 07/20/2015
helpviewer_keywords:
- generic interfaces
- data type arguments [Visual Basic], defining
- generic delegates
- arguments [Visual Basic], data types
- Of keyword [Visual Basic], using
- delegates, generic
- constraints, Visual Basic generic types
- generic parameters
- data type parameters
- procedures [Visual Basic], generic
- generic procedures
- data types [Visual Basic], generic
- data types [Visual Basic], as parameters
- generics [Visual Basic], generic types
- data types [Visual Basic], as arguments
- generic classes [Visual Basic], Visual Basic
- parameters [Visual Basic], type
- type arguments
- interfaces [Visual Basic], generic
- generics [Visual Basic]
- types [Visual Basic], generic
- parameters [Visual Basic], generic
- generic structures [Visual Basic]
- generic classes [Visual Basic]
- type parameters
- data type arguments
- structures [Visual Basic], generic
- parameters [Visual Basic], data type
- collections, generic
- classes [Visual Basic], generic
- data type parameters [Visual Basic], defining
- type arguments [Visual Basic], defining
- arguments [Visual Basic], type
ms.assetid: 89f771d9-ecbb-4737-88b8-116b63c6cf4d
ms.openlocfilehash: f9b343c664baaf316e5cd6df72da8dcf56222382
ms.sourcegitcommit: bf5c5850654187705bc94cc40ebfb62fe346ab02
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/23/2020
ms.locfileid: "91090260"
---
# <a name="generic-types-in-visual-basic-visual-basic"></a><span data-ttu-id="bab40-102">Generische Typen in Visual Basic (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="bab40-102">Generic Types in Visual Basic (Visual Basic)</span></span>

<span data-ttu-id="bab40-103">Ein *generischer Typ* ist ein einzelnes Programmierelement, das sich so anpasst, dass es für verschiedene Datentypen dieselben Funktionalität ausführt.</span><span class="sxs-lookup"><span data-stu-id="bab40-103">A *generic type* is a single programming element that adapts to perform the same functionality for a variety of data types.</span></span> <span data-ttu-id="bab40-104">Wenn Sie eine generische Klasse oder Prozedur definieren, müssen Sie keine separate Version für jeden Datentyp definieren, für den Sie diese Funktionalität möglicherweise ausführen möchten.</span><span class="sxs-lookup"><span data-stu-id="bab40-104">When you define a generic class or procedure, you do not have to define a separate version for each data type for which you might want to perform that functionality.</span></span>  
  
 <span data-ttu-id="bab40-105">Eine Analogie hierzu ist ein Schraubendrehersatz mit auswechselbaren Spitzen.</span><span class="sxs-lookup"><span data-stu-id="bab40-105">An analogy is a screwdriver set with removable heads.</span></span> <span data-ttu-id="bab40-106">Sie sehen sich die Schraube an, die Sie drehen müssen, und wählen die geeignete Spitze für diese Schraube aus (geschlitzt, gekreuzt oder mit Stern).</span><span class="sxs-lookup"><span data-stu-id="bab40-106">You inspect the screw you need to turn and select the correct head for that screw (slotted, crossed, starred).</span></span> <span data-ttu-id="bab40-107">Sobald Sie die richtige Spitze in den Schraubendreher gesteckt haben, führen Sie mit dem Schraubendreher genau diese Funktion aus, d. h., Sie drehen die Schraube.</span><span class="sxs-lookup"><span data-stu-id="bab40-107">Once you insert the correct head in the screwdriver handle, you perform the exact same function with the screwdriver, namely turning the screw.</span></span>  
  
 ![Diagramm eines Schraubendreher Satzes mit unterschiedlichen Köpfen.](./media/generic-types/generic-screwdriver-set.gif)  
  
 <span data-ttu-id="bab40-109">Wenn Sie einen generischen Typ definieren, parametrisieren Sie ihn mit mindestens einem Datentyp.</span><span class="sxs-lookup"><span data-stu-id="bab40-109">When you define a generic type, you parameterize it with one or more data types.</span></span> <span data-ttu-id="bab40-110">Dies ermöglicht es, die Datentypen mithilfe von Code an die Anforderungen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="bab40-110">This allows the using code to tailor the data types to its requirements.</span></span> <span data-ttu-id="bab40-111">Im Code können Sie mehrere unterschiedliche Programmierelemente anhand des generischen Elements deklarieren, von denen jedes für eine andere Gruppe von Datentypen ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="bab40-111">Your code can declare several different programming elements from the generic element, each one acting on a different set of data types.</span></span> <span data-ttu-id="bab40-112">Die deklarierten Elemente führen jedoch alle dieselbe Logik aus, unabhängig davon, welche Datentypen von ihnen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="bab40-112">But the declared elements all perform the identical logic, no matter what data types they are using.</span></span>  
  
 <span data-ttu-id="bab40-113">Nehmen Sie beispielsweise an, Sie möchten eine Warteschlangeklasse erstellen und verwenden, die für einen bestimmten Datentyp, z. B. `String`, ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="bab40-113">For example, you might want to create and use a queue class that operates on a specific data type such as `String`.</span></span> <span data-ttu-id="bab40-114">Sie können eine solche Klasse über <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType>deklarieren, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="bab40-114">You can declare such a class from <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType>, as the following example shows.</span></span>  
  
 [!code-vb[VbVbalrDataTypes#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#1)]  
  
 <span data-ttu-id="bab40-115">Nun können Sie `stringQ` verwenden, um ausschließlich mit `String` -Werten zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="bab40-115">You can now use `stringQ` to work exclusively with `String` values.</span></span> <span data-ttu-id="bab40-116">Da `stringQ` speziell für `String` -Werte und nicht allgemein für `Object` -Werte verwendet wird, gibt es weder späte Bindung noch Typkonvertierung.</span><span class="sxs-lookup"><span data-stu-id="bab40-116">Because `stringQ` is specific for `String` instead of being generalized for `Object` values, you do not have late binding or type conversion.</span></span> <span data-ttu-id="bab40-117">Dies erspart Ausführungszeit und verringert Laufzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="bab40-117">This saves execution time and reduces run-time errors.</span></span>  
  
 <span data-ttu-id="bab40-118">Weitere Informationen zur Verwendung eines generischen Typs finden Sie unter [How to: Use a Generic Class](how-to-use-a-generic-class.md).</span><span class="sxs-lookup"><span data-stu-id="bab40-118">For more information on using a generic type, see [How to: Use a Generic Class](how-to-use-a-generic-class.md).</span></span>  
  
## <a name="example-of-a-generic-class"></a><span data-ttu-id="bab40-119">Beispiel für eine generische Klasse</span><span class="sxs-lookup"><span data-stu-id="bab40-119">Example of a Generic Class</span></span>  

 <span data-ttu-id="bab40-120">Im folgenden Beispiel wird eine Rumpfdefinition einer generischen Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="bab40-120">The following example shows a skeleton definition of a generic class.</span></span>  
  
 [!code-vb[VbVbalrDataTypes#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#2)]  
  
 <span data-ttu-id="bab40-121">Im dieser Rumpfdefinition ist `t` ein *Typparameter*, d. h. ein Platzhalter für einen Datentyp, den Sie beim Deklarieren der Klasse angeben.</span><span class="sxs-lookup"><span data-stu-id="bab40-121">In the preceding skeleton, `t` is a *type parameter*, that is, a placeholder for a data type that you supply when you declare the class.</span></span> <span data-ttu-id="bab40-122">An anderer Stelle im Code können Sie verschiedene Versionen von `classHolder` deklarieren, indem Sie für `t`verschiedene Datentypen angeben.</span><span class="sxs-lookup"><span data-stu-id="bab40-122">Elsewhere in your code, you can declare various versions of `classHolder` by supplying various data types for `t`.</span></span> <span data-ttu-id="bab40-123">Im folgenden Beispiel werden zwei solcher Deklarationen gezeigt.</span><span class="sxs-lookup"><span data-stu-id="bab40-123">The following example shows two such declarations.</span></span>  
  
 [!code-vb[VbVbalrDataTypes#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#3)]  
  
 <span data-ttu-id="bab40-124">Die vorangehenden Anweisungen deklarieren *konstruierte Klassen*, in denen ein bestimmter Typ den Typparameter ersetzt.</span><span class="sxs-lookup"><span data-stu-id="bab40-124">The preceding statements declare *constructed classes*, in which a specific type replaces the type parameter.</span></span> <span data-ttu-id="bab40-125">Diese Ersetzung wird im gesamten Code in der konstruierten Klasse weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="bab40-125">This replacement is propagated throughout the code within the constructed class.</span></span> <span data-ttu-id="bab40-126">Im folgenden Beispiel wird gezeigt, wie die `processNewItem` -Prozedur in `integerClass`aussieht.</span><span class="sxs-lookup"><span data-stu-id="bab40-126">The following example shows what the `processNewItem` procedure looks like in `integerClass`.</span></span>  
  
 [!code-vb[VbVbalrDataTypes#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#4)]  
  
 <span data-ttu-id="bab40-127">Ein ausführlichere Beispiel finden Sie unter Gewusst [wie: Definieren einer Klasse, die für unterschiedliche Datentypen die gleiche Funktionalität bereitstellen kann](how-to-define-a-class-that-can-provide-identical-functionality.md).</span><span class="sxs-lookup"><span data-stu-id="bab40-127">For a more complete example, see [How to: Define a Class That Can Provide Identical Functionality on Different Data Types](how-to-define-a-class-that-can-provide-identical-functionality.md).</span></span>  
  
## <a name="eligible-programming-elements"></a><span data-ttu-id="bab40-128">Geeignete Programmierelemente</span><span class="sxs-lookup"><span data-stu-id="bab40-128">Eligible Programming Elements</span></span>  

 <span data-ttu-id="bab40-129">Sie können generische Klassen, Strukturen, Schnittstellen, Prozeduren und Delegaten definieren und verwenden.</span><span class="sxs-lookup"><span data-stu-id="bab40-129">You can define and use generic classes, structures, interfaces, procedures, and delegates.</span></span> <span data-ttu-id="bab40-130">Beachten Sie, dass der .NET Framework mehrere generische Klassen, Strukturen und Schnittstellen definiert, die häufig verwendete generische Elemente darstellen.</span><span class="sxs-lookup"><span data-stu-id="bab40-130">Note that the .NET Framework defines several generic classes, structures, and interfaces that represent commonly used generic elements.</span></span> <span data-ttu-id="bab40-131">Der <xref:System.Collections.Generic?displayProperty=nameWithType> -Namespace stellt Wörterbücher, Listen, Warteschlangen und Stapel bereit.</span><span class="sxs-lookup"><span data-stu-id="bab40-131">The <xref:System.Collections.Generic?displayProperty=nameWithType> namespace provides dictionaries, lists, queues, and stacks.</span></span> <span data-ttu-id="bab40-132">Bevor Sie ein eigenes generisches Element definieren, überprüfen Sie, ob es bereits in <xref:System.Collections.Generic?displayProperty=nameWithType>verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="bab40-132">Before defining your own generic element, see if it is already available in <xref:System.Collections.Generic?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bab40-133">Prozeduren sind keine Typen, Sie können aber generische Prozeduren definieren und verwenden.</span><span class="sxs-lookup"><span data-stu-id="bab40-133">Procedures are not types, but you can define and use generic procedures.</span></span> <span data-ttu-id="bab40-134">Siehe [Generic Procedures in Visual Basic](generic-procedures.md).</span><span class="sxs-lookup"><span data-stu-id="bab40-134">See [Generic Procedures in Visual Basic](generic-procedures.md).</span></span>  
  
## <a name="advantages-of-generic-types"></a><span data-ttu-id="bab40-135">Vorteile von generischen Typen</span><span class="sxs-lookup"><span data-stu-id="bab40-135">Advantages of Generic Types</span></span>  

 <span data-ttu-id="bab40-136">Ein generischer Typ fungiert als Basis für das Deklarieren mehrerer unterschiedlicher Programmierelemente, von denen jedes für einen bestimmten Datentyp ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="bab40-136">A generic type serves as a basis for declaring several different programming elements, each of which operates on a specific data type.</span></span> <span data-ttu-id="bab40-137">Die Alternativen zu einem generischen Typ sind:</span><span class="sxs-lookup"><span data-stu-id="bab40-137">The alternatives to a generic type are:</span></span>  
  
1. <span data-ttu-id="bab40-138">Ein einzelner Typ, der auf den `Object` -Datentyp angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="bab40-138">A single type operating on the `Object` data type.</span></span>  
  
2. <span data-ttu-id="bab40-139">Ein Satz von *typspezifischen* Versionen des Typs, wobei jede Version einzeln codiert ist und auf einem bestimmten Datentyp, z `String` `Integer` . b., oder einem benutzerdefinierten Typ, wie z. b., ausgeführt wird `customer` .</span><span class="sxs-lookup"><span data-stu-id="bab40-139">A set of *type-specific* versions of the type, each version individually coded and operating on one specific data type such as `String`, `Integer`, or a user-defined type such as `customer`.</span></span>  
  
 <span data-ttu-id="bab40-140">Ein generischer Typ bietet folgende Vorteile gegenüber diesen Alternativen:</span><span class="sxs-lookup"><span data-stu-id="bab40-140">A generic type has the following advantages over these alternatives:</span></span>  
  
- <span data-ttu-id="bab40-141">**Typsicherheit.**</span><span class="sxs-lookup"><span data-stu-id="bab40-141">**Type Safety.**</span></span> <span data-ttu-id="bab40-142">. Generische Typen erzwingen die Typüberprüfung zur Kompilierzeit.</span><span class="sxs-lookup"><span data-stu-id="bab40-142">Generic types enforce compile-time type checking.</span></span> <span data-ttu-id="bab40-143">Auf `Object` basierende Typen akzeptieren jeden Datentyp, und Sie müssen Code schreiben, der überprüft, ob ein Eingabedatentyp zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="bab40-143">Types based on `Object` accept any data type, and you must write code to check whether an input data type is acceptable.</span></span> <span data-ttu-id="bab40-144">Mit generischen Typen kann der Compiler Typenkonflikte vor der Laufzeit abfangen.</span><span class="sxs-lookup"><span data-stu-id="bab40-144">With generic types, the compiler can catch type mismatches before run time.</span></span>  
  
- <span data-ttu-id="bab40-145">**Leistung**</span><span class="sxs-lookup"><span data-stu-id="bab40-145">**Performance.**</span></span> <span data-ttu-id="bab40-146">Generische Typen müssen kein *Boxing* und *unBoxing* für Daten ausführen, da jeder Typ speziell für einen Datentyp verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="bab40-146">Generic types do not have to *box* and *unbox* data, because each one is specialized for one data type.</span></span> <span data-ttu-id="bab40-147">Operationen, die auf `Object` basierend, müssen für Eingabedatentypen Boxing ausführen, um sie in `Object` zu konvertieren, und Unboxing für Daten ausführen, die für die Ausgabe vorgesehen sind.</span><span class="sxs-lookup"><span data-stu-id="bab40-147">Operations based on `Object` must box input data types to convert them to `Object` and unbox data destined for output.</span></span> <span data-ttu-id="bab40-148">Durch Boxing und Unboxing wird die Leistung verringert.</span><span class="sxs-lookup"><span data-stu-id="bab40-148">Boxing and unboxing reduce performance.</span></span>  
  
     <span data-ttu-id="bab40-149">Typen, die auf `Object` basieren, sind außerdem spät gebunden, d. h., dass der Zugriff auf ihre Member zusätzlichen Code zur Laufzeit erfordert.</span><span class="sxs-lookup"><span data-stu-id="bab40-149">Types based on `Object` are also late-bound, which means that accessing their members requires extra code at run time.</span></span> <span data-ttu-id="bab40-150">Hierdurch wird die Leistung ebenfalls verringert.</span><span class="sxs-lookup"><span data-stu-id="bab40-150">This also reduces performance.</span></span>  
  
- <span data-ttu-id="bab40-151">**Codekonsolidierung.**</span><span class="sxs-lookup"><span data-stu-id="bab40-151">**Code Consolidation.**</span></span> <span data-ttu-id="bab40-152">Der Code in einem generischen Typ muss nur einmal definiert werden.</span><span class="sxs-lookup"><span data-stu-id="bab40-152">The code in a generic type has to be defined only once.</span></span> <span data-ttu-id="bab40-153">Ein Satz typspezifischer Versionen eines Typs muss in jeder Version denselben Code replizieren, wobei der einzige Unterschied im speziellen Datentyp für die jeweilige Version besteht.</span><span class="sxs-lookup"><span data-stu-id="bab40-153">A set of type-specific versions of a type must replicate the same code in each version, with the only difference being the specific data type for that version.</span></span> <span data-ttu-id="bab40-154">Bei generischen Typen werden alle typspezifischen Versionen aus dem ursprünglichen generischen Typ generiert.</span><span class="sxs-lookup"><span data-stu-id="bab40-154">With generic types, the type-specific versions are all generated from the original generic type.</span></span>  
  
- <span data-ttu-id="bab40-155">**Wiederverwendung von Code**</span><span class="sxs-lookup"><span data-stu-id="bab40-155">**Code Reuse.**</span></span> <span data-ttu-id="bab40-156">. Code, der nicht von einem bestimmten Datentyp abhängt, kann für verschiedene Datentypen wiederverwendet werden, wenn er generisch ist.</span><span class="sxs-lookup"><span data-stu-id="bab40-156">Code that does not depend on a particular data type can be reused with various data types if it is generic.</span></span> <span data-ttu-id="bab40-157">Sie können ihn häufig sogar für einen Datentypen wiederverwenden, den Sie ursprünglich nicht vorausbestimmt haben.</span><span class="sxs-lookup"><span data-stu-id="bab40-157">You can often reuse it even with a data type that you did not originally predict.</span></span>  
  
- <span data-ttu-id="bab40-158">**IDE-Unterstützung.**</span><span class="sxs-lookup"><span data-stu-id="bab40-158">**IDE Support.**</span></span> <span data-ttu-id="bab40-159">Wenn Sie einen konstruierten Typ verwenden, der aus einem generischen Typ deklariert wurde, können Sie durch die IDE (Integrated Development Environment, integrierte Entwicklungsumgebung) weitere Unterstützung beim Verfassen des Codes erhalten.</span><span class="sxs-lookup"><span data-stu-id="bab40-159">When you use a constructed type declared from a generic type, the integrated development environment (IDE) can give you more support while you are developing your code.</span></span> <span data-ttu-id="bab40-160">Beispielsweise kann IntelliSense Ihnen die typspezifischen Optionen für ein Argument eines Konstruktors oder einer Methode anzeigen.</span><span class="sxs-lookup"><span data-stu-id="bab40-160">For example, IntelliSense can show you the type-specific options for an argument to a constructor or method.</span></span>  
  
- <span data-ttu-id="bab40-161">**Generische Algorithmen.**</span><span class="sxs-lookup"><span data-stu-id="bab40-161">**Generic Algorithms.**</span></span> <span data-ttu-id="bab40-162">Abstrakte Algorithmen, die typunabhängig sind, sind gute Kandidaten für generische Typen.</span><span class="sxs-lookup"><span data-stu-id="bab40-162">Abstract algorithms that are type-independent are good candidates for generic types.</span></span> <span data-ttu-id="bab40-163">Beispielsweise kann eine generische Prozedur, die Elemente mithilfe der <xref:System.IComparable> -Schnittstelle sortiert, für jeden Datentyp verwendet werden, der <xref:System.IComparable>implementiert.</span><span class="sxs-lookup"><span data-stu-id="bab40-163">For example, a generic procedure that sorts items using the <xref:System.IComparable> interface can be used with any data type that implements <xref:System.IComparable>.</span></span>  
  
## <a name="constraints"></a><span data-ttu-id="bab40-164">Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="bab40-164">Constraints</span></span>  

 <span data-ttu-id="bab40-165">Obwohl der Code in der Definition eines generischen Typs so typunabhängig wie möglich sein sollte, müssen Sie eventuell eine bestimmte Fähigkeit irgendeines Datentyps erfordern, der dem generischen Datentyp bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="bab40-165">Although the code in a generic type definition should be as type-independent as possible, you might need to require a certain capability of any data type supplied to your generic type.</span></span> <span data-ttu-id="bab40-166">Wenn Sie z. B. zwei Elemente vergleichen möchten, um sie zu sortieren oder abzugleichen, muss ihr Datentyp die <xref:System.IComparable> -Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="bab40-166">For example, if you want to compare two items for the purpose of sorting or collating, their data type must implement the <xref:System.IComparable> interface.</span></span> <span data-ttu-id="bab40-167">Sie können diese Anforderung erzwingen, indem Sie dem Typparameter eine *Einschränkung* hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="bab40-167">You can enforce this requirement by adding a *constraint* to the type parameter.</span></span>  
  
### <a name="example-of-a-constraint"></a><span data-ttu-id="bab40-168">Beispiel für eine Einschränkung</span><span class="sxs-lookup"><span data-stu-id="bab40-168">Example of a Constraint</span></span>  

 <span data-ttu-id="bab40-169">Im folgenden Beispiel wird die Rumpfdefinition einer Klasse mit einer Einschränkung gezeigt, die für das Typargument erfordert, dass es <xref:System.IComparable>implementiert.</span><span class="sxs-lookup"><span data-stu-id="bab40-169">The following example shows a skeleton definition of a class with a constraint that requires the type argument to implement <xref:System.IComparable>.</span></span>  
  
 [!code-vb[VbVbalrDataTypes#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#5)]  
  
 <span data-ttu-id="bab40-170">Wird in späterem Code versucht, eine Klasse aus `itemManager` zu erstellen, wozu ein Typ bereitgestellt wird, der <xref:System.IComparable>nicht implementiert, signalisiert der Compiler einen Fehler.</span><span class="sxs-lookup"><span data-stu-id="bab40-170">If subsequent code attempts to construct a class from `itemManager` supplying a type that does not implement <xref:System.IComparable>, the compiler signals an error.</span></span>  
  
### <a name="types-of-constraints"></a><span data-ttu-id="bab40-171">Typen von Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="bab40-171">Types of Constraints</span></span>  

 <span data-ttu-id="bab40-172">In einer Einschränkung können die folgenden Anforderungen in beliebiger Kombination angegeben werden:</span><span class="sxs-lookup"><span data-stu-id="bab40-172">Your constraint can specify the following requirements in any combination:</span></span>  
  
- <span data-ttu-id="bab40-173">Das Typargument muss mindestens eine Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="bab40-173">The type argument must implement one or more interfaces</span></span>  
  
- <span data-ttu-id="bab40-174">Das Typargument darf nur den Typ einer einzigen Klasse haben oder von einer einzigen Klasse erben.</span><span class="sxs-lookup"><span data-stu-id="bab40-174">The type argument must be of the type of, or inherit from, at most one class</span></span>  
  
- <span data-ttu-id="bab40-175">Das Typargument muss einen parameterlosen Konstruktor für den Code verfügbar machen, der Objekte aus dem Typargument erstellt.</span><span class="sxs-lookup"><span data-stu-id="bab40-175">The type argument must expose a parameterless constructor accessible to the code that creates objects from it</span></span>  
  
- <span data-ttu-id="bab40-176">Das Typargument muss ein *Verweistyp*sein, oder es muss ein *Werttyp* sein.</span><span class="sxs-lookup"><span data-stu-id="bab40-176">The type argument must be a *reference type*, or it must be a *value type*</span></span>  
  
 <span data-ttu-id="bab40-177">Wenn Sie mehrere Einschränkungen erzwingen müssen, verwenden Sie eine durch Trennzeichen getrennte *Einschränkungsliste* in geschweiften Klammern (`{ }`).</span><span class="sxs-lookup"><span data-stu-id="bab40-177">If you need to impose more than one requirement, you use a comma-separated *constraint list* inside braces (`{ }`).</span></span> <span data-ttu-id="bab40-178">Wenn Sie einen barrierefreien Konstruktor benötigen, fügen Sie das [neue Operator](../../../language-reference/operators/new-operator.md) Schlüsselwort in die Liste ein.</span><span class="sxs-lookup"><span data-stu-id="bab40-178">To require an accessible constructor, you include the [New Operator](../../../language-reference/operators/new-operator.md) keyword in the list.</span></span> <span data-ttu-id="bab40-179">Um festzulegen, dass ein Verweistyp erforderlich ist, fügen Sie das `Class` -Schlüsselwort ein. Um festzulegen, dass ein Werttyp erforderlich ist, fügen Sie das `Structure` -Schlüsselwort ein.</span><span class="sxs-lookup"><span data-stu-id="bab40-179">To require a reference type, you include the `Class` keyword; to require a value type, you include the `Structure` keyword.</span></span>  
  
 <span data-ttu-id="bab40-180">Weitere Informationen über Einschränkungen finden Sie unter [Type List](../../../language-reference/statements/type-list.md).</span><span class="sxs-lookup"><span data-stu-id="bab40-180">For more information on constraints, see [Type List](../../../language-reference/statements/type-list.md).</span></span>  
  
### <a name="example-of-multiple-constraints"></a><span data-ttu-id="bab40-181">Beispiel für mehrere Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="bab40-181">Example of Multiple Constraints</span></span>  

 <span data-ttu-id="bab40-182">Im folgenden Beispiel wird die Rumpfdefinition einer generischen Klasse mit einer Einschränkungsliste für den Typparameter veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="bab40-182">The following example shows a skeleton definition of a generic class with a constraint list on the type parameter.</span></span> <span data-ttu-id="bab40-183">In dem Code, der eine Instanz dieser Klasse erstellt, muss das Typargument sowohl die <xref:System.IComparable> -Schnittstelle als auch die <xref:System.IDisposable> -Schnittstelle implementieren, ein Verweistyp sein und einen zugänglichen parameterlosen Konstruktor verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="bab40-183">In the code that creates an instance of this class, the type argument must implement both the <xref:System.IComparable> and <xref:System.IDisposable> interfaces, be a reference type, and expose an accessible parameterless constructor.</span></span>  
  
 [!code-vb[VbVbalrDataTypes#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#6)]  
  
## <a name="important-terms"></a><span data-ttu-id="bab40-184">Wichtige Begriffe</span><span class="sxs-lookup"><span data-stu-id="bab40-184">Important Terms</span></span>  

 <span data-ttu-id="bab40-185">Für generische Typen werden die folgenden Begriffe verwendet:</span><span class="sxs-lookup"><span data-stu-id="bab40-185">Generic types introduce and use the following terms:</span></span>  
  
- <span data-ttu-id="bab40-186">*Generischer Typ*.</span><span class="sxs-lookup"><span data-stu-id="bab40-186">*Generic Type*.</span></span> <span data-ttu-id="bab40-187">Eine Definition einer Klasse, einer Struktur, einer Schnittstelle, einer Prozedur oder eines Delegaten, für deren bzw. dessen Deklaration Sie mindestens einen Datentyp angeben.</span><span class="sxs-lookup"><span data-stu-id="bab40-187">A definition of a class, structure, interface, procedure, or delegate for which you supply at least one data type when you declare it.</span></span>  
  
- <span data-ttu-id="bab40-188">*Typparameter*.</span><span class="sxs-lookup"><span data-stu-id="bab40-188">*Type Parameter*.</span></span> <span data-ttu-id="bab40-189">In der Definition eines generischen Typs ein Platzhalter für einen Datentyp, den Sie beim Deklarieren des Typs angeben.</span><span class="sxs-lookup"><span data-stu-id="bab40-189">In a generic type definition, a placeholder for a data type you supply when you declare the type.</span></span>  
  
- <span data-ttu-id="bab40-190">*Typargument*.</span><span class="sxs-lookup"><span data-stu-id="bab40-190">*Type Argument*.</span></span> <span data-ttu-id="bab40-191">Ein spezieller Datentyp, der einen Typparameter ersetzt, wenn Sie einen konstruierten Typ aus einem generischen Typ deklarieren.</span><span class="sxs-lookup"><span data-stu-id="bab40-191">A specific data type that replaces a type parameter when you declare a constructed type from a generic type.</span></span>  
  
- <span data-ttu-id="bab40-192">*Einschränkung*.</span><span class="sxs-lookup"><span data-stu-id="bab40-192">*Constraint*.</span></span> <span data-ttu-id="bab40-193">Eine Bedingung für einen Typparameter, die das Typargument einschränkt, das Sie für den Typparameter angeben können.</span><span class="sxs-lookup"><span data-stu-id="bab40-193">A condition on a type parameter that restricts the type argument you can supply for it.</span></span> <span data-ttu-id="bab40-194">Eine Einschränkung kann festlegen, dass das Typargument eine bestimmte Schnittstelle implementieren, eine bestimmte Klasse sein oder von einer bestimmten Klasse erben, einen zugänglichen parameterlosen Konstruktor haben oder ein Verweistyp oder ein Werttyp sein muss.</span><span class="sxs-lookup"><span data-stu-id="bab40-194">A constraint can require that the type argument must implement a particular interface, be or inherit from a particular class, have an accessible parameterless constructor, or be a reference type or a value type.</span></span> <span data-ttu-id="bab40-195">Sie können diese Einschränkungen kombinieren, Sie können aber maximal eine Klasse angeben.</span><span class="sxs-lookup"><span data-stu-id="bab40-195">You can combine these constraints, but you can specify at most one class.</span></span>  
  
- <span data-ttu-id="bab40-196">*Konstruierter Typ*.</span><span class="sxs-lookup"><span data-stu-id="bab40-196">*Constructed Type*.</span></span> <span data-ttu-id="bab40-197">Eine Klasse, eine Struktur, eine Schnittstelle, eine Prozedur oder ein Delegat, die bzw. der aus einem generischen Typ deklariert wird, indem Typargumente für dessen Typparameter angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="bab40-197">A class, structure, interface, procedure, or delegate declared from a generic type by supplying type arguments for its type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bab40-198">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="bab40-198">See also</span></span>

- [<span data-ttu-id="bab40-199">Datentypen</span><span class="sxs-lookup"><span data-stu-id="bab40-199">Data Types</span></span>](index.md)
- [<span data-ttu-id="bab40-200">Typzeichen</span><span class="sxs-lookup"><span data-stu-id="bab40-200">Type Characters</span></span>](type-characters.md)
- [<span data-ttu-id="bab40-201">Wert- und Verweistypen</span><span class="sxs-lookup"><span data-stu-id="bab40-201">Value Types and Reference Types</span></span>](value-types-and-reference-types.md)
- [<span data-ttu-id="bab40-202">Typkonvertierung in Visual Basic</span><span class="sxs-lookup"><span data-stu-id="bab40-202">Type Conversions in Visual Basic</span></span>](type-conversions.md)
- [<span data-ttu-id="bab40-203">Problembehandlung bei Datentypen</span><span class="sxs-lookup"><span data-stu-id="bab40-203">Troubleshooting Data Types</span></span>](troubleshooting-data-types.md)
- [<span data-ttu-id="bab40-204">Datentypen</span><span class="sxs-lookup"><span data-stu-id="bab40-204">Data Types</span></span>](../../../language-reference/data-types/index.md)
- [<span data-ttu-id="bab40-205">Natürlich</span><span class="sxs-lookup"><span data-stu-id="bab40-205">Of</span></span>](../../../language-reference/statements/of-clause.md)
- [<span data-ttu-id="bab40-206">Möglichst</span><span class="sxs-lookup"><span data-stu-id="bab40-206">As</span></span>](../../../language-reference/statements/as-clause.md)
- [<span data-ttu-id="bab40-207">Object Data Type</span><span class="sxs-lookup"><span data-stu-id="bab40-207">Object Data Type</span></span>](../../../language-reference/data-types/object-data-type.md)
- [<span data-ttu-id="bab40-208">Kovarianz und Kontravarianz</span><span class="sxs-lookup"><span data-stu-id="bab40-208">Covariance and Contravariance</span></span>](../../concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="bab40-209">Iteratoren</span><span class="sxs-lookup"><span data-stu-id="bab40-209">Iterators</span></span>](../../concepts/iterators.md)
